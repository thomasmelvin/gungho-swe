!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
!> @brief     Tests for mesh_tools/source/support/gen_planar_mod.F90
!>
!> @details   [1]  Constructor can be called with program default args.
!>            [2]  Constructor fails with invalid args.
!>            [3]  Type generates mesh with appropriate dimensions for args.
!>            [4]  Mesh contains correct values at fixed points for fixed args.
!>            [5]  Mesh connectivity has correct dimensions.
!>            [6]  Mesh connectivity has correct values at fixed points.
!>            [7]  Mesh coords have correct values at fixed points.
!>
module gen_planar_mod_test

  use constants_mod,                  only: i_def, r_def, str_def, l_def, &
                                            imdi, str_longlong
  use gen_planar_mod,                 only: gen_planar_type, NON_PERIODIC_ID
  use global_mesh_map_collection_mod, only: global_mesh_map_collection_type
  use global_mesh_map_mod,            only: global_mesh_map_type

  use pFUnit_Mod

  use reference_element_mod,          only: reference_cube_type, &
                                            W, S, E, N

  use mesh_config_mod, only: coord_sys_ll, coord_sys_xyz,             &
                             geometry_spherical, geometry_planar,     &
                             topology_non_periodic, topology_channel, &
                             topology_periodic

  implicit none

  private
  public :: test_biperiodic_2x2,     &
            test_biperiodic_5x4,     &
            test_periodic_x_5x4,     &
            test_periodic_y_5x4,     &
            test_non_periodic_5x4,   &
            test_1x1_non_periodic,   &
            test_1x2_non_periodic,   &
            test_1x3_non_periodic,   &
            test_2x1_non_periodic,   &
            test_3x1_non_periodic,   &
            test_2x1_trench_x,       &
            test_3x1_trench_x,       &
            test_2x2_trench_x,       &
            test_3x2_trench_x,       &
            test_1x2_trench_y,       &
            test_1x3_trench_y,       &
            test_2x2_trench_y,       &
            test_2x3_trench_y,       &
            test_1x1_noncartesian,   &
            test_1x1_rotate_south,   &
            test_1x1_rotate_north

  @TestCase
  type, extends(TestCase), public :: gen_planar_test_type
    private
    integer(i_def), allocatable :: faces_on_face(:,:)
    integer(i_def), allocatable :: nodes_on_face(:,:)
    integer(i_def), allocatable :: edges_on_face(:,:)
    integer(i_def), allocatable :: nodes_on_edge(:,:)
    real(r_def),    allocatable :: coords(:,:)
    real(r_def),    allocatable :: face_coords(:,:)

  contains
    procedure :: setUp
    procedure :: tearDown
    procedure :: test_biperiodic_2x2
    procedure :: test_biperiodic_5x4
    procedure :: test_periodic_x_5x4
    procedure :: test_periodic_y_5x4
    procedure :: test_non_periodic_5x4
    procedure :: test_1x1_non_periodic
    procedure :: test_1x2_non_periodic
    procedure :: test_1x3_non_periodic
    procedure :: test_2x1_non_periodic
    procedure :: test_3x1_non_periodic
    procedure :: test_2x1_trench_x
    procedure :: test_3x1_trench_x
    procedure :: test_2x2_trench_x
    procedure :: test_3x2_trench_x
    procedure :: test_1x2_trench_y
    procedure :: test_1x3_trench_y
    procedure :: test_2x2_trench_y
    procedure :: test_2x3_trench_y
    procedure :: test_1x1_noncartesian
    procedure :: test_1x1_rotate_north
    procedure :: test_1x1_rotate_south
  end type gen_planar_test_type

  character(str_def), parameter :: mesh_name = 'unit_test'
  integer(i_def),     parameter :: edge_cells_x = 5
  integer(i_def),     parameter :: edge_cells_y = 4
  real(r_def),        parameter :: domain_x = 30000.0
  real(r_def),        parameter :: domain_y = 8000.0
  integer(i_def),     parameter :: npanels = 1
  integer(i_def),     parameter :: nmaps = 1
  integer(i_def),     parameter :: ncells = 20

  character(str_def), parameter :: target_mesh_names(nmaps) = ['unit_test_target']
  integer(i_def),     parameter :: target_edge_cells_x(nmaps) = [10]
  integer(i_def),     parameter :: target_edge_cells_y(nmaps) = [12]

  real(r_def),        parameter :: eps = 1E-09_r_def
contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    allocate( this%faces_on_face(4, edge_cells_x*edge_cells_y) )
    allocate( this%face_coords(2, edge_cells_x*edge_cells_y) )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    if (allocated(this%faces_on_face)) deallocate( this%faces_on_face )
    if (allocated(this%nodes_on_face)) deallocate( this%nodes_on_face )
    if (allocated(this%edges_on_face)) deallocate( this%edges_on_face )
    if (allocated(this%nodes_on_edge)) deallocate( this%nodes_on_edge )
    if (allocated(this%coords))        deallocate( this%coords )
    if (allocated(this%face_coords))   deallocate( this%face_coords )

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_biperiodic_2x2( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .true.
    logical(l_def) :: periodic_y = .true.

    integer(i_def) :: edge_cells_x = 2
    integer(i_def) :: edge_cells_y = 2

    integer(i_def)           :: row,i
    integer(i_def), pointer  :: edge_cell_ids(:) => null()
    integer(i_def)           :: icell

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element, &
                                mesh_name=mesh_name,            &
                                geometry=geometry_planar,       &
                                topology=topology_periodic,     &
                                coord_sys=coord_sys_xyz,        &
                                edge_cells_x=edge_cells_x,      &
                                edge_cells_y=edge_cells_y,      &
                                periodic_x=periodic_x,          &
                                periodic_y=periodic_y,          &
                                domain_x=domain_x,              &
                                domain_y=domain_y )

    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name,   trim(test_str(1)) )
    @assertEqual( 'planar',    trim(test_str(2)) )
    @assertEqual( 'periodic',  trim(test_str(3)) )
    @assertEqual( 'xyz',       trim(test_str(4)) )
    @assertEqual( "geometry=planar;topology=periodic;coord_sys=xyz;edge_cells_x=2;edge_cells_y=2;periodic_x=T;periodic_y=T;domain_x=30000.00;domain_y=8000.00", trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, 4, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 8, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, 4, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual(this%nodes_on_face(:,1), (/  1, 2, 3, 4 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,2), (/  2, 1, 4, 3 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,3), (/  4, 3, 2, 1 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,4), (/  3, 4, 1, 2 /), "Incorrect vertex sequence on faces.")

    ! Test northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) /= NON_PERIODIC_ID )
    end do

    ! Test Eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) /= NON_PERIODIC_ID )
    end do

    ! Test Southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) /= NON_PERIODIC_ID )
    end do

    ! Test Western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) /= NON_PERIODIC_ID )
    end do

    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1), (/  2, 3, 2, 3 /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,2), (/  1, 4, 1, 4 /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,3), (/  4, 1, 4, 1 /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,4), (/  3, 2, 3, 2 /), "Incorrect faces_on_face connectivity.")

    @assertEqual(this%edges_on_face(:,1), (/  1, 2, 3, 4 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,2), (/  3, 5, 1, 6 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,3), (/  7, 4, 8, 2 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,4), (/  8, 6, 7, 5 /), "Incorrect edges_on_face connectivity.")

    @assertEqual((/ 4,1 /), this%nodes_on_edge(:,1), "Incorrect nodes_on_edge connectivity.")
    @assertEqual((/ 1,2 /), this%nodes_on_edge(:,2), "Incorrect nodes_on_edge connectivity.")
    @assertEqual((/ 3,2 /), this%nodes_on_edge(:,3), "Incorrect nodes_on_edge connectivity.")
    @assertEqual((/ 4,3 /), this%nodes_on_edge(:,4), "Incorrect nodes_on_edge connectivity.")
    @assertEqual((/ 2,1 /), this%nodes_on_edge(:,5), "Incorrect nodes_on_edge connectivity.")
    @assertEqual((/ 3,4 /), this%nodes_on_edge(:,6), "Incorrect nodes_on_edge connectivity.")
    @assertEqual((/ 1,4 /), this%nodes_on_edge(:,7), "Incorrect nodes_on_edge connectivity.")
    @assertEqual((/ 2,3 /), this%nodes_on_edge(:,8), "Incorrect nodes_on_edge connectivity.")


    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )

    ! Mesh coordinates have expected values at certain points
    @assertTrue(this%coords(:,1) == (/ -15000.0_r_def,  0.0_r_def    /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,2) == (/  0.0_r_def,      0.0_r_def    /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,3) == (/  0.0_r_def,      4000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,4) == (/ -15000.0_r_def,  4000.0_r_def /), "Incorrect mesh coordinates.")

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_biperiodic_2x2


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_biperiodic_5x4( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen

    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .true.
    logical(l_def) :: periodic_y = .true.

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    integer(i_def)      :: test_npanels
    integer(i_def)      :: test_edge_cells_x
    integer(i_def)      :: test_edge_cells_y
    integer(i_def)      :: test_nmaps

    character(str_def), allocatable :: test_target_mesh_names(:)
    integer(i_def),     allocatable :: test_maps_edge_cells_x(:)
    integer(i_def),     allocatable :: test_maps_edge_cells_y(:)

    type(global_mesh_map_collection_type), pointer :: global_mesh_maps => null()
    type(global_mesh_map_type),            pointer :: global_mesh_map  => null()

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type(                               &
                   reference_element = cube_element,          &
                   mesh_name    = mesh_name,                  &
                   geometry     = geometry_planar,            &
                   topology     = topology_periodic,          &
                   coord_sys    = coord_sys_xyz,              &
                   edge_cells_x = edge_cells_x,               &
                   edge_cells_y = edge_cells_y,               &
                   periodic_x   = periodic_x,                 &
                   periodic_y   = periodic_y,                 &
                   domain_x     = domain_x,                   &
                   domain_y     = domain_y,                   &
                   target_mesh_names   = target_mesh_names,   &
                   target_edge_cells_x = target_edge_cells_x, &
                   target_edge_cells_y = target_edge_cells_y  )

    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name           = test_str(1),             &
                                geometry            = test_str(2),             &
                                topology            = test_str(3),             &
                                coord_sys           = test_str(4),             &
                                constructor_inputs  = big_test_str,            &
                                npanels             = test_npanels,            &
                                edge_cells_x        = test_edge_cells_x,       &
                                edge_cells_y        = test_edge_cells_y,       &
                                nmaps               = test_nmaps,              &
                                target_mesh_names   = test_target_mesh_names,  &
                                maps_edge_cells_x   = test_maps_edge_cells_x,  &
                                maps_edge_cells_y   = test_maps_edge_cells_y )

    @assertEqual( mesh_name,  trim(test_str(1)) )
    @assertEqual( 'planar',   trim(test_str(2)) )
    @assertEqual( 'periodic', trim(test_str(3)) )
    @assertEqual( 'xyz',      trim(test_str(4)) )
    @assertEqual( "geometry=planar;topology=periodic;coord_sys=xyz;edge_cells_x=5;edge_cells_y=4;periodic_x=T;periodic_y=T;domain_x=30000.00;domain_y=8000.00;target_mesh_names=['unit_test_target'];target_edge_cells_x=[10];target_edge_cells_y=[12]", trim(big_test_str) )
    @assertEqual( npanels, test_npanels )
    @assertEqual( edge_cells_x, test_edge_cells_x )
    @assertEqual( edge_cells_y, test_edge_cells_y )
    @assertEqual( nmaps, test_nmaps )
    @assertEqual( trim(target_mesh_names(1)), trim(test_target_mesh_names(1)) )
    @assertEqual( target_edge_cells_x, test_maps_edge_cells_x )
    @assertEqual( target_edge_cells_y, test_maps_edge_cells_y )
    @assertEqual( nmaps, size(test_target_mesh_names   ) )
    @assertEqual( nmaps, size(test_maps_edge_cells_x ) )
    @assertEqual( nmaps, size(test_maps_edge_cells_y ) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, &
                                  nodes_per_face,      &
                                  edges_per_face,      &
                                  nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, edge_cells_x*edge_cells_y,   "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 2*edge_cells_x*edge_cells_y, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, edge_cells_x*edge_cells_y,   "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual(this%nodes_on_face(:,1),  (/  1, 2,  3,  4 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,20), (/ 10, 4, 16, 20 /), "Incorrect vertex sequence on faces.")

    ! Mesh connectivity is complete
    @assertTrue(minval(this%faces_on_face, 2) /= 0, "Incomplete faces_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1),  (/  5,  6,  2, 16 /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,11), (/ 15, 16, 12,  6 /), "Incorrect faces_on_face connectivity.")

    @assertEqual(this%edges_on_face(:,1),  (/  1,  2,  3,  4 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,20), (/ 40, 15, 36, 35 /), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1),  (/  4,  1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,40), (/ 20, 10 /), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )

    ! Mesh coordinates have expected values at certain points
    @assertTrue(this%coords(:,1)  == (/ -12000.0_r_def,  2000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,20) == (/  12000.0_r_def, -2000.0_r_def /), "Incorrect mesh coordinates.")

    ! Cell coordinates have expected values at certain points
    @assertTrue(this%face_coords(:,1)  == (/  -9000.0_r_def,  3000.0_r_def /), "Incorrect cell coordinates.")
    @assertTrue(this%face_coords(:,20) == (/  15000.0_r_def, -3000.0_r_def /), "Incorrect cell coordinates.")

    @assertTrue( trim(test_coord_units_x) == 'm')
    @assertTrue( trim(test_coord_units_y) == 'm')

    ! Retrieve global mesh maps
    nullify(global_mesh_maps)
    global_mesh_maps => mesh_gen%get_global_mesh_maps()
    @assertAssociated(global_mesh_maps)

    ! Although no actual global mesh maps have written to file maps have been created
    ! for global meshes in the order they are virtually listed,
    ! i.e. mesh "unit_test", id=1
    !      mesh "unit_test_target", id=2
    nullify(global_mesh_map)
    global_mesh_map  => global_mesh_maps%get_global_mesh_map(1,2)

    @assertAssociated( global_mesh_map )
    @assertEqual( ncells, global_mesh_map%get_nsource_cells() )
    @assertEqual( 6,  global_mesh_map%get_ntarget_cells_per_source_cell() )
    @assertEqual( 1,  global_mesh_map%get_source_id() )
    @assertEqual( 2,  global_mesh_map%get_target_id() )
    @assertEqual( 2, global_mesh_map%get_ntarget_cells_per_source_x() )
    @assertEqual( 3, global_mesh_map%get_ntarget_cells_per_source_y() )

    call mesh_gen%clear()
    if ( allocated(test_target_mesh_names) ) deallocate( test_target_mesh_names )
    if ( allocated(test_maps_edge_cells_x) ) deallocate( test_maps_edge_cells_x )
    if ( allocated(test_maps_edge_cells_y) ) deallocate( test_maps_edge_cells_y )

    nullify(global_mesh_maps)
    nullify(global_mesh_map)

  end subroutine test_biperiodic_5x4


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_periodic_x_5x4( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .true.
    logical(l_def) :: periodic_y = .false.

    integer(i_def)           :: row,i
    integer(i_def), pointer  :: edge_cell_ids(:) => null()
    integer(i_def)           :: icell

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element, &
                                mesh_name=mesh_name,            &
                                geometry=geometry_planar,       &
                                topology=topology_channel,      &
                                coord_sys=coord_sys_xyz,        &
                                edge_cells_x=edge_cells_x,      &
                                edge_cells_y=edge_cells_y,      &
                                periodic_x=periodic_x,          &
                                periodic_y=periodic_y,          &
                                domain_x=domain_x,              &
                                domain_y=domain_y )


    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name, trim(test_str(1)) )
    @assertEqual( 'planar',  trim(test_str(2)) )
    @assertEqual( 'channel', trim(test_str(3)) )
    @assertEqual( 'xyz',     trim(test_str(4)) )
    @assertEqual( 'geometry=planar;topology=channel;coord_sys=xyz;edge_cells_x=5;edge_cells_y=4;periodic_x=T;periodic_y=F;domain_x=30000.00;domain_y=8000.00', trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, (edge_cells_x)*(edge_cells_y+1),  "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, (edge_cells_x*(edge_cells_y+1)) + (edge_cells_y*edge_cells_x), "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, edge_cells_x*edge_cells_y,        "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual(this%nodes_on_face(:,1),  (/  1, 2, 3, 4 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,20), (/ 25,21,16,20 /), "Incorrect vertex sequence on faces.")

    ! Test northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) == NON_PERIODIC_ID )
    end do

    ! Test Eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) /= NON_PERIODIC_ID )
    end do

    ! Test Southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) == NON_PERIODIC_ID )
    end do

    ! Test Western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) /= NON_PERIODIC_ID )
    end do

    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1),  (/  5, 6, 2, NON_PERIODIC_ID /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,11), (/ 15,16,12, 6 /), "Incorrect faces_on_face connectivity.")

    @assertEqual(this%edges_on_face(:,1),  (/  1, 2, 3, 4 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,20), (/ 44,45,36,35 /), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1), (/ 4,1 /),    "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,40), (/ 18,23 /), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )

    ! Mesh coordinates have expected values at certain points
    @assertTrue(this%coords(:,1)  == (/ -12000.0_r_def,  2000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,20) == (/  12000.0_r_def, -2000.0_r_def /), "Incorrect mesh coordinates.")

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_periodic_x_5x4


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_periodic_y_5x4( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .false.
    logical(l_def) :: periodic_y = .true.

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    integer(i_def) :: icell, row, i
    integer(i_def), pointer :: edge_cell_ids(:) => null()

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element, &
                                mesh_name=mesh_name,            &
                                geometry=geometry_planar,       &
                                topology=topology_channel,      &
                                coord_sys=coord_sys_xyz,        &
                                edge_cells_x=edge_cells_x,      &
                                edge_cells_y=edge_cells_y,      &
                                periodic_x=periodic_x,          &
                                periodic_y=periodic_y,          &
                                domain_x=domain_x,              &
                                domain_y=domain_y )


    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name, trim(test_str(1)) )
    @assertEqual( 'planar',  trim(test_str(2)) )
    @assertEqual( 'channel', trim(test_str(3)) )
    @assertEqual( 'xyz',     trim(test_str(4)) )
    @assertEqual( 'geometry=planar;topology=channel;coord_sys=xyz;edge_cells_x=5;edge_cells_y=4;periodic_x=F;periodic_y=T;domain_x=30000.00;domain_y=8000.00', trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, (edge_cells_x+1)*edge_cells_y,           "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, (edge_cells_x*edge_cells_y)+(edge_cells_y*(edge_cells_x+1)), "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, edge_cells_x*edge_cells_y,               "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity(this%nodes_on_face, this%nodes_on_edge, &
                                this%edges_on_face, this%faces_on_face)

    ! Mesh has expected vertex values on certain faces
    @assertEqual(this%nodes_on_face(:,1),  (/  1, 2, 3, 4 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,20), (/ 10,12,24,23 /), "Incorrect vertex sequence on faces.")


    ! Test northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) /= NON_PERIODIC_ID )
    end do

    ! Test eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) == NON_PERIODIC_ID )
    end do

    ! Test southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) /= NON_PERIODIC_ID )
    end do

    ! Test western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) == NON_PERIODIC_ID )
    end do

    @assertFalse( any(this%faces_on_face == imdi), "Incomplete faces_on_face connectivity.")
    @assertFalse( any(this%nodes_on_face == imdi), "Incomplete nodes_on_face connectivity.")
    @assertFalse( any(this%edges_on_face == imdi), "Incomplete edges_on_face connectivity.")
    @assertFalse( any(this%nodes_on_edge == imdi), "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1),  (/  NON_PERIODIC_ID,  6,  2, 16 /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,11), (/  NON_PERIODIC_ID, 16, 12,  6 /), "Incorrect faces_on_face connectivity.")

    @assertEqual(this%edges_on_face(:,1),  (/  1,  2,  3,  4 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,20), (/ 43, 16, 44, 37 /), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1),  (/  4,  1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,40), (/  20, 3 /), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )

    ! Mesh coordinates have expected values at certain points
    @assertTrue(this%coords(:,1)  == (/ -12000.0_r_def,  2000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,20) == (/  -6000.0_r_def, -2000.0_r_def /), "Incorrect mesh coordinates.")

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_periodic_y_5x4


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_non_periodic_5x4( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .false.
    logical(l_def) :: periodic_y = .false.

    integer(i_def) :: icell, row, i
    integer(i_def), pointer :: edge_cell_ids(:) => null()

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element,   &
                                mesh_name=mesh_name,              &
                                geometry = geometry_planar,       &
                                topology = topology_non_periodic, &
                                coord_sys=coord_sys_xyz,          &
                                edge_cells_x=edge_cells_x,        &
                                edge_cells_y=edge_cells_y,        &
                                periodic_x=periodic_x,            &
                                periodic_y=periodic_y,            &
                                domain_x=domain_x,                &
                                domain_y=domain_y )


    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name,      trim(test_str(1)) )
    @assertEqual( 'planar',       trim(test_str(2)) )
    @assertEqual( 'non_periodic', trim(test_str(3)) )
    @assertEqual( 'xyz',          trim(test_str(4)) )
    @assertEqual( 'geometry=planar;topology=non_periodic;coord_sys=xyz;edge_cells_x=5;edge_cells_y=4;periodic_x=F;periodic_y=F;domain_x=30000.00;domain_y=8000.00', trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, (edge_cells_x+1)*(edge_cells_y+1),           "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, (edge_cells_x*(edge_cells_y+1))+(edge_cells_y*(edge_cells_x+1)), "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, edge_cells_x*edge_cells_y,                   "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual(this%nodes_on_face(:,1),  (/  1, 2, 3, 4 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,20), (/ 29,30,24,23 /), "Incorrect vertex sequence on faces.")

    ! Mesh connectivity is complete (for interior cells only)

    ! Test Northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) == NON_PERIODIC_ID )
    end do

    ! Test Eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) == NON_PERIODIC_ID )
    end do

    ! Test Southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) == NON_PERIODIC_ID )
    end do

    ! Test Western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) == NON_PERIODIC_ID )
    end do

    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1),  (/ non_periodic_id,  6,  2, non_periodic_id /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,11), (/ non_periodic_id, 16, 12, 6 /), "Incorrect faces_on_face connectivity.")

    @assertEqual(this%edges_on_face(:,1),  (/  1, 2, 3, 4 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,20), (/ 47,48,49,37 /), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1),  (/  4, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,40), (/ 25,26 /), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )

    ! Mesh coordinates have expected values at certain points
    @assertTrue(this%coords(:,1)  == (/ -12000.0_r_def,   2000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,20) == (/  -6000.0_r_def,  -2000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,30) == (/  18000.0_r_def,  -4000.0_r_def /), "Incorrect mesh coordinates.")

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_non_periodic_5x4


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_2x1_trench_x( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .true.
    logical(l_def) :: periodic_y = .false.

    integer(i_def) :: edge_cells_x = 2
    integer(i_def) :: edge_cells_y = 1

    integer(i_def)           :: row,i
    integer(i_def), pointer  :: edge_cell_ids(:) => null()
    integer(i_def)           :: icell

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element, &
                                mesh_name=mesh_name,            &
                                geometry=geometry_planar,       &
                                topology=topology_channel,      &
                                coord_sys=coord_sys_xyz,        &
                                edge_cells_x=edge_cells_x,      &
                                edge_cells_y=edge_cells_y,      &
                                periodic_x=periodic_x,          &
                                periodic_y=periodic_y,          &
                                domain_x=domain_x,              &
                                domain_y=domain_y )


    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name, trim(test_str(1)) )
    @assertEqual( 'planar',  trim(test_str(2)) )
    @assertEqual( 'channel', trim(test_str(3)) )
    @assertEqual( 'xyz',     trim(test_str(4)) )
    @assertEqual( 'geometry=planar;topology=channel;coord_sys=xyz;edge_cells_x=2;edge_cells_y=1;periodic_x=T;periodic_y=F;domain_x=30000.00;domain_y=8000.00', trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, 4, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 6, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, 2, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual(this%nodes_on_face(:,1), (/ 1, 2, 3, 4 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,2), (/ 2, 1, 4, 3 /), "Incorrect vertex sequence on faces.")

    ! Test northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) == NON_PERIODIC_ID )
    end do

    ! Test Eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) /= NON_PERIODIC_ID )
    end do

    ! Test Southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) == NON_PERIODIC_ID )
    end do

    ! Test Western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) /= NON_PERIODIC_ID )
    end do

    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1), (/  2, NON_PERIODIC_ID, 2, NON_PERIODIC_ID /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,2), (/  1, NON_PERIODIC_ID, 1, NON_PERIODIC_ID /), "Incorrect faces_on_face connectivity.")

    @assertEqual(this%edges_on_face(:,1), (/ 1, 2, 3, 4 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,2), (/ 3, 5, 1, 6 /), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1), (/ 4, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,2), (/ 1, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,3), (/ 3, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,4), (/ 4, 3 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,5), (/ 2, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,6), (/ 3, 4 /), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )

    ! Mesh coordinates have expected values at certain points
    @assertTrue(this%coords(:,1) == (/ -15000.0_r_def,    0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,2) == (/  0.0_r_def,        0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,3) == (/  0.0_r_def,     8000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,4) == (/ -15000.0_r_def, 8000.0_r_def /), "Incorrect mesh coordinates.")

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_2x1_trench_x


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_3x1_trench_x( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .true.
    logical(l_def) :: periodic_y = .false.

    integer(i_def) :: edge_cells_x = 3
    integer(i_def) :: edge_cells_y = 1

    integer(i_def)           :: row,i
    integer(i_def), pointer  :: edge_cell_ids(:) => null()
    integer(i_def)           :: icell

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element, &
                                mesh_name=mesh_name,            &
                                geometry=geometry_planar,       &
                                topology=topology_channel,      &
                                coord_sys=coord_sys_xyz,        &
                                edge_cells_x=edge_cells_x,      &
                                edge_cells_y=edge_cells_y,      &
                                periodic_x=periodic_x,          &
                                periodic_y=periodic_y,          &
                                domain_x=domain_x,              &
                                domain_y=domain_y )


    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name, trim(test_str(1)) )
    @assertEqual( 'planar',  trim(test_str(2)) )
    @assertEqual( 'channel', trim(test_str(3)) )
    @assertEqual( 'xyz',     trim(test_str(4)) )
    @assertEqual( 'geometry=planar;topology=channel;coord_sys=xyz;edge_cells_x=3;edge_cells_y=1;periodic_x=T;periodic_y=F;domain_x=30000.00;domain_y=8000.00', trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, 6, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 9, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, 3, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual(this%nodes_on_face(:,1), (/ 1, 2, 3, 4 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,2), (/ 2, 5, 6, 3 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,3), (/ 5, 1, 4, 6 /), "Incorrect vertex sequence on faces.")

    ! Test northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) == NON_PERIODIC_ID )
    end do

    ! Test Eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) /= NON_PERIODIC_ID )
    end do

    ! Test Southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) == NON_PERIODIC_ID )
    end do

    ! Test Western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) /= NON_PERIODIC_ID )
    end do

    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual((/ 3, NON_PERIODIC_ID, 2, NON_PERIODIC_ID /), this%faces_on_face(:,1), "Incorrect faces_on_face connectivity.")
    @assertEqual((/ 1, NON_PERIODIC_ID, 3, NON_PERIODIC_ID /), this%faces_on_face(:,2), "Incorrect faces_on_face connectivity.")
    @assertEqual((/ 2, NON_PERIODIC_ID, 1, NON_PERIODIC_ID /), this%faces_on_face(:,3), "Incorrect faces_on_face connectivity.")

    @assertEqual(this%edges_on_face(:,1), (/ 1, 2, 3, 4 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,2), (/ 3, 5, 6, 7 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,3), (/ 6, 8, 1, 9 /), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1), (/ 4, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,2), (/ 1, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,3), (/ 3, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,4), (/ 4, 3 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,5), (/ 2, 5 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,6), (/ 6, 5 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,7), (/ 3, 6 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,8), (/ 5, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,9), (/ 6, 4 /), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )

    ! Mesh coordinates have expected values at certain points
    @assertTrue(this%coords(:,1) == (/ -10000.0_r_def,    0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,2) == (/  0.0_r_def,        0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,3) == (/  0.0_r_def,     8000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,4) == (/ -10000.0_r_def, 8000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,5) == (/  10000.0_r_def,    0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,6) == (/  10000.0_r_def, 8000.0_r_def /), "Incorrect mesh coordinates.")

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_3x1_trench_x


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_2x2_trench_x( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .true.
    logical(l_def) :: periodic_y = .false.

    integer(i_def) :: edge_cells_x = 2
    integer(i_def) :: edge_cells_y = 2

    integer(i_def)           :: row,i
    integer(i_def), pointer  :: edge_cell_ids(:) => null()
    integer(i_def)           :: icell

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element, &
                                mesh_name=mesh_name,            &
                                geometry=geometry_planar,       &
                                topology=topology_channel,      &
                                coord_sys=coord_sys_xyz,        &
                                edge_cells_x=edge_cells_x,      &
                                edge_cells_y=edge_cells_y,      &
                                periodic_x=periodic_x,          &
                                periodic_y=periodic_y,          &
                                domain_x=domain_x,              &
                                domain_y=domain_y )

    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name, trim(test_str(1)) )
    @assertEqual( 'planar',  trim(test_str(2)) )
    @assertEqual( 'channel', trim(test_str(3)) )
    @assertEqual( 'xyz',     trim(test_str(4)) )
    @assertEqual( 'geometry=planar;topology=channel;coord_sys=xyz;edge_cells_x=2;edge_cells_y=2;periodic_x=T;periodic_y=F;domain_x=30000.00;domain_y=8000.00', trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, 6,  "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 10, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, 4,  "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual(this%nodes_on_face(:,1), (/ 1, 2, 3, 4 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,2), (/ 2, 1, 4, 3 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,3), (/ 5, 6, 2, 1 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,4), (/ 6, 5, 1, 2 /), "Incorrect vertex sequence on faces.")

    ! Test northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) == NON_PERIODIC_ID )
    end do

    ! Test Eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) /= NON_PERIODIC_ID )
    end do

    ! Test Southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) == NON_PERIODIC_ID )
    end do

    ! Test Western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) /= NON_PERIODIC_ID )
    end do

    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1), (/  2, 3, 2, NON_PERIODIC_ID /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,2), (/  1, 4, 1, NON_PERIODIC_ID /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,3), (/  4, NON_PERIODIC_ID, 4 ,1 /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,4), (/  3, NON_PERIODIC_ID, 3, 2 /), "Incorrect faces_on_face connectivity.")

    @assertEqual(this%edges_on_face(:,1), (/ 1,  2, 3, 4 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,2), (/ 3,  5, 1, 6 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,3), (/ 7,  8, 9, 2 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,4), (/ 9, 10, 7, 5 /), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:, 1), (/ 4, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:, 2), (/ 1, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:, 3), (/ 3, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:, 4), (/ 4, 3 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:, 5), (/ 2, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:, 6), (/ 3, 4 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:, 7), (/ 1, 5 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:, 8), (/ 5, 6 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:, 9), (/ 2, 6 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,10), (/ 6, 5 /), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )

    ! Mesh coordinates have expected values at certain points
    @assertTrue(this%coords(:,1) == (/ -15000.0_r_def,     0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,2) == (/  0.0_r_def,         0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,3) == (/  0.0_r_def,      4000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,4) == (/ -15000.0_r_def,  4000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,5) == (/ -15000.0_r_def, -4000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,6) == (/  0.0_r_def, -4000.0_r_def /), "Incorrect mesh coordinates.")

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_2x2_trench_x


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_3x2_trench_x( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .true.
    logical(l_def) :: periodic_y = .false.

    integer(i_def) :: edge_cells_x = 3
    integer(i_def) :: edge_cells_y = 2

    integer(i_def)           :: row,i
    integer(i_def), pointer  :: edge_cell_ids(:) => null()
    integer(i_def)           :: icell

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element, &
                                mesh_name=mesh_name,            &
                                geometry=geometry_planar,       &
                                topology=topology_channel,      &
                                coord_sys=coord_sys_xyz,        &
                                edge_cells_x=edge_cells_x,      &
                                edge_cells_y=edge_cells_y,      &
                                periodic_x=periodic_x,          &
                                periodic_y=periodic_y,          &
                                domain_x=domain_x,              &
                                domain_y=domain_y )

    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name, trim(test_str(1)) )
    @assertEqual( 'planar',  trim(test_str(2)) )
    @assertEqual( 'channel', trim(test_str(3)) )
    @assertEqual( 'xyz',     trim(test_str(4)) )
    @assertEqual( 'geometry=planar;topology=channel;coord_sys=xyz;edge_cells_x=3;edge_cells_y=2;periodic_x=T;periodic_y=F;domain_x=30000.00;domain_y=8000.00', trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, 9,  "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 15, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, 6,  "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual(this%nodes_on_face(:,1), (/ 1, 2, 3, 4 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,2), (/ 2, 5, 6, 3 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,3), (/ 5, 1, 4, 6 /), "Incorrect vertex sequence on faces.")

    ! Test northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) == NON_PERIODIC_ID )
    end do

    ! Test Eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) /= NON_PERIODIC_ID )
    end do

    ! Test Southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) == NON_PERIODIC_ID )
    end do

    ! Test Western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) /= NON_PERIODIC_ID )
    end do

    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual((/ 3, 4, 2, NON_PERIODIC_ID /), this%faces_on_face(:,1), "Incorrect faces_on_face connectivity.")
    @assertEqual((/ 1, 5, 3, NON_PERIODIC_ID /), this%faces_on_face(:,2), "Incorrect faces_on_face connectivity.")
    @assertEqual((/ 2, 6, 1, NON_PERIODIC_ID /), this%faces_on_face(:,3), "Incorrect faces_on_face connectivity.")
    @assertEqual((/ 6, NON_PERIODIC_ID, 5, 1 /), this%faces_on_face(:,4), "Incorrect faces_on_face connectivity.")
    @assertEqual((/ 4, NON_PERIODIC_ID, 6, 2 /), this%faces_on_face(:,5), "Incorrect faces_on_face connectivity.")
    @assertEqual((/ 5, NON_PERIODIC_ID, 4, 3 /), this%faces_on_face(:,6), "Incorrect faces_on_face connectivity.")

    @assertEqual(this%edges_on_face(:,1), (/ 1, 2, 3, 4 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,2), (/ 3, 5, 6, 7 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,3), (/ 6, 8, 1, 9 /), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1), (/ 4, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,2), (/ 1, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,3), (/ 3, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,4), (/ 4, 3 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,5), (/ 2, 5 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,6), (/ 6, 5 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,7), (/ 3, 6 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,8), (/ 5, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,9), (/ 6, 4 /), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )

    ! Mesh coordinates have expected values at certain points
    @assertTrue(this%coords(:,1) == (/ -10000.0_r_def,     0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,2) == (/  0.0_r_def,         0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,3) == (/  0.0_r_def,      4000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,4) == (/ -10000.0_r_def,  4000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,5) == (/  10000.0_r_def,     0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,6) == (/  10000.0_r_def,  4000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,7) == (/ -10000.0_r_def, -4000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,8) == (/  0.0_r_def,     -4000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,9) == (/  10000.0_r_def, -4000.0_r_def /), "Incorrect mesh coordinates.")

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_3x2_trench_x


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine  test_1x2_trench_y( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .false.
    logical(l_def) :: periodic_y = .true.

    integer(i_def) :: edge_cells_x = 1
    integer(i_def) :: edge_cells_y = 2

    integer(i_def)           :: row,i
    integer(i_def), pointer  :: edge_cell_ids(:) => null()
    integer(i_def)           :: icell

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( cube_element, mesh_name,    &
                                geometry_planar,            &
                                topology_channel,           &
                                coord_sys_xyz,              &
                                edge_cells_x, edge_cells_y, &
                                periodic_x, periodic_y,     &
                                domain_x, domain_y )

    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name, trim(test_str(1)) )
    @assertEqual( 'planar',  trim(test_str(2)) )
    @assertEqual( 'channel', trim(test_str(3)) )
    @assertEqual( 'xyz',     trim(test_str(4)) )
    @assertEqual( 'geometry=planar;topology=channel;coord_sys=xyz;edge_cells_x=1;edge_cells_y=2;periodic_x=F;periodic_y=T;domain_x=30000.00;domain_y=8000.00', trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, 4, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 6, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, 2, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual(this%nodes_on_face(:,1), (/ 1, 2, 3, 4 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,2), (/ 4, 3, 2, 1 /), "Incorrect vertex sequence on faces.")

    ! Test northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) /= NON_PERIODIC_ID )
    end do

    ! Test Eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) == NON_PERIODIC_ID )
    end do

    ! Test Southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) /= NON_PERIODIC_ID )
    end do

    ! Test Western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) == NON_PERIODIC_ID )
    end do

    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1), (/  NON_PERIODIC_ID, 2, NON_PERIODIC_ID, 2 /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,2), (/  NON_PERIODIC_ID, 1, NON_PERIODIC_ID, 1 /), "Incorrect faces_on_face connectivity.")

    @assertEqual(this%edges_on_face(:,1), (/ 1, 2, 3, 4 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,2), (/ 5, 4, 6, 2 /), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1), (/ 4, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,2), (/ 1, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,3), (/ 3, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,4), (/ 4, 3 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,5), (/ 1, 4 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,6), (/ 2, 3 /), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )

    ! Mesh coordinates have expected values at certain points
    @assertTrue(this%coords(:,1) == (/ 0.0_r_def,      0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,2) == (/ 30000.0_r_def,  0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,3) == (/ 30000.0_r_def,  4000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,4) == (/ 0.0_r_def,      4000.0_r_def /), "Incorrect mesh coordinates.")

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_1x2_trench_y


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine  test_1x3_trench_y( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .false.
    logical(l_def) :: periodic_y = .true.

    integer(i_def) :: edge_cells_x = 1
    integer(i_def) :: edge_cells_y = 3

    integer(i_def)           :: row,i
    integer(i_def), pointer  :: edge_cell_ids(:) => null()
    integer(i_def)           :: icell

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    real(r_def) :: dy

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element, &
                                mesh_name=mesh_name,            &
                                geometry=geometry_planar,       &
                                topology=topology_channel,      &
                                edge_cells_x=edge_cells_x,      &
                                edge_cells_y=edge_cells_y,      &
                                periodic_x=periodic_x,          &
                                periodic_y=periodic_y,          &
                                domain_x=domain_x,              &
                                domain_y=domain_y,              &
                                coord_sys=coord_sys_xyz )

    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name, trim(test_str(1)) )
    @assertEqual( 'planar',  trim(test_str(2)) )
    @assertEqual( 'channel', trim(test_str(3)) )
    @assertEqual( 'xyz',     trim(test_str(4)) )
    @assertEqual( 'geometry=planar;topology=channel;coord_sys=xyz;edge_cells_x=1;edge_cells_y=3;periodic_x=F;periodic_y=T;domain_x=30000.00;domain_y=8000.00', trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, 6, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 9, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, 3, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual( (/ 1, 2, 3, 4 /), this%nodes_on_face(:,1), "Incorrect vertex sequence on faces.")
    @assertEqual( (/ 5, 6, 2, 1 /), this%nodes_on_face(:,2), "Incorrect vertex sequence on faces.")
    @assertEqual( (/ 4, 3, 6, 5 /), this%nodes_on_face(:,3), "Incorrect vertex sequence on faces.")

    ! Test northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) /= NON_PERIODIC_ID )
    end do

    ! Test Eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) == NON_PERIODIC_ID )
    end do

    ! Test Southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) /= NON_PERIODIC_ID )
    end do

    ! Test Western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) == NON_PERIODIC_ID )
    end do

    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1), (/  NON_PERIODIC_ID, 2, NON_PERIODIC_ID, 3 /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,2), (/  NON_PERIODIC_ID, 3, NON_PERIODIC_ID, 1 /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,3), (/  NON_PERIODIC_ID, 1, NON_PERIODIC_ID, 2 /), "Incorrect faces_on_face connectivity.")

    @assertEqual((/ 1, 2, 3, 4 /), this%edges_on_face(:,1), "Incorrect edges_on_face connectivity.")
    @assertEqual((/ 5, 6, 7, 2 /), this%edges_on_face(:,2), "Incorrect edges_on_face connectivity.")
    @assertEqual((/ 8, 4, 9, 6 /), this%edges_on_face(:,3), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1), (/ 4, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,2), (/ 1, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,3), (/ 3, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,4), (/ 4, 3 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,5), (/ 1, 5 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,6), (/ 5, 6 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,7), (/ 2, 6 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,8), (/ 5, 4 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,9), (/ 6, 3 /), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )

    dy = domain_y/3

    ! Mesh coordinates have expected values at certain points
    @assertTrue(this%coords(:,1) == (/ 0.0_r_def    ,  dy   /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,2) == (/ 30000.0_r_def,  dy   /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,3) == (/ 30000.0_r_def,  2*dy /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,4) == (/ 0.0_r_def,      2*dy /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,5) == (/ 0.0_r_def,      0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,6) == (/ 30000.0_r_def,  0.0_r_def /), "Incorrect mesh coordinates.")

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_1x3_trench_y


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine  test_2x2_trench_y( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .false.
    logical(l_def) :: periodic_y = .true.

    integer(i_def) :: edge_cells_x = 2
    integer(i_def) :: edge_cells_y = 2

    integer(i_def)           :: row,i
    integer(i_def), pointer  :: edge_cell_ids(:) => null()
    integer(i_def)           :: icell

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element, &
                                mesh_name=mesh_name,            &
                                geometry=geometry_planar,       &
                                topology=topology_channel,      &
                                edge_cells_x=edge_cells_x,      &
                                edge_cells_y=edge_cells_y,      &
                                periodic_x=periodic_x,          &
                                periodic_y=periodic_y,          &
                                domain_x=domain_x,              &
                                domain_y=domain_y,              &
                                coord_sys=coord_sys_xyz )

    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name, trim(test_str(1)) )
    @assertEqual( 'planar',  trim(test_str(2)) )
    @assertEqual( 'channel', trim(test_str(3)) )
    @assertEqual( 'xyz',     trim(test_str(4)) )
    @assertEqual( 'geometry=planar;topology=channel;coord_sys=xyz;edge_cells_x=2;edge_cells_y=2;periodic_x=F;periodic_y=T;domain_x=30000.00;domain_y=8000.00', trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes,  6, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 10, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces,  4, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual(this%nodes_on_face(:,1), (/ 1, 2, 3, 4 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,2), (/ 2, 5, 6, 3 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,3), (/ 4, 3, 2, 1 /), "Incorrect vertex sequence on faces.")
    @assertEqual(this%nodes_on_face(:,4), (/ 3, 6, 5, 2 /), "Incorrect vertex sequence on faces.")

    ! Test northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) /= NON_PERIODIC_ID )
    end do

    ! Test Eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) == NON_PERIODIC_ID )
    end do

    ! Test Southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) /= NON_PERIODIC_ID )
    end do

    ! Test Western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) == NON_PERIODIC_ID )
    end do

    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1), (/  NON_PERIODIC_ID, 3, 2, 3 /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,2), (/  1, 4, NON_PERIODIC_ID, 4 /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,3), (/  NON_PERIODIC_ID, 1, 4, 1 /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,4), (/  3, 2, NON_PERIODIC_ID, 2 /), "Incorrect faces_on_face connectivity.")


    @assertEqual(this%edges_on_face(:,1), (/ 1, 2,  3, 4 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,2), (/ 3, 5,  6, 7 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,3), (/ 8, 4,  9, 2 /), "Incorrect edges_on_face connectivity.")
    @assertEqual(this%edges_on_face(:,4), (/ 9, 7, 10, 5 /), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:, 1), (/ 4, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:, 2), (/ 1, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:, 3), (/ 3, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:, 4), (/ 4, 3 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:, 5), (/ 2, 5 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:, 6), (/ 6, 5 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:, 7), (/ 3, 6 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:, 8), (/ 1, 4 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:, 9), (/ 2, 3 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,10), (/ 5, 6 /), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )

    ! Mesh coordinates have expected values at certain points
    @assertTrue(this%coords(:,1) == (/ -15000.0_r_def,     0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,2) == (/      0.0_r_def,     0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,3) == (/      0.0_r_def,  4000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,4) == (/ -15000.0_r_def,  4000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,5) == (/  15000.0_r_def,     0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,6) == (/  15000.0_r_def,  4000.0_r_def /), "Incorrect mesh coordinates.")

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_2x2_trench_y


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine  test_2x3_trench_y( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .false.
    logical(l_def) :: periodic_y = .true.

    integer(i_def) :: edge_cells_x = 2
    integer(i_def) :: edge_cells_y = 3

    integer(i_def)           :: row,i
    integer(i_def), pointer  :: edge_cell_ids(:) => null()
    integer(i_def)           :: icell

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    real(r_def), parameter :: domain_x = 2.0
    real(r_def), parameter :: domain_y = 3.0

    real(r_def) :: dy

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element, &
                                mesh_name=mesh_name,            &
                                geometry=geometry_planar,       &
                                topology=topology_channel,      &
                                edge_cells_x=edge_cells_x,      &
                                edge_cells_y=edge_cells_y,      &
                                periodic_x=periodic_x,          &
                                periodic_y=periodic_y,          &
                                domain_x=domain_x,              &
                                domain_y=domain_y,              &
                                coord_sys=coord_sys_xyz )

    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name, trim(test_str(1)) )
    @assertEqual( 'planar',  trim(test_str(2)) )
    @assertEqual( 'channel', trim(test_str(3)) )
    @assertEqual( 'xyz',     trim(test_str(4)) )
    @assertEqual( 'geometry=planar;topology=channel;coord_sys=xyz;edge_cells_x=2;edge_cells_y=3;periodic_x=F;periodic_y=T;domain_x=2.00;domain_y=3.00', trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes,  9, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 15, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces,  6, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual( (/ 1, 2, 3, 4 /), this%nodes_on_face(:,1), "Incorrect vertex sequence on faces.")
    @assertEqual( (/ 2, 5, 6, 3 /), this%nodes_on_face(:,2), "Incorrect vertex sequence on faces.")
    @assertEqual( (/ 7, 8, 2, 1 /), this%nodes_on_face(:,3), "Incorrect vertex sequence on faces.")
    @assertEqual( (/ 8, 9, 5, 2 /), this%nodes_on_face(:,4), "Incorrect vertex sequence on faces.")
    @assertEqual( (/ 4, 3, 8, 7 /), this%nodes_on_face(:,5), "Incorrect vertex sequence on faces.")
    @assertEqual( (/ 3, 6, 9, 8 /), this%nodes_on_face(:,6), "Incorrect vertex sequence on faces.")

    ! Test northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) /= NON_PERIODIC_ID )
    end do

    ! Test Eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) == NON_PERIODIC_ID )
    end do

    ! Test Southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) /= NON_PERIODIC_ID )
    end do

    ! Test Western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) == NON_PERIODIC_ID )
    end do

    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1), (/  NON_PERIODIC_ID, 3, 2, 5 /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,2), (/  1, 4, NON_PERIODIC_ID, 6 /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,3), (/  NON_PERIODIC_ID, 5, 4, 1 /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,4), (/  3, 6, NON_PERIODIC_ID, 2 /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,5), (/  NON_PERIODIC_ID, 1, 6, 3 /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,6), (/  5, 2, NON_PERIODIC_ID, 4 /), "Incorrect faces_on_face connectivity.")


    @assertEqual((/  1,  2,  3,  4 /), this%edges_on_face(:,1), "Incorrect edges_on_face connectivity.")
    @assertEqual((/  3,  5,  6,  7 /), this%edges_on_face(:,2), "Incorrect edges_on_face connectivity.")
    @assertEqual((/  8,  9, 10,  2 /), this%edges_on_face(:,3), "Incorrect edges_on_face connectivity.")
    @assertEqual((/ 10, 11, 12,  5 /), this%edges_on_face(:,4), "Incorrect edges_on_face connectivity.")
    @assertEqual((/ 13,  4, 14,  9 /), this%edges_on_face(:,5), "Incorrect edges_on_face connectivity.")
    @assertEqual((/ 14,  7, 15, 11 /), this%edges_on_face(:,6), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1), (/ 4, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,2), (/ 1, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,3), (/ 3, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,4), (/ 4, 3 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,5), (/ 2, 5 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,6), (/ 6, 5 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,7), (/ 3, 6 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,8), (/ 1, 7 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,9), (/ 7, 8 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,10), (/ 2, 8 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,11), (/ 8, 9 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,12), (/ 5, 9 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,13), (/ 7, 4 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,14), (/ 8, 3 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,15), (/ 9, 6 /), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )

    dy = domain_y/3

    ! Mesh coordinates have expected values at certain points
    @assertTrue(this%coords(:,1) == (/ -1.0_r_def, 1.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,2) == (/  0.0_r_def, 1.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,3) == (/  0.0_r_def, 2.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,4) == (/ -1.0_r_def, 2.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,5) == (/  1.0_r_def, 1.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,6) == (/  1.0_r_def, 2.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,7) == (/ -1.0_r_def, 0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,8) == (/  0.0_r_def, 0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,9) == (/  1.0_r_def, 0.0_r_def /), "Incorrect mesh coordinates.")

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_2x3_trench_y


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine  test_1x1_non_periodic( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .false.
    logical(l_def) :: periodic_y = .false.

    integer(i_def) :: edge_cells_x = 1
    integer(i_def) :: edge_cells_y = 1

    integer(i_def)           :: row,i
    integer(i_def), pointer  :: edge_cell_ids(:) => null()
    integer(i_def)           :: icell

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element, &
                                mesh_name=mesh_name,            &
                                geometry=geometry_planar,       &
                                topology=topology_non_periodic, &
                                edge_cells_x=edge_cells_x,      &
                                edge_cells_y=edge_cells_y,      &
                                periodic_x=periodic_x,          &
                                periodic_y=periodic_y,          &
                                domain_x=domain_x,              &
                                domain_y=domain_y,              &
                                coord_sys=coord_sys_xyz )

    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name,      trim(test_str(1)) )
    @assertEqual( 'planar',       trim(test_str(2)) )
    @assertEqual( 'non_periodic', trim(test_str(3)) )
    @assertEqual( 'xyz',          trim(test_str(4)) )
    @assertEqual( 'geometry=planar;topology=non_periodic;coord_sys=xyz;edge_cells_x=1;edge_cells_y=1;periodic_x=F;periodic_y=F;domain_x=30000.00;domain_y=8000.00', trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, 4, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 4, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, 1, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual( (/ 1, 2, 3, 4 /), this%nodes_on_face(:,1), "Incorrect vertex sequence on faces.")

    ! Test northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) == NON_PERIODIC_ID )
    end do

    ! Test Eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) == NON_PERIODIC_ID )
    end do

    ! Test Southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) == NON_PERIODIC_ID )
    end do

    ! Test Western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) == NON_PERIODIC_ID )
    end do

    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1), (/  NON_PERIODIC_ID, NON_PERIODIC_ID, NON_PERIODIC_ID, NON_PERIODIC_ID /), "Incorrect faces_on_face connectivity.")


    @assertEqual((/ 1, 2, 3, 4 /), this%edges_on_face(:,1), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1), (/ 4, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,2), (/ 1, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,3), (/ 3, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,4), (/ 4, 3 /), "Incorrect nodes_on_edge connectivity.")


    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )



    ! Mesh coordinates have expected values at certain points
    @assertTrue(this%coords(:,1) == (/ 0.0_r_def    ,  0.0_r_def    /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,2) == (/ 30000.0_r_def,  0.0_r_def    /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,3) == (/ 30000.0_r_def,  8000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,4) == (/ 0.0_r_def,      8000.0_r_def /), "Incorrect mesh coordinates.")

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_1x1_non_periodic


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine  test_1x2_non_periodic( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .false.
    logical(l_def) :: periodic_y = .false.

    integer(i_def) :: edge_cells_x = 1
    integer(i_def) :: edge_cells_y = 2

    integer(i_def)           :: row,i
    integer(i_def), pointer  :: edge_cell_ids(:) => null()
    integer(i_def)           :: icell

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element, &
                                mesh_name=mesh_name,            &
                                geometry=geometry_planar,       &
                                topology=topology_non_periodic, &
                                edge_cells_x=edge_cells_x,      &
                                edge_cells_y=edge_cells_y,      &
                                periodic_x=periodic_x,          &
                                periodic_y=periodic_y,          &
                                domain_x=domain_x,              &
                                domain_y=domain_y,              &
                                coord_sys=coord_sys_xyz )

    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name, trim(test_str(1)) )
    @assertEqual( 'planar',  trim(test_str(2)) )
    @assertEqual( 'non_periodic', trim(test_str(3)) )
    @assertEqual( 'xyz',     trim(test_str(4)) )
    @assertEqual( 'geometry=planar;topology=non_periodic;coord_sys=xyz;edge_cells_x=1;edge_cells_y=2;periodic_x=F;periodic_y=F;domain_x=30000.00;domain_y=8000.00', trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, 6, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 7, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, 2, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual( (/ 1, 2, 3, 4 /), this%nodes_on_face(:,1), "Incorrect vertex sequence on faces.")
    @assertEqual( (/ 5, 6, 2, 1 /), this%nodes_on_face(:,2), "Incorrect vertex sequence on faces.")

    ! Test northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) == NON_PERIODIC_ID )
    end do

    ! Test Eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) == NON_PERIODIC_ID )
    end do

    ! Test Southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) == NON_PERIODIC_ID )
    end do

    ! Test Western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) == NON_PERIODIC_ID )
    end do

    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1), (/  NON_PERIODIC_ID, 2, NON_PERIODIC_ID, NON_PERIODIC_ID /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,2), (/  NON_PERIODIC_ID, NON_PERIODIC_ID, NON_PERIODIC_ID, 1 /), "Incorrect faces_on_face connectivity.")


    @assertEqual((/ 1, 2, 3, 4 /), this%edges_on_face(:,1), "Incorrect edges_on_face connectivity.")
    @assertEqual((/ 5, 6, 7, 2 /), this%edges_on_face(:,2), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1), (/ 4, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,2), (/ 1, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,3), (/ 3, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,4), (/ 4, 3 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,5), (/ 1, 5 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,6), (/ 5, 6 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,7), (/ 2, 6 /), "Incorrect nodes_on_edge connectivity.")


    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )



    ! Mesh coordinates have expected values at certain points
    @assertTrue(this%coords(:,1) == (/ 0.0_r_def    ,  0.0_r_def    /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,2) == (/ 30000.0_r_def,  0.0_r_def    /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,3) == (/ 30000.0_r_def,  4000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,4) == (/ 0.0_r_def,      4000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,5) == (/ 0.0_r_def,     -4000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,6) == (/ 30000.0_r_def, -4000.0_r_def /), "Incorrect mesh coordinates.")

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_1x2_non_periodic


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine  test_1x3_non_periodic( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .false.
    logical(l_def) :: periodic_y = .false.

    integer(i_def) :: edge_cells_x = 1
    integer(i_def) :: edge_cells_y = 3

    integer(i_def)           :: row,i
    integer(i_def), pointer  :: edge_cell_ids(:) => null()
    integer(i_def)           :: icell

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    real(r_def), parameter :: domain_x = 1.0
    real(r_def), parameter :: domain_y = 3.0

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element, &
                                mesh_name=mesh_name,            &
                                geometry=geometry_planar,       &
                                topology=topology_non_periodic, &
                                edge_cells_x=edge_cells_x,      &
                                edge_cells_y=edge_cells_y,      &
                                periodic_x=periodic_x,          &
                                periodic_y=periodic_y,          &
                                domain_x=domain_x,              &
                                domain_y=domain_y,              &
                                coord_sys=coord_sys_xyz )

    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name, trim(test_str(1)) )
    @assertEqual( 'planar',  trim(test_str(2)) )
    @assertEqual( 'non_periodic', trim(test_str(3)) )
    @assertEqual( 'xyz',     trim(test_str(4)) )
    @assertEqual( 'geometry=planar;topology=non_periodic;coord_sys=xyz;edge_cells_x=1;edge_cells_y=3;periodic_x=F;periodic_y=F;domain_x=1.00;domain_y=3.00', trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes,  8, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 10, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces,  3, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual( (/ 1, 2, 3, 4 /), this%nodes_on_face(:,1), "Incorrect vertex sequence on faces.")
    @assertEqual( (/ 5, 6, 2, 1 /), this%nodes_on_face(:,2), "Incorrect vertex sequence on faces.")
    @assertEqual( (/ 7, 8, 6, 5 /), this%nodes_on_face(:,3), "Incorrect vertex sequence on faces.")

    ! Test northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) == NON_PERIODIC_ID )
    end do

    ! Test Eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) == NON_PERIODIC_ID )
    end do

    ! Test Southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) == NON_PERIODIC_ID )
    end do

    ! Test Western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) == NON_PERIODIC_ID )
    end do

    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1), (/  NON_PERIODIC_ID, 2, NON_PERIODIC_ID, NON_PERIODIC_ID /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,2), (/  NON_PERIODIC_ID, 3, NON_PERIODIC_ID, 1 /),               "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,3), (/  NON_PERIODIC_ID, NON_PERIODIC_ID, NON_PERIODIC_ID, 2 /), "Incorrect faces_on_face connectivity.")


    @assertEqual((/ 1, 2,  3, 4 /),  this%edges_on_face(:,1), "Incorrect edges_on_face connectivity.")
    @assertEqual((/ 5, 6,  7, 2 /),  this%edges_on_face(:,2), "Incorrect edges_on_face connectivity.")
    @assertEqual((/ 8, 9, 10, 6 /), this%edges_on_face(:,3), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1),  (/ 4, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,2),  (/ 1, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,3),  (/ 3, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,4),  (/ 4, 3 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,5),  (/ 1, 5 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,6),  (/ 5, 6 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,7),  (/ 2, 6 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,8),  (/ 5, 7 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,9),  (/ 7, 8 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,10), (/ 6, 8 /), "Incorrect nodes_on_edge connectivity.")


    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )

    ! Mesh coordinates have expected values at certain points
    @assertTrue( this%coords(:,1) == (/ 0.0_r_def,  1.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue( this%coords(:,2) == (/ 1.0_r_def,  1.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue( this%coords(:,3) == (/ 1.0_r_def,  2.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue( this%coords(:,4) == (/ 0.0_r_def,  2.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue( this%coords(:,5) == (/ 0.0_r_def,  0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue( this%coords(:,6) == (/ 1.0_r_def,  0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue( this%coords(:,7) == (/ 0.0_r_def, -1.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue( this%coords(:,8) == (/ 1.0_r_def, -1.0_r_def /), "Incorrect mesh coordinates.")

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_1x3_non_periodic


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine  test_2x1_non_periodic( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .false.
    logical(l_def) :: periodic_y = .false.

    integer(i_def) :: edge_cells_x = 2
    integer(i_def) :: edge_cells_y = 1

    integer(i_def)           :: row,i
    integer(i_def), pointer  :: edge_cell_ids(:) => null()
    integer(i_def)           :: icell

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element, &
                                mesh_name=mesh_name,            &
                                geometry=geometry_planar,       &
                                topology=topology_non_periodic, &
                                edge_cells_x=edge_cells_x,      &
                                edge_cells_y=edge_cells_y,      &
                                periodic_x=periodic_x,          &
                                periodic_y=periodic_y,          &
                                domain_x=domain_x,              &
                                domain_y=domain_y,              &
                                coord_sys=coord_sys_xyz )

    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name, trim(test_str(1)) )
    @assertEqual( 'planar',  trim(test_str(2)) )
    @assertEqual( 'non_periodic', trim(test_str(3)) )
    @assertEqual( 'xyz',     trim(test_str(4)) )
    @assertEqual( 'geometry=planar;topology=non_periodic;coord_sys=xyz;edge_cells_x=2;edge_cells_y=1;periodic_x=F;periodic_y=F;domain_x=30000.00;domain_y=8000.00', trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, 6, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 7, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, 2, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual( (/ 1, 2, 3, 4 /), this%nodes_on_face(:,1), "Incorrect vertex sequence on faces.")
    @assertEqual( (/ 2, 5, 6, 3 /), this%nodes_on_face(:,2), "Incorrect vertex sequence on faces.")

    ! Test northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) == NON_PERIODIC_ID )
    end do

    ! Test Eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) == NON_PERIODIC_ID )
    end do

    ! Test Southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) == NON_PERIODIC_ID )
    end do

    ! Test Western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) == NON_PERIODIC_ID )
    end do

    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1), (/ NON_PERIODIC_ID, NON_PERIODIC_ID, 2, NON_PERIODIC_ID /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,2), (/ 1, NON_PERIODIC_ID, NON_PERIODIC_ID, NON_PERIODIC_ID /), "Incorrect faces_on_face connectivity.")


    @assertEqual((/ 1, 2, 3, 4 /), this%edges_on_face(:,1), "Incorrect edges_on_face connectivity.")
    @assertEqual((/ 3, 5, 6, 7 /), this%edges_on_face(:,2), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1), (/ 4, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,2), (/ 1, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,3), (/ 3, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,4), (/ 4, 3 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,5), (/ 2, 5 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,6), (/ 6, 5 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,7), (/ 3, 6 /), "Incorrect nodes_on_edge connectivity.")


    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )



    ! Mesh coordinates have expected values at certain points
    @assertTrue(this%coords(:,1) == (/ -15000.0_r_def,     0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,2) == (/      0.0_r_def,     0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,3) == (/      0.0_r_def,  8000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,4) == (/ -15000.0_r_def,  8000.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,5) == (/  15000.0_r_def,     0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,6) == (/  15000.0_r_def,  8000.0_r_def /), "Incorrect mesh coordinates.")

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_2x1_non_periodic


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine  test_3x1_non_periodic( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .false.
    logical(l_def) :: periodic_y = .false.

    integer(i_def) :: edge_cells_x = 3
    integer(i_def) :: edge_cells_y = 1

    integer(i_def)           :: row,i
    integer(i_def), pointer  :: edge_cell_ids(:) => null()
    integer(i_def)           :: icell

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    real(r_def), parameter :: domain_x = 3.0
    real(r_def), parameter :: domain_y = 1.0

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element, &
                                mesh_name=mesh_name,            &
                                geometry=geometry_planar,       &
                                topology=topology_non_periodic, &
                                edge_cells_x=edge_cells_x,      &
                                edge_cells_y=edge_cells_y,      &
                                periodic_x=periodic_x,          &
                                periodic_y=periodic_y,          &
                                domain_x=domain_x,              &
                                domain_y=domain_y,              &
                                coord_sys=coord_sys_xyz )

    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name, trim(test_str(1)) )
    @assertEqual( 'planar',  trim(test_str(2)) )
    @assertEqual( 'non_periodic', trim(test_str(3)) )
    @assertEqual( 'xyz',     trim(test_str(4)) )
    @assertEqual( 'geometry=planar;topology=non_periodic;coord_sys=xyz;edge_cells_x=3;edge_cells_y=1;periodic_x=F;periodic_y=F;domain_x=3.00;domain_y=1.00', trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes,  8, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 10, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces,  3, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual( (/ 1, 2, 3, 4 /), this%nodes_on_face(:,1), "Incorrect vertex sequence on faces.")
    @assertEqual( (/ 2, 5, 6, 3 /), this%nodes_on_face(:,2), "Incorrect vertex sequence on faces.")
    @assertEqual( (/ 5, 7, 8, 6 /), this%nodes_on_face(:,3), "Incorrect vertex sequence on faces.")

    ! Test northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) == NON_PERIODIC_ID )
    end do

    ! Test Eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) == NON_PERIODIC_ID )
    end do

    ! Test Southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) == NON_PERIODIC_ID )
    end do

    ! Test Western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) == NON_PERIODIC_ID )
    end do

    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1), (/  NON_PERIODIC_ID, NON_PERIODIC_ID, 2, NON_PERIODIC_ID /), "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,2), (/  1, NON_PERIODIC_ID, 3, NON_PERIODIC_ID /),               "Incorrect faces_on_face connectivity.")
    @assertEqual(this%faces_on_face(:,3), (/  2, NON_PERIODIC_ID, NON_PERIODIC_ID, NON_PERIODIC_ID /), "Incorrect faces_on_face connectivity.")


    @assertEqual((/ 1, 2, 3,  4 /),  this%edges_on_face(:,1), "Incorrect edges_on_face connectivity.")
    @assertEqual((/ 3, 5, 6,  7 /),  this%edges_on_face(:,2), "Incorrect edges_on_face connectivity.")
    @assertEqual((/ 6, 8, 9, 10 /), this%edges_on_face(:,3), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1),  (/ 4, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,2),  (/ 1, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,3),  (/ 3, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,4),  (/ 4, 3 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,5),  (/ 2, 5 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,6),  (/ 6, 5 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,7),  (/ 3, 6 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,8),  (/ 5, 7 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,9),  (/ 8, 7 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,10), (/ 6, 8 /), "Incorrect nodes_on_edge connectivity.")


    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )

    ! Mesh coordinates have expected values at certain points
    @assertTrue( this%coords(:,1) == (/ -1.0_r_def,  0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue( this%coords(:,2) == (/  0.0_r_def,  0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue( this%coords(:,3) == (/  0.0_r_def,  1.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue( this%coords(:,4) == (/ -1.0_r_def,  1.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue( this%coords(:,5) == (/  1.0_r_def,  0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue( this%coords(:,6) == (/  1.0_r_def,  1.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue( this%coords(:,7) == (/  2.0_r_def,  0.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue( this%coords(:,8) == (/  2.0_r_def,  1.0_r_def /), "Incorrect mesh coordinates.")

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_3x1_non_periodic

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine  test_1x1_noncartesian( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .false.
    logical(l_def) :: periodic_y = .false.

    real(r_def), parameter :: domain_x_degrees = 50.0_r_def
    real(r_def), parameter :: domain_y_degrees = 10.0_r_def
    real(r_def), parameter :: first_lon = -25.0_r_def
    real(r_def), parameter :: first_lat = -5.0_r_def

    integer(i_def) :: edge_cells_x = 1
    integer(i_def) :: edge_cells_y = 1

    integer(i_def)           :: row,i
    integer(i_def), pointer  :: edge_cell_ids(:) => null()
    integer(i_def)           :: icell

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element,   &
                                mesh_name=mesh_name,              &
                                geometry=geometry_spherical,      &
                                topology=topology_non_periodic,   &
                                edge_cells_x=edge_cells_x,        &
                                edge_cells_y=edge_cells_y,        &
                                periodic_x=periodic_x,            &
                                periodic_y=periodic_y,            &
                                domain_x=domain_x_degrees,        &
                                domain_y=domain_y_degrees,        &
                                coord_sys=coord_sys_ll,           &
                                first_node=[first_lon,first_lat], &
                                rotate_mesh=.false. )

    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name,   trim(test_str(1)) )
    @assertEqual( 'spherical', trim(test_str(2)) )
    @assertEqual( 'non_periodic',   trim(test_str(3)) )
    @assertEqual( 'll',        trim(test_str(4)) )
    @assertEqual( "geometry=spherical;topology=non_periodic;coord_sys=ll;edge_cells_x=1;edge_cells_y=1;periodic_x=F;periodic_y=F;domain_x=50.00;domain_y=10.00;rotate_mesh=F", trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, 4, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 4, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, 1, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual( (/ 1, 2, 3, 4 /), this%nodes_on_face(:,1), "Incorrect vertex sequence on faces.")

    ! Test northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) == NON_PERIODIC_ID )
    end do

    ! Test Eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) == NON_PERIODIC_ID )
    end do

    ! Test Southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) == NON_PERIODIC_ID )
    end do

    ! Test Western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) == NON_PERIODIC_ID )
    end do

    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1), (/  NON_PERIODIC_ID, NON_PERIODIC_ID, NON_PERIODIC_ID, NON_PERIODIC_ID /), "Incorrect faces_on_face connectivity.")

    @assertEqual((/ 1, 2, 3, 4 /), this%edges_on_face(:,1), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1), (/ 4, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,2), (/ 1, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,3), (/ 3, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,4), (/ 4, 3 /), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )

    ! Mesh coordinates have expected values at certain points
    @assertTrue(this%coords(:,1) == (/ -25.0_r_def, -5.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,2) == (/  25.0_r_def, -5.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,3) == (/  25.0_r_def,  5.0_r_def /), "Incorrect mesh coordinates.")
    @assertTrue(this%coords(:,4) == (/ -25.0_r_def,  5.0_r_def /), "Incorrect mesh coordinates.")

    @assertTrue( trim(test_coord_units_x) == 'degrees_east')
    @assertTrue( trim(test_coord_units_y) == 'degrees_north')

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_1x1_noncartesian

 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  @test
  subroutine  test_1x1_rotate_south( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .false.
    logical(l_def) :: periodic_y = .false.

    ! Rotate target null island southward
    real(r_def), parameter :: domain_x_degrees = 180.0_r_def
    real(r_def), parameter :: domain_y_degrees = 10.0_r_def
    real(r_def), parameter :: pole_lon = 0.0_r_def
    real(r_def), parameter :: pole_lat = 85.0_r_def
    real(r_def), parameter :: ni_lon = 180.0_r_def
    real(r_def), parameter :: ni_lat = 5.0_r_def
    real(r_def), parameter :: first_lon = 0.0
    real(r_def), parameter :: first_lat = -5.0

    integer(i_def) :: edge_cells_x = 1
    integer(i_def) :: edge_cells_y = 1

    integer(i_def)           :: row,i
    integer(i_def), pointer  :: edge_cell_ids(:) => null()
    integer(i_def)           :: icell

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element,        &
                                mesh_name=mesh_name,                   &
                                geometry=geometry_spherical,           &
                                topology=topology_non_periodic,        &
                                edge_cells_x=edge_cells_x,             &
                                edge_cells_y=edge_cells_y,             &
                                periodic_x=periodic_x,                 &
                                periodic_y=periodic_y,                 &
                                domain_x=domain_x_degrees,             &
                                domain_y=domain_y_degrees,             &
                                coord_sys=coord_sys_ll,                &
                                rotate_mesh=.true.,                    &
                                target_north_pole=[pole_lon,pole_lat], &
                                target_null_island=[ni_lon,ni_lat],    &
                                first_node=[first_lon,first_lat] )

    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name,      trim(test_str(1)) )
    @assertEqual( 'spherical',    trim(test_str(2)) )
    @assertEqual( 'non_periodic', trim(test_str(3)) )
    @assertEqual( 'll',           trim(test_str(4)) )
    @assertEqual( 'geometry=spherical;topology=non_periodic;coord_sys=ll;edge_cells_x=1;edge_cells_y=1;periodic_x=F;periodic_y=F;domain_x=180.00;domain_y=10.00;rotate_mesh=T;north_pole=[0.00,85.00];null_island=[180.00,5.00];first_node=[0.00,-5.00]', trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, 4, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 4, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, 1, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual( (/ 1, 2, 3, 4 /), this%nodes_on_face(:,1), "Incorrect vertex sequence on faces.")

    ! Test northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) == NON_PERIODIC_ID )
    end do

    ! Test Eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) == NON_PERIODIC_ID )
    end do

    ! Test Southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) == NON_PERIODIC_ID )
    end do

    ! Test Western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) == NON_PERIODIC_ID )
    end do

    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1), (/  NON_PERIODIC_ID, NON_PERIODIC_ID, NON_PERIODIC_ID, NON_PERIODIC_ID /), "Incorrect faces_on_face connectivity.")

    @assertEqual((/ 1, 2, 3, 4 /), this%edges_on_face(:,1), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1), (/ 4, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,2), (/ 1, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,3), (/ 3, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,4), (/ 4, 3 /), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )

    ! The new pole is at lon = 0, lat = 85
    ! Original and rotated coordinates (long,lat) are:
    ! Node 1  0,   -5  ->  0,  -10
    ! Node 2  180, -5  ->  180,  0
    ! Node 3  180,  5  ->  180, 10
    ! Node 4    0,  5  ->    0,  0

    ! Mesh coordinates have expected values at certain points
    @assertTrue(abs(  0.0_r_def - this%coords(1,1) ) < eps, "Incorrect longitude, node 1")
    @assertTrue(abs(-10.0_r_def - this%coords(2,1) ) < eps, "Incorrect latitude, node 1")
    @assertTrue(abs(180.0_r_def - this%coords(1,2) ) < eps, "Incorrect longitude, node 2")
    @assertTrue(abs(  0.0_r_def - this%coords(2,2) ) < eps, "Incorrect latitude, node 2")
    @assertTrue(abs(180.0_r_def - this%coords(1,3) ) < eps, "Incorrect longitude, node 3")
    @assertTrue(abs( 10.0_r_def - this%coords(2,3) ) < eps, "Incorrect latitude, node 3")
    @assertTrue(abs(  0.0_r_def - this%coords(1,4) ) < eps, "Incorrect longitude, node 4")
    @assertTrue(abs(  0.0_r_def - this%coords(2,4) ) < eps, "Incorrect latitude, node 4")

    @assertTrue( trim(test_coord_units_x) == 'degrees_east')
    @assertTrue( trim(test_coord_units_y) == 'degrees_north')

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_1x1_rotate_south

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine  test_1x1_rotate_north( this )

    implicit none

    class(gen_planar_test_type), intent(inout) :: this

    type(gen_planar_type) :: mesh_gen
    integer(i_def) :: nodes, edges, faces
    integer(i_def) :: nodes_per_face, edges_per_face
    integer(i_def) :: nodes_per_edge
    integer(i_def) :: max_faces_per_node

    logical(l_def) :: periodic_x = .false.
    logical(l_def) :: periodic_y = .false.

    ! Rotate target null island northward
    real(r_def), parameter :: domain_x_degrees = 180.0_r_def
    real(r_def), parameter :: domain_y_degrees = 10.0_r_def
    real(r_def), parameter :: pole_lon = 180.0_r_def
    real(r_def), parameter :: pole_lat = 85.0_r_def
    real(r_def), parameter :: ni_lon = 0.0_r_def
    real(r_def), parameter :: ni_lat = 5.0_r_def
    real(r_def), parameter :: first_lon = 0.0
    real(r_def), parameter :: first_lat = -5.0

    integer(i_def) :: edge_cells_x = 1
    integer(i_def) :: edge_cells_y = 1

    integer(i_def)           :: row,i
    integer(i_def), pointer  :: edge_cell_ids(:) => null()
    integer(i_def)           :: icell

    character(str_def)      :: test_str(5)
    character(str_longlong) :: big_test_str

    character(str_def)  :: test_coord_units_x
    character(str_def)  :: test_coord_units_y

    type(reference_cube_type) :: cube_element
    cube_element = reference_cube_type()

    mesh_gen = gen_planar_type( reference_element=cube_element,        &
                                mesh_name=mesh_name,                   &
                                geometry=geometry_spherical,           &
                                topology=topology_non_periodic,        &
                                coord_sys=coord_sys_ll,                &
                                edge_cells_x=edge_cells_x,             &
                                edge_cells_y=edge_cells_y,             &
                                periodic_x=periodic_x,                 &
                                periodic_y=periodic_y,                 &
                                domain_x=domain_x_degrees,             &
                                domain_y=domain_y_degrees,             &
                                rotate_mesh=.true.,                    &
                                target_north_pole=[pole_lon,pole_lat], &
                                target_null_island=[ni_lon,ni_lat],    &
                                first_node=[first_lon,first_lat] )

    ! Test metadata retrieval
    call mesh_gen%get_metadata( mesh_name          = test_str(1), &
                                geometry           = test_str(2), &
                                topology           = test_str(3), &
                                coord_sys          = test_str(4), &
                                constructor_inputs = big_test_str )

    @assertEqual( mesh_name,      trim(test_str(1)) )
    @assertEqual( 'spherical',    trim(test_str(2)) )
    @assertEqual( 'non_periodic', trim(test_str(3)) )
    @assertEqual( 'll',           trim(test_str(4)) )
    @assertEqual( "geometry=spherical;topology=non_periodic;coord_sys=ll;edge_cells_x=1;edge_cells_y=1;periodic_x=F;periodic_y=F;domain_x=180.00;domain_y=10.00;rotate_mesh=T;north_pole=[180.00,85.00];null_island=[0.00,5.00];first_node=[0.00,-5.00]", trim(big_test_str) )

    ! Generate the mesh and connectivity
    call mesh_gen%generate()

    ! Retrieve calculated dimensions
    call mesh_gen%get_dimensions( nodes, edges, faces, nodes_per_face, &
                                  edges_per_face, nodes_per_edge,      &
                                  max_faces_per_node )

    ! Mesh has correct dimensions for arguments
    @assertEqual(nodes, 4, "Incorrect number of vertices for mesh dimensions")
    @assertEqual(edges, 4, "Incorrect number of edges for mesh dimensions")
    @assertEqual(faces, 1, "Incorrect number of faces for mesh dimensions")

    ! Mesh has correct element dimensions
    @assertEqual(edges_per_face, 4, "Number of edges per face does not correspond to quad mesh")
    @assertEqual(nodes_per_edge, 2, "Number of vertices per edge does not correspond to quad mesh")
    @assertEqual(max_faces_per_node, 4, "Max number of faces around a node does not correspond to quad mesh")

    allocate( this%nodes_on_face(4, faces) )
    allocate( this%edges_on_face(4, faces) )
    allocate( this%nodes_on_edge(2, edges) )
    allocate( this%coords(2, nodes) )

    ! Retrieve mesh connectivity
    call mesh_gen%get_connectivity( this%nodes_on_face, this%nodes_on_edge, &
                                    this%edges_on_face, this%faces_on_face )

    ! Mesh has expected vertex values on certain faces
    @assertEqual( (/ 1, 2, 3, 4 /), this%nodes_on_face(:,1), "Incorrect vertex sequence on faces.")

    ! Test northern border
    do icell=1, edge_cells_x
      @assertTrue( this%faces_on_face(N, icell) == NON_PERIODIC_ID )
    end do

    ! Test Eastern border
    do row=1, edge_cells_y
      icell = row*edge_cells_x
      @assertTrue( this%faces_on_face(E, icell) == NON_PERIODIC_ID )
    end do

    ! Test Southern border
    do i=1, edge_cells_x
      icell = (edge_cells_y-1)*edge_cells_x +i
      @assertTrue( this%faces_on_face(S, icell) == NON_PERIODIC_ID )
    end do

    ! Test Western border
    do row=1, edge_cells_y
      icell = (row-1)*edge_cells_x + 1
      @assertTrue( this%faces_on_face(W, icell) == NON_PERIODIC_ID )
    end do

    @assertTrue(minval(this%nodes_on_face, 2) /= 0, "Incomplete nodes_on_face connectivity.")
    @assertTrue(minval(this%edges_on_face, 2) /= 0, "Incomplete edges_on_face connectivity.")
    @assertTrue(minval(this%nodes_on_edge, 2) /= 0, "Incomplete nodes_on_edge connectivity.")

    ! Mesh connectivity has expected values at certain points
    @assertEqual(this%faces_on_face(:,1), (/  NON_PERIODIC_ID, NON_PERIODIC_ID, NON_PERIODIC_ID, NON_PERIODIC_ID /), "Incorrect faces_on_face connectivity.")

    @assertEqual((/ 1, 2, 3, 4 /), this%edges_on_face(:,1), "Incorrect edges_on_face connectivity.")

    @assertEqual(this%nodes_on_edge(:,1), (/ 4, 1 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,2), (/ 1, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,3), (/ 3, 2 /), "Incorrect nodes_on_edge connectivity.")
    @assertEqual(this%nodes_on_edge(:,4), (/ 4, 3 /), "Incorrect nodes_on_edge connectivity.")

    ! Retrieve mesh coordinates
    call mesh_gen%get_coordinates( this%coords,        &
                                   this%face_coords,   &
                                   test_coord_units_x, &
                                   test_coord_units_y )

    ! The new pole is at lon = 180, lat = 85
    ! Original and rotated coordinates (long,lat) are:
    ! Node 1    0, -5  ->    0,  0
    ! Node 2  180, -5  ->  180,-10
    ! Node 3  180,  5  ->  180,  0
    ! Node 4    0,  5  ->    0, 10

    ! Mesh coordinates have expected values at certain points
    @assertTrue(abs(  0.0_r_def - this%coords(1,1) ) < eps, "Incorrect longitude, node 1")
    @assertTrue(abs(  0.0_r_def - this%coords(2,1) ) < eps, "Incorrect latitude, node 1")
    @assertTrue(abs(180.0_r_def - this%coords(1,2) ) < eps, "Incorrect longitude, node 2")
    @assertTrue(abs(-10.0_r_def - this%coords(2,2) ) < eps, "Incorrect latitude, node 2")
    @assertTrue(abs(180.0_r_def - this%coords(1,3) ) < eps, "Incorrect longitude, node 3")
    @assertTrue(abs(  0.0_r_def - this%coords(2,3) ) < eps, "Incorrect latitude, node 3")
    @assertTrue(abs(  0.0_r_def - this%coords(1,4) ) < eps, "Incorrect longitude, node 4")
    @assertTrue(abs( 10.0_r_def - this%coords(2,4) ) < eps, "Incorrect latitude, node 4")

    @assertTrue( trim(test_coord_units_x) == 'degrees_east')
    @assertTrue( trim(test_coord_units_y) == 'degrees_north')

    call mesh_gen%clear()
    nullify(edge_cell_ids)

  end subroutine test_1x1_rotate_north

end module gen_planar_mod_test
