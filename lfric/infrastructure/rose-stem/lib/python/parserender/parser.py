#!/usr/bin/env python
# -*- coding: utf-8 -*-
##############################################################################
# Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
# For further details please refer to the file LICENCE.original which you
# should have received as part of this distribution.
##############################################################################
'''
Parse the log files generated by Cylc of various stages in the test suite.
'''
from __future__ import print_function

from __future__ import absolute_import
from abc import ABCMeta, abstractmethod
import copy
import hashlib
import re


##############################################################################
class Event(object):
    '''
    An "event" gleened from parsing the output of various processes.
    '''
    # pylint: disable=too-many-instance-attributes

    def __init__(self):
        self.occurrences = 1
        self.filename = None
        self.line_number = None
        self.level = None
        self.event_code = None
        self.message = None
        self.source = None
        self.highlight_start = None
        self.highlight_end = None
        self.highlight_range = ':'

    def set_filename(self, filename):
        '''
        The file in which the event occurred.
        '''
        self.filename = filename

    def set_line_number(self, line_number):
        '''
        The line of the file in which the event occurred.
        '''
        self.line_number = line_number

    def set_level(self, level):
        '''
        Severity of the event.
        '''
        self.level = level

    def set_event_code(self, code):
        '''
        A code for the event.
        '''
        self.event_code = code

    def set_message(self, message):
        '''
        The description of the event.
        '''
        # Strip sexed single quotes
        message = message.replace(u'\u2018', "'")
        message = message.replace(u'\u2019', "'")
        self.message = message

    def extend_message(self, extension):
        '''
        Append additional text to the message.
        '''
        self.set_message(self.message + ' ' + extension)

    def set_source(self, source):
        '''
        The line of source the event refers to.
        '''
        self.source = source

    def set_highlight(self, start, end):
        '''
        The first and last characters within the source line to highlight.
        '''
        self.highlight_start = start
        self.highlight_end = end
        self.highlight_range = str(start) + ':' + str(end)

    def get_hash(self):
        '''
        Calculates a hash for the event.
        '''
        hasher = hashlib.sha1()
        if self.filename:
            hasher.update(self.filename)
        if self.line_number:
            hasher.update(str(self.line_number))
        if self.highlight_start:
            hasher.update(str(self.highlight_start))
        if self.highlight_end:
            hasher.update(str(self.highlight_end))
        if self.level:
            hasher.update(self.level)
        if self.event_code:
            hasher.update(self.event_code)
        if self.message:
            hasher.update(self.message)
        return hasher.digest()

    def bump(self):
        '''
        Increments the occurence counter for this event.
        '''
        self.occurrences = self.occurrences + 1


##############################################################################
class Parser(object):
    '''
    The root parser class, all parsers inherit from this.
    '''
    __MetaClass__ = ABCMeta

    def __init__(self, errfile):
        '''
        Initialises a Parser object a log file's contents.

        In their initialiser children should set up any state their parser
        needs, the call "super(<ChildClass>, self).__init__(errfile)". They
        will then have their "accept_line" method called for each line in the
        log file.

        errfile (str) Text sent to standard out by the process of interest.
        '''
        self._events = {}

        for line in errfile:
            if not line.strip():  # Ignore blank lines
                continue

            line = line.decode('utf-8')
            while line:
                line, event = self.accept_line(line)
                if event:
                    signature = event.get_hash()
                    if signature in self._events:
                        self._events[signature].bump()
                    else:
                        self._events[signature] = event
        # Force the last line through the parser. I don't like this duplication
        # but people are waiting.
        line = 'EOF'
        while line:
            line, event = self.accept_line(line)
            if event:
                signature = event.get_hash()
                if signature in self._events:
                    self._events[signature].bump()
                else:
                    self._events[signature] = event

    @abstractmethod
    def accept_line(self, line):
        '''
        Examine one line of the input file.

        Called repeatedly by the parsing process, this method is passed the
        new line to examine.

        It should return any of the input line not yet parsed (or None if it
        is all parsed) and any event which may have become available through
        the processing of the line.

        line (str) Next line in the log file.
        '''
        pass

    def process_events(self, processor):
        '''
        Passes each event, in turn, to the processor for potential
        modification.

        processor (function) Accepts an event and returns an event.
        '''
        new_events = {}
        for event in self._events.values():
            new_event = processor(event)
            new_events[new_event.get_hash()] = new_event
        self._events = new_events

    def get_events(self, ignore_codes=None, group_by=None):
        '''
        Gets the events collected by parsing the file.

        ignore_codes (list) Events with codes appearing in this list will be
                            ommitted from the results.
        group_by (str) Name of event property to use when grouping the results.

        Returns a dictionary keyed on the attribute specified in group_by. If
        group_by is not specigied then returns the events as a list.
        '''
        if not ignore_codes:
            ignore_codes = []

        if group_by:
            groups = {}
            for event in self._events.values():
                if event.event_code in ignore_codes:
                    continue

                grouping_value = getattr(event, group_by)

                if grouping_value not in groups:
                    groups[grouping_value] = []

                groups[grouping_value].append(copy.deepcopy(event))

            return groups
        else:
            return [copy.deepcopy(event)
                    for event in self._events.values()
                    if event.event_code not in ignore_codes]


##############################################################################
class CylcParser(Parser):
    '''
    Parse the status file from a Cylc task.

    This picks up the start and completion timestamps.
    '''
    startTimePattern = re.compile(r'CYLC_JOB_INIT_TIME=(\S+)')
    endTimePattern = re.compile(r'CYLC_JOB_EXIT_TIME=(\S+)')

    def __init__(self, statusfile, compiler=None):
        self.started = None
        self.completed = None
        self.compiler = compiler
        super(CylcParser, self).__init__(statusfile)

    def accept_line(self, line):
        match = BuildParser.startTimePattern.match(line)
        if match:
            self.started = match.group(1)
            return None, None

        match = BuildParser.endTimePattern.match(line)
        if match:
            self.completed = match.group(1)
            return None, None

        return None, None


##############################################################################
class BuildParser(CylcParser):
    '''
    Parse the standard output from the Dynamo build system.

    This is done in order to determine which compiler was in use.
    '''
    fortranPattern = re.compile(r'\*\* Chosen (\S+) Fortran compiler')

    def __init__(self, outfile):
        self.compiler = None
        super(BuildParser, self).__init__(outfile)

    def accept_line(self, line):
        super(BuildParser, self).accept_line(line)

        match = BuildParser.fortranPattern.match(line)
        if match:
            self.compiler = match.group(1)

        return None, None


##############################################################################
class DoxygenParser(Parser):
    '''
    Parse the error stream from the Doxygen tasks.
    '''
    eventPattern = re.compile(r'([^:]+):(\d+): ([^:]+): (.+)')
    continuationPattern = re.compile(r'  (.+)')

    def __init__(self, errfile):
        self._state = 'lookingForEvent'
        self._current_event = None
        super(DoxygenParser, self).__init__(errfile)

    def accept_line(self, line):
        if self._state == 'lookingForEvent':
            match = DoxygenParser.eventPattern.match(line)
            if match:
                self._current_event = Event()
                self._current_event.set_filename(match.group(1))
                self._current_event.set_line_number(int(match.group(2)))
                self._current_event.set_level(match.group(3))
                self._current_event.set_message(match.group(4).strip())

                self._state = 'lookingForContinuation'
                return None, None

        if self._state == 'lookingForContinuation':
            match = DoxygenParser.continuationPattern.match(line)
            if match:
                self._current_event.extend_message(match.group(1).strip())
                return None, None
            else:
                self._state = 'lookingForEvent'
                return line, self._current_event

        return None, None


##############################################################################
class CompileParser(Parser):
    '''
    All parsers of compiler output inherit this class.
    '''
    __MetaClass__ = ABCMeta

    def __init__(self, compiler, errfile):
        super(CompileParser, self).__init__(errfile)
        self.compiler = compiler

    @abstractmethod
    def accept_line(self, line):
        pass


##############################################################################
class CrayCompileParser(CompileParser):
    '''
    Parse the error stream from the Cray compiler.
    '''
    pattern_string = r'ftn-(\d+) crayftn: (\S+) (\S+), File = ([^,]+), ' \
                     r'Line = (\d+)(?:, Column = (\d+))?'
    eventPattern = re.compile(pattern_string)
    junkPattern = re.compile(r'Cray Fortran : .+')

    _LEVEL_MAP = {'comment': 'comment',
                  'note': 'comment',
                  'caution': 'beware',
                  'ansi': 'warning',
                  'warning': 'warning',
                  'error':   'error'}

    def __init__(self, errfile):
        self._state = 'lookingForEvent'
        self._current_event = None
        self._backlog = []
        super(CrayCompileParser, self).__init__("Cray Fortran", errfile)

    def accept_line(self, line):
        if self._state == 'lookingForEvent':
            match = CrayCompileParser.junkPattern.match(line)
            if match:
                return None, None

            match = CrayCompileParser.eventPattern.match(line)
            if match:
                self._current_event = Event()
                self._current_event.set_event_code(match.group(1))
                self._current_event.set_level(
                    CrayCompileParser._LEVEL_MAP[match.group(2).lower()])
                self._current_event.set_filename(match.group(4))
                self._current_event.set_line_number(int(match.group(5)))
                if match.group(6) is not None:
                    self._current_event.set_highlight(int(match.group(6)),
                                                      None)
                    if len(self._backlog) > 0 \
                       and self._backlog[-1].strip() == '^':
                        self._backlog.pop()

                if len(self._backlog) > 0:
                    source = self._backlog.pop().rstrip()
                    self._current_event.set_source(source)
                    self._backlog = []

                self._state = 'lookingForMessage'
                return None, None

            self._backlog.append(line)
            return None, None

        if self._state == 'lookingForMessage':
            self._current_event.set_message(line.strip())
            self._state = 'lookingForEvent'
            return None, self._current_event

        raise Exception('Unknown state: {}'.format(self._state))


##############################################################################
class GnuCompileParser(CompileParser):
    '''
    Parse the error stream from the GNU compiler.
    '''
    eventPattern = re.compile(r'([^:]+):(\d+):(\d+):')
    messagePattern = re.compile(r'([^:]+): (.+)\[-W(.+)\]')

    _LEVEL_MAP = {'warning': 'warning',
                  'error':   'error'}

    def __init__(self, errfile):
        self._state = 'lookingForEvent'
        self._current_event = None
        super(GnuCompileParser, self).__init__("GNU Fortran", errfile)

    def accept_line(self, line):
        if self._state == 'lookingForEvent':
            match = GnuCompileParser.eventPattern.match(line)
            if match:
                self._current_event = Event()
                self._current_event.set_filename(match.group(1))
                self._current_event.set_line_number(int(match.group(2)))
                self._current_event.set_highlight(None,
                                                  int(match.group(3)) + 1)

                self._state = 'lookingForSource'

            return None, None

        if self._state == 'lookingForSource':
            self._current_event.set_source(line.rstrip())
            self._state = 'lookingForMessage'
            return None, None

        if self._state == 'lookingForMessage':
            match = GnuCompileParser.messagePattern.match(line.strip())
            if match:
                level = match.group(1).lower()
                message = match.group(2).rstrip()
                category = match.group(3)

                self._current_event.set_level(self._LEVEL_MAP[level])
                self._current_event.set_message(message)
                self._current_event.set_event_code(category.lower())

                self._state = 'lookingForEvent'
                return None, self._current_event

            return None, None

        raise Exception('Unknown state: {}'.format(self._state))


##############################################################################
class IntelCompileParser(CompileParser):
    '''
    Parse the error stream from the Intel compiler.
    '''
    pattern_string = r'([^(]+)\((\d+)\): (\S+) #(\d+): (.+)'
    compileMessagePattern = re.compile(pattern_string)
    pattern_string = r'forrtl: (\S+) \((\d+)\): ([^:]+): \((\d+)\): (.+)'
    runMessagePattern = re.compile(pattern_string)

    _LEVEL_MAP = {'remark':  'comment',
                  'warning': 'warning',
                  'error':   'error'}

    def __init__(self, errfile):
        self._state = 'lookingForEvent'
        self._current_event = None
        super(IntelCompileParser, self).__init__("Intel Fortran", errfile)

    def accept_line(self, line):
        if self._state == 'lookingForEvent':
            match = IntelCompileParser.compileMessagePattern.match(line)
            if match:
                self._current_event = Event()
                self._current_event.set_filename(match.group(1))
                self._current_event.set_line_number(match.group(2))
                self._current_event.set_level(
                    IntelCompileParser._LEVEL_MAP[match.group(3).lower()])
                self._current_event.set_event_code(match.group(4))
                self._current_event.set_message(match.group(5).strip())

                self._state = 'lookingForSource'

            return None, None

        if self._state == 'lookingForSource':
            self._current_event.set_source(line.rstrip())
            self._state = 'lookingForStart'
            return None, None

        if self._state == 'lookingForStart':
            self._current_event.set_highlight(line.count('-'), None)
            self._state = 'lookingForEvent'
            return None, self._current_event

        raise Exception('Unrecognised state: {}'.format(self._state))


##############################################################################
class PortlandCompileParser(CompileParser):
    '''
    Parse the error stream from the Portland compiler.
    '''
    pattern_string = r'PGF90-([^-]+)-(\d+)-([^(]+) \(([^:)]+)(?:: (\d+))?\)'
    compileMessagePattern = re.compile(pattern_string)

    _LEVEL_MAP = {'W': 'warning'}

    def __init__(self, errfile):
        self._state = 'lookingForEvent'
        super(PortlandCompileParser, self).__init__("Portland Fortran",
                                                    errfile)

    def accept_line(self, line):
        if self._state == 'lookingForEvent':
            match = PortlandCompileParser.compileMessagePattern.match(line)
            if match:
                event = Event()
                event.set_level(self._LEVEL_MAP[match.group(1)])
                event.set_event_code(match.group(2))
                event.set_message(match.group(3))
                event.set_filename(match.group(4))
                if match.group(5):
                    event.set_line_number(match.group(5))

                return None, event

            return None, None

        raise Exception('Unrecognised state: {}'.format(self._state))


##############################################################################
class RuntimeParser(Parser):
    '''
    All parsers of run-time library checking output inherit this class.
    '''
    __MetaClass__ = ABCMeta

    def __init__(self, compiler, errfile):
        super(RuntimeParser, self).__init__(errfile)
        self.compiler = compiler

    @abstractmethod
    def accept_line(self, line):
        pass


##############################################################################
class CrayRunParser(RuntimeParser):
    '''
    Parse the error stream from the Cray run-time.
    '''
    _EVENT_PATTERN = re.compile(r'(\w+-\d+)\s*:\s*(\S+)')
    _DESCRIPTION_PATTERN = re.compile(r'\s*(?:(.+)\s+at|(.+))')
    _LOCATION_PATTERN = re.compile(r"\s*at line (\d+) in file '([^']+)'")

    def __init__(self, errfile):
        self._state = 'lookingForEvent'
        self._current_event = None
        super(CrayRunParser, self).__init__('Cray Fortran', errfile)

    def accept_line(self, line):
        if self._state == 'lookingForEvent':
            match = self._EVENT_PATTERN.match(line)
            if match:
                self._current_event = Event()
                self._current_event.set_event_code(match.group(1))
                self._current_event.set_level(match.group(2).lower())
                self._state = 'lookingForMessage'
            return None, None

        if self._state == 'lookingForMessage':
            match = self._DESCRIPTION_PATTERN.match(line)
            if match:
                if match.group(1):
                    self._current_event.set_message(match.group(1))
                else:
                    self._current_event.set_message(match.group(2))
                self._state = 'lookingForSource'
            return None, None

        if self._state == 'lookingForSource':
            match = self._LOCATION_PATTERN.match(line)
            if match:
                self._current_event.set_line_number(match.group(1))
                self._current_event.set_filename(match.group(2))
                self._state = 'lookingForEvent'
                return None, self._current_event
            return None, None
        raise Exception('Unknown state: ' + self._state)


##############################################################################
class GnuRunParser(RuntimeParser):
    '''
    Parse the error stream from the GNU run-time.
    '''
    runContextPattern = re.compile(r'At line (\d+) of file (.+)')
    runMessagePattern = re.compile(r'Fortran runtime ([^:]+): (.+)')

    def __init__(self, errfile):
        self._state = 'lookingForEvent'
        self._current_event = None
        super(GnuRunParser, self).__init__('GNU Fortran', errfile)

    def accept_line(self, line):
        if self._state == 'lookingForEvent':
            match = GnuRunParser.runContextPattern.match(line)
            if match:
                self._current_event = Event()
                self._current_event.set_line_number(match.group(1))
                self._current_event.set_filename(match.group(2))

                self._state = 'lookingForMessage'

            return None, None

        if self._state == 'lookingForMessage':
            match = GnuRunParser.runMessagePattern.match(line)
            if match:
                self._current_event.set_level(match.group(1))
                self._current_event.set_message(match.group(2))

                self._state = 'lookingForEvent'
                return None, self._current_event

            return None, None

        raise Exception('Unknown state: {}'.format(self._state))


##############################################################################
class IntelRunParser(RuntimeParser):
    '''
    Parse the error stream from the Intel run-time.
    '''
    pattern_string = r'forrtl: (\S+) \((\d+)\): ([^:]+): \((\d+)\): (.+)'
    runMessagePattern = re.compile(pattern_string)

    def __init__(self, errfile):
        super(IntelRunParser, self).__init__('Intel Fortran', errfile)

    def accept_line(self, line):
        print(line)
        match = IntelRunParser.runMessagePattern.match(line)
        if match:
            level = match.group(1)
            message = match.group(5)

            event = Event()
            event.set_level(level)
            event.set_event_code(match.group(2))
            event.set_message(message)

            return None, event

        return None, None


##############################################################################
class PortlandRunParser(RuntimeParser):
    '''
    Parse the error stream from the Portland run-time.
    '''
    def __init__(self, errfile):
        super(PortlandRunParser, self).__init__('Portland Fortran', errfile)

    def accept_line(self, line):
        raise NotImplementedError()
