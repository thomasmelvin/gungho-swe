module assign_field_random_kernel_mod_test

  use pFUnit_Mod
  use constants_mod,      only : i_def, r_def

  implicit none

  contains

    @test
    subroutine sample_test()

      use assign_field_random_kernel_mod, only : assign_field_random_code

      implicit none

      integer(kind=i_def), parameter      :: nlayers=100, ndf=100, undf=10000
      integer(kind=i_def), dimension(ndf) :: map
      real(kind=r_def), dimension(undf)   :: x, y
      real(kind=r_def), parameter         :: tol = 0.01_r_def
      integer(kind=i_def)                 :: i, k
      integer, allocatable                :: seed(:)

      ! map has size ndf
      ! x has size ndf * nlayers == undf
      ! map contains values 1, 1 + nlayers, 1 + 2*nlayers, ...
      do i = 1, ndf
        map(i) = 1 + ((i - 1) * nlayers)
      end do

      ! Reset seed for reliable retesting
      call random_seed(size=k)
      allocate(seed(1:k))
      seed = [(i, i=1, k)]
      call random_seed(put=seed)

      call assign_field_random_code(nlayers, x, 1._r_def, ndf, undf, map)

      ! Ensure extreme values present
      ! With 10,000 values these conditions are true with p ~ e^-100 ~ 3.7e-44
      @assertTrue(any(x < 0.01_r_def))
      @assertTrue(any(x > 0.99_r_def))
      ! Ensure all values within range
      @assertTrue(all(x < 1_r_def))
      @assertTrue(all(x > 0_r_def))

      ! reset seed again
      call random_seed(put=seed)
      ! Repeat tests with scale 10
      call assign_field_random_code(nlayers, y, 10._r_def, ndf, undf, map)

      @assertEqual(x * 10._r_def, y, 1.0e-6_r_def)

      ! Continue rng
      call random_seed(put=seed)

    end subroutine sample_test

end module assign_field_random_kernel_mod_test