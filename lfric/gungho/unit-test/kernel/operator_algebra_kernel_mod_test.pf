!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! For further details please refer to the file COPYRIGHT.txt
! which you should have received as part of this distribution.
!-----------------------------------------------------------------------------

!> Test the mixed operator application to the equation of state
!>
module operator_algebra_kernel_mod_test

  use constants_mod, only : i_def, r_def
  use pFUnit_Mod

  implicit none

  private
  public :: test_x_plus_ay
  public :: test_setval_c
  public :: test_setval_x
  public :: test_x_times_y

  @TestCase
  type, extends(TestCase), public :: operator_algebra_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_x_plus_ay
    procedure test_setval_c
    procedure test_setval_x
    procedure test_x_times_y
  end type operator_algebra_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(operator_algebra_test_type), intent(inout) :: this

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(operator_algebra_test_type), intent(inout) :: this

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  @Test( )
  subroutine test_x_plus_ay( this )

    use, intrinsic :: iso_fortran_env, only: real64
    use operator_algebra_kernel_mod, only : operator_x_plus_ay_kernel_code

    implicit none

    class(operator_algebra_test_type), intent(inout) :: this

    real(kind=r_def), parameter :: tol = 1.0e-12_r_def   ! r_def 64bit
    real(kind=r_def)            :: use_tol

    ! Mesh
    integer(kind=i_def), parameter :: nlayers = 1
    integer(kind=i_def), parameter :: cell = 1
    integer(kind=i_def), parameter :: ncell = 1

    ! Spaces
    integer(kind=i_def), parameter :: ndf1 = 3
    integer(kind=i_def), parameter :: ndf2 = 2

    ! Operators
    real(kind=r_def), dimension(ndf1, ndf2, ncell) :: x_plus_ay
    real(kind=r_def), dimension(ndf1, ndf2, ncell) :: x, y

    ! Reals
    real(kind=r_def), parameter :: a = 2.0_r_def

    real(kind=r_def)    :: answer
    integer(kind=i_def) :: df

    ! Set up operators
    x(:,1,1) = 0.1_r_def
    x(:,2,1) = 0.2_r_def

    y(:,1,1) = 1.1_r_def
    y(:,2,1) = 2.1_r_def

    ! Compute x + a*y
    call operator_x_plus_ay_kernel_code(cell, nlayers,    &
                                        ncell, x_plus_ay, &
                                        ncell, x,         &
                                        a,                &
                                        ncell, y,         &
                                        ndf1, ndf2)
    if ( r_def == real64 ) then
      use_tol = tol
    else
      use_tol = 10.0_r_def*spacing( maxval(x_plus_ay) )
    endif
    do df = 1,ndf1
      answer = 2.3_r_def
      @assertEqual(answer, x_plus_ay(df,1,1), use_tol)
      answer = 4.4_r_def
      @assertEqual(answer, x_plus_ay(df,2,1), use_tol)
    end do

  end subroutine test_x_plus_ay

  @Test( )
  subroutine test_setval_c( this )

    use, intrinsic :: iso_fortran_env, only: real64
    use operator_algebra_kernel_mod, only : operator_setval_c_kernel_code

    implicit none

    class(operator_algebra_test_type), intent(inout) :: this

    real(kind=r_def), parameter :: tol = 1.0e-12_r_def   ! r_def 64bit
    real(kind=r_def)            :: use_tol

    ! Mesh
    integer(kind=i_def), parameter :: nlayers = 1
    integer(kind=i_def), parameter :: cell = 1
    integer(kind=i_def), parameter :: ncell = 1

    ! Spaces
    integer(kind=i_def), parameter :: ndf1 = 3
    integer(kind=i_def), parameter :: ndf2 = 2

    ! Operators
    real(kind=r_def), dimension(ndf1, ndf2, ncell) :: x

    ! Reals
    real(kind=r_def), parameter :: a = 2.0_r_def

    real(kind=r_def), dimension(ndf1, ndf2, ncell) :: answer

    ! Compute x = a
    call operator_setval_c_kernel_code(cell, nlayers, &
                                       ncell, x,      &
                                       a,             &
                                       ndf1, ndf2)

    if ( r_def == real64 ) then
      use_tol = tol
    else
      use_tol = 10.0_r_def*spacing( maxval( x ) )
    endif

    answer = a
    @assertEqual(answer, x, use_tol)

  end subroutine test_setval_c

  @Test( )
  subroutine test_setval_x( this )

    use, intrinsic :: iso_fortran_env, only: real64
    use operator_algebra_kernel_mod, only : operator_setval_x_kernel_code

    implicit none

    class(operator_algebra_test_type), intent(inout) :: this

    real(kind=r_def), parameter :: tol = 1.0e-12_r_def   ! r_def 64bit
    real(kind=r_def)            :: use_tol

    ! Mesh
    integer(kind=i_def), parameter :: nlayers = 1
    integer(kind=i_def), parameter :: cell = 1
    integer(kind=i_def), parameter :: ncell = 1

    ! Spaces
    integer(kind=i_def), parameter :: ndf1 = 1
    integer(kind=i_def), parameter :: ndf2 = 2

    ! Operators
    real(kind=r_def), dimension(ndf1, ndf2, ncell) :: x
    real(kind=r_def), dimension(ndf1, ndf2, ncell) :: y

    ! Reals
    real(kind=r_def), parameter :: a = 2.0_r_def

    real(kind=r_def)    :: answer
    integer(kind=i_def) :: df

    ! Set up operators
    y(1,1,1) = 1.1_r_def
    y(2,1,1) = 2.1_r_def

    ! Compute a*x*y
    call operator_setval_x_kernel_code(cell, nlayers, &
                                       ncell, x,      &
                                       ncell, y,      &
                                       ndf1, ndf2)
    if ( r_def == real64 ) then
      use_tol = tol
    else
      use_tol = 10.0_r_def*spacing( maxval(x) )
    endif
    @assertEqual(x, y, use_tol)

  end subroutine test_setval_x


  @Test( )
  subroutine test_x_times_y( this )

    use, intrinsic :: iso_fortran_env, only: real64
    use operator_algebra_kernel_mod, only : operator_x_times_y_kernel_code

    implicit none

    class(operator_algebra_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-12_r_def   ! r_def 64bit
    real(r_def)            :: use_tol

    ! Mesh
    integer(i_def), parameter :: nlayers = 1
    integer(i_def), parameter :: cell = 1
    integer(i_def), parameter :: ncell = 1

    ! Spaces
    integer(i_def), parameter :: ndf1 = 3
    integer(i_def), parameter :: ndf2 = 2
    integer(i_def), parameter :: ndf3 = 1

    ! Operators
    real(r_def), dimension(ndf1, ndf2, ncell) :: x_times_y
    real(r_def), dimension(ndf1, ndf3, ncell) :: x
    real(r_def), dimension(ndf3, ndf2, ncell) :: y

    real(r_def), dimension(ndf1, ndf2) :: answer

    ! Set up operators
    x(:,1,1) = (/ 0.1_r_def, 3.4_r_def, 4.2_r_def /)
    y(1,:,1) = (/ 2.1_r_def, -6.1_r_def /)

    ! Compute x*y
    call operator_x_times_y_kernel_code(cell, nlayers,    &
                                        ncell, x_times_y, &
                                        ncell, x,         &
                                        ncell, y,         &
                                        ndf1, ndf2, ndf3)
    if ( r_def == real64 ) then
      use_tol = tol
    else
      use_tol = 10.0_r_def*spacing( maxval(x_times_y) )
    endif

    answer(:,1) = x(:,1,1)*y(1,1,1)
    answer(:,2) = x(:,1,1)*y(1,2,1)

    @assertEqual(answer, x_times_y(:,:,1), use_tol)

  end subroutine test_x_times_y

end module operator_algebra_kernel_mod_test
