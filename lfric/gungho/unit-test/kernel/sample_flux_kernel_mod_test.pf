!-----------------------------------------------------------------------------
! Copyright (c) 2019,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

module sample_flux_kernel_mod_test

  use constants_mod,                 only : i_def, r_def
  use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: sample_flux_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type sample_flux_test_type

  integer(i_def), parameter :: element_order = 0

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(sample_flux_test_type), intent(inout) :: this

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(sample_flux_test_type), intent(inout) :: this

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( this )

    use sample_flux_kernel_mod,     only : sample_flux_code

    use get_unit_test_w2nodal_basis_mod, only: get_w3_w2nodal_basis

    use get_unit_test_m3x3_dofmap_mod, only: get_w2_m3x3_dofmap, &
                                             get_w3_m3x3_dofmap

    use get_unit_test_m3x3_q3x3x3_sizes_mod, only: get_w2_m3x3_q3x3x3_size, &
                                                   get_w3_m3x3_q3x3x3_size

    implicit none

    class(sample_flux_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-6_r_def

    ! Test field data
    real(r_def),allocatable :: flux_data(:)
    real(r_def),allocatable :: u_data(:)
    real(r_def),allocatable :: rho_data(:)
    real(r_def),allocatable :: rm_data(:)

    real(r_def) :: answer

    integer(i_def) :: cell

    real(r_def), allocatable :: basis_rho(:,:,:)

    integer(i_def)  :: ndf_rho, undf_rho
    integer(i_def)  :: ndf_u, undf_u
    integer(i_def)  :: nlayers

    integer, allocatable      :: map_rho(:,:)
    integer, allocatable      :: map_u(:,:)

    ! Dummy variable for passing into multi-getter routines where item is not needed
    integer(i_def) :: unused

    ! Get canned data for a 3-layer mesh
    nlayers = 3

    ! Get sizes
    call get_w2_m3x3_q3x3x3_size( ndf_u, undf_u, unused, &
                                  unused, unused,        &
                                  unused, unused,        &
                                  nlayers )

    call get_w3_m3x3_q3x3x3_size( ndf_rho, undf_rho, unused, &
                                  unused, unused,            &
                                  unused, unused,            &
                                  nlayers )

    ! Get the w3 basis function at w2 nodal points
    call get_w3_w2nodal_basis(basis_rho)

    cell = 5
    ! Get dofmaps
    call get_w2_m3x3_dofmap(map_u)
    call get_w3_m3x3_dofmap(map_rho)

    ! Create the data arrays
    allocate(flux_data(undf_u))
    allocate(u_data(undf_u))
    allocate(rho_data(undf_rho))
    allocate(rm_data(undf_u))

    ! Initialise the data
    flux_data(:) = 0.0_r_def
    u_data(:) = 0.0_r_def
    rho_data(:) = 2.0_r_def
    rm_data(:) = 0.5_r_def

    u_data(map_u(5,cell)+0) = 0.0_r_def
    u_data(map_u(5,cell)+1) = 1.0_r_def
    u_data(map_u(6,cell)+1) = 1.0_r_def
    u_data(map_u(6,cell)+2) = 0.0_r_def
    rho_data(map_rho(1,cell)) = 3.0_r_def
    rho_data(map_rho(1,cell)+1) = 4.0_r_def

    call sample_flux_code(nlayers,         &
                          flux_data,       &
                          u_data,          &
                          rm_data,         &
                          rho_data,        &
                          ndf_u,           &
                          undf_u,          &
                          map_u(:,cell),   &
                          ndf_rho,         &
                          undf_rho,        &
                          map_rho(:,cell), &
                          basis_rho        &
                          )

     answer = 0.0_r_def
     @assertEqual(answer, flux_data(map_u(1,cell) ), tol)
     answer = 0.0_r_def
     @assertEqual(answer, flux_data(map_u(5,cell) ), tol)
     answer = 3.5_r_def
     @assertEqual(answer, flux_data(map_u(6,cell) ), tol)
     answer = 3.0_r_def
     @assertEqual(answer, flux_data(map_u(5,cell)+ 2 ), tol)

     deallocate(map_u)
     deallocate(map_rho)
     deallocate(basis_rho)
     deallocate(flux_data)
     deallocate(u_data)
     deallocate(rho_data)
     deallocate(rm_data)

  end subroutine test_all

end module sample_flux_kernel_mod_test
