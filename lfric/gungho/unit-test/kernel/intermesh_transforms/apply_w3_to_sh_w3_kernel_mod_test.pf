!-----------------------------------------------------------------------------
! (c) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> Test the apply_w3_to_sh_w3_kernel
module apply_w3_to_sh_w3_kernel_mod_test

  use constants_mod,                       only : i_def, r_def
  use get_unit_test_m3x3_q3x3x3_sizes_mod, only : get_w3_m3x3_q3x3x3_size
  use get_unit_test_m3x3_dofmap_mod,       only : get_w3_m3x3_dofmap
  use pFUnit_Mod

  implicit none

  private
  public :: apply_w3_to_sh_w3_test_type, test_all

  @TestCase
  type, extends(TestCase) :: apply_w3_to_sh_w3_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type apply_w3_to_sh_w3_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use base_mesh_config_mod,      only : geometry_planar, &
                                          topology_fully_periodic
    use feign_config_mod,          only : feign_base_mesh_config

    implicit none

    class(apply_w3_to_sh_w3_test_type), intent(inout) :: this

    call feign_base_mesh_config( filename='foo',                   &
                                 prime_mesh_name='unit_test',      &
                                 geometry=geometry_planar,         &
                                 offline_partitioning=.false.,     &
                                 topology=topology_fully_periodic, &
                                 fplane=.false., f_lat_deg=0.0_r_def )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod,        only: final_configuration

    implicit none

    class(apply_w3_to_sh_w3_test_type), intent(inout) :: this

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( this )

    use apply_w3_to_sh_w3_kernel_mod, only : apply_w3_to_sh_w3_code

   implicit none

    class(apply_w3_to_sh_w3_test_type), intent(inout) :: this

    real(kind=r_def),      parameter :: tol = 1.0e-12_r_def
    real(kind=r_def),      parameter :: dx = 5.0_r_def
    real(kind=r_def),      parameter :: dy = 3.0_r_def
    real(kind=r_def),      parameter :: dz = 7.0_r_def
    real(kind=r_def),      parameter :: dV = dx * dy * dz

    ! Fields
    real(kind=r_def),    allocatable :: rhs_w3_sh(:)
    real(kind=r_def),    allocatable :: field_w3(:)
    real(kind=r_def),    allocatable :: rhs_answer(:)
    real(kind=r_def),    allocatable :: T_ip1(:), T_i(:)

    integer(kind=i_def)              :: i, j, k, cell
    integer(kind=i_def)              :: nlayers, nlayers_sh, ncells, ncells_sh
    integer(kind=i_def)              :: nqp_h, nqp_v
    integer(kind=i_def)              :: ndf_w3_sh, ndf_w3
    integer(kind=i_def)              :: dim_space, dim_space_diff
    integer(kind=i_def)              :: undf_w3_sh, undf_w3

    ! Dofmaps
    integer(kind=i_def), allocatable :: map_w3_sh(:,:)
    integer(kind=i_def), allocatable :: map_w3(:,:)

    nlayers = 3
    nlayers_sh = nlayers + 1
    call get_w3_m3x3_q3x3x3_size( ndf_w3, undf_w3, ncells,   &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v,              &
                                  nlayers )
    call get_w3_m3x3_q3x3x3_size( ndf_w3_sh, undf_w3_sh, ncells_sh, &
                                  dim_space, dim_space_diff,        &
                                  nqp_h, nqp_v,                     &
                                  nlayers_sh )


    call get_w3_m3x3_dofmap(map_w3, nlayers)
    call get_w3_m3x3_dofmap(map_w3_sh, nlayers_sh)
    cell = 1

    ! Create the data
    allocate( rhs_w3_sh( undf_w3_sh ) )
    allocate( rhs_answer( undf_w3_sh ) )
    allocate( field_w3( undf_w3 ) )
    allocate( T_ip1( undf_w3 ) )
    allocate( T_i( undf_w3 ) )

    rhs_w3_sh(:) = 0.0_r_def

    do cell = 1, ncells
      ! Fill values for interior of domain
      do k = 0, nlayers - 1
        ! Density increasing linearly with height
        field_w3(map_w3(1, cell) + k) = real(k+1, r_def)

        ! These are the values that the transform matrix should have
        ! for a uniform mesh
        T_ip1(map_w3(1, cell) + k) = dV / 2.0_r_def
        T_i(map_w3(1, cell) + k) = dV / 2.0_r_def
      end do
    end do

    cell = 1
    call apply_w3_to_sh_w3_code(                    &
                                 nlayers_sh,        &
                                 rhs_w3_sh,         &
                                 field_w3,          &
                                 T_ip1,             &
                                 T_i,               &
                                 ndf_w3_sh,         &
                                 undf_w3_sh,        &
                                 map_w3_sh(:,cell), &
                                 ndf_w3,            &
                                 undf_w3,           &
                                 map_w3(:,cell)     &
                               )

    ! Look at first column
    rhs_answer(:) = 0.0_r_def
    rhs_answer(map_w3_sh(1,cell)+0) = dV / 2.0_r_def
    rhs_answer(map_w3_sh(1,cell)+1) = 3.0_r_def * dV / 2.0_r_def
    rhs_answer(map_w3_sh(1,cell)+2) = 5.0_r_def * dV / 2.0_r_def
    rhs_answer(map_w3_sh(1,cell)+3) = 3.0_r_def * dV / 2.0_r_def

    do k = 0, nlayers_sh - 1
        @assertEqual(rhs_answer(map_w3_sh(1, cell)+k), rhs_w3_sh(map_w3_sh(1, cell)+k), tol)
    end do


    deallocate( rhs_w3_sh )
    deallocate( rhs_answer )
    deallocate( field_w3 )
    deallocate( T_ip1 )
    deallocate( T_i )
    deallocate( map_w3_sh )
    deallocate( map_w3 )

  end subroutine test_all

end module apply_w3_to_sh_w3_kernel_mod_test
