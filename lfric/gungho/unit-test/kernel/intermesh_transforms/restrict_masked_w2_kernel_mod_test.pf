!-----------------------------------------------------------------------------
! (C) Crown copyright 2022 Met Office. All rights reserved.
! For further details please refer to the file COPYRIGHT.txt
! which you should have received as part of this distribution.
!-----------------------------------------------------------------------------
!> Test for the masked W2 restriction kernel
module restrict_masked_w2_kernel_mod_test

  use pFUnit_mod
  use constants_mod,                 only : i_def, r_def, rmdi
  use restrict_masked_w2_kernel_mod, only : restrict_masked_w2_kernel_code

  implicit none

  private
  public :: restrict_masked_w2_test_type, test_edge, test_corner

  @TestCase
  type, extends(TestCase) :: restrict_masked_w2_test_type
     private
     integer(kind=i_def) :: ncell_fine, undf_fine, undf_coarse
     integer(kind=i_def), allocatable, dimension(:,:) :: cell_map
     integer(kind=i_def), allocatable, dimension(:,:) :: map_fine
     integer(kind=i_def), allocatable, dimension(:)   :: map_coarse
     real(kind=r_def), allocatable, dimension(:) :: field_fine
     real(kind=r_def), allocatable, dimension(:) :: field_coarse
     real(kind=r_def), allocatable, dimension(:) :: mask_fine
     real(kind=r_def), allocatable, dimension(:) :: answer, rmultiplicity
   contains
     procedure setUp
     procedure tearDown
     procedure test_edge
     procedure test_corner
  end type restrict_masked_w2_test_type

  integer(kind=i_def), parameter :: nlayers = 3

  ! Number of fine cells per coarse cell in x-direction (for quad elements)
  integer(kind=i_def), parameter :: ncell_fine_per_coarse_x = 2

  ! Number of fine cells per coarse cell in y-direction (for quad elements)
  integer(kind=i_def), parameter :: ncell_fine_per_coarse_y = 3

  integer(kind=i_def) :: ndf_fine = 6
  integer(kind=i_def) :: ndf_coarse = 6
  integer(kind=i_def) :: undf_coarse = 16
  integer(kind=i_def) :: undf_fine = 75

  real(r_def), parameter :: tol = 1.0e-12_r_def

  real(r_def), parameter :: input_coarse = 12.0_r_def
contains

  subroutine setUp( this )

    implicit none
    class(restrict_masked_w2_test_type), intent(inout) :: this

    integer(kind=i_def) :: lp_x, lp_y

    this%ncell_fine =  ncell_fine_per_coarse_x * ncell_fine_per_coarse_y

    allocate( this%cell_map(ncell_fine_per_coarse_x, &
                            ncell_fine_per_coarse_y) )
    allocate( this%map_fine(ndf_fine, this%ncell_fine) )
    allocate( this%map_coarse(ndf_coarse) )
    allocate( this%field_coarse(undf_coarse) )
    allocate( this%field_fine(undf_fine) )
    allocate( this%mask_fine(undf_fine) )
    allocate( this%rmultiplicity(undf_fine) )
    allocate( this%answer(undf_coarse) )

    ! Construct coarse to fine cell id mappings based on x/y array index
    do lp_y = 1, ncell_fine_per_coarse_y
      do lp_x = 1, ncell_fine_per_coarse_x
       this%cell_map(lp_x, lp_y) = lp_x + (lp_y - 1)*ncell_fine_per_coarse_x
      end do
    end do

    ! Make a W2 DoF map for 2*3*3 cells
    this%map_fine = reshape( (/  1,  4,  7, 10, 13, 14, &
                                 7, 17, 20, 23, 26, 27, &
                                30, 33, 36,  4, 39, 40, &
                                36, 43, 46, 17, 49, 50, &
                                53, 56, 59, 33, 62, 63, &
                                59, 66, 69, 43, 72, 73  &
                              /), (/ ndf_fine, this%ncell_fine /) )

    ! DoF map for single coarse cell
    this%map_coarse = (/ 1, 4, 7, 10, 13, 14 /)

  end subroutine setUp

  subroutine tearDown( this )

    implicit none

    class(restrict_masked_w2_test_type), intent(inout) :: this

    deallocate( this%cell_map,     &
                this%map_fine,     &
                this%map_coarse,   &
                this%mask_fine,    &
                this%field_coarse, &
                this%field_fine )

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_edge( this )

    implicit none

    class(restrict_masked_w2_test_type), intent(inout) :: this

    integer(kind=i_def) :: df, k, lp_x, lp_y, cell_f

    this%field_coarse(:) = input_coarse
    this%field_fine(:) = rmdi
    this%mask_fine(:) = rmdi
    this%rmultiplicity(:) = rmdi

    ! Set up fine level mask which determines which DoFs are used in
    ! restriction to corresponding DoFs on coarse field.  Only the outer
    ! most W2 DoFs are considered, so mask values at all other
    ! interior DoF locations are redundant (will remain rmdi) and are not
    ! shown (X).
    !
    ! Fine mask (2x3) 2D layer, top and bottom mask values not shown
    ! The hashed cells denote the cells corresponding to mask values of 1.
    !
    !    +--1--+--0--+
    !    | /// |     |
    !    1 /F/ X     0
    !    | /// |     |
    !    +--X--+--X--+
    !    | /// |     |
    !    1 /F/ X     0
    !    | /// |     |
    !    +--X--+--X--+
    !    | /// |     |
    !    1 /F/ X     0
    !    | /// |     |
    !    +--1--+--0--+

    !    Dof arrangements per cell
    !
    !    -- 4 --
    !    |      |
    !    1      3
    !    |      |
    !    -- 2 --

    do k = 0, nlayers - 1
      do lp_x = 1, ncell_fine_per_coarse_x
        do lp_y = 1, ncell_fine_per_coarse_y

          cell_f = this%cell_map(lp_x, lp_y)

          if ( lp_x == 1 ) then
            ! Fine DoFs contributing to the West edge of the coarse cell (DoF 1)
            ! The coarse answer corresponding to this will be 12 + (6 + 3*k)/3
            ! i.e. Average over lp_y=1,3 so
            ! output= input_coarse + 1*((1+k)+(2+k)+(3+k))/3
            this%field_fine(this%map_fine(1,cell_f)+k) = real(lp_y + k, r_def)
            this%mask_fine(this%map_fine(1,cell_f)+k) = 1.0_r_def

            ! Weight for W2 field is 1 (or 0.5 for a shared DoF)
            this%rmultiplicity(this%map_fine(1,cell_f)+k) = 1.0_r_def

          else if ( lp_x == ncell_fine_per_coarse_x ) then
            ! Fine DoFs contributing to the East edge of the coarse cell (DoF 3)
            ! The coarse answer corresponding to this will be 12
            ! output = input_coarse + 0*((2+k)+(3+k)+(4+k))/3 = 0*(9 + 3*k)/3
            this%field_fine(this%map_fine(3,cell_f)+k) = real(lp_y + k + 1, r_def)
            this%mask_fine(this%map_fine(3,cell_f)+k) = 0.0_r_def

            ! Weight for W2 field is 1 (or 0.5 for a shared DoF)
            this%rmultiplicity(this%map_fine(3,cell_f)+k) = 1.0_r_def

          end if

          if ( lp_y == 1 ) then
            ! Fine DoFs contributing to the North edge of the coarse cell (DoF 4)
            ! The coarse answer corresponding to this will be 12 + (1 + k)
            ! i.e. output =  input_coarse + (1*(1+k) + 0*(2+k) )/1
            this%field_fine(this%map_fine(4,cell_f)+k) = real(lp_x + k, r_def)

            if ( lp_x == 1 ) then
              this%mask_fine(this%map_fine(4,cell_f)+k) = 1.0_r_def
            else if ( lp_x == ncell_fine_per_coarse_x ) then
              this%mask_fine(this%map_fine(4,cell_f)+k) = 0.0_r_def
            end if

            ! Weight for W2 field is 1 (or 0.5 for a shared DoF)
            this%rmultiplicity(this%map_fine(4,cell_f)+k) = 1.0_r_def

          else if ( lp_y == ncell_fine_per_coarse_y ) then
            ! Fine DoFs contributing to the South edge of the coarse cell (DoF 2)
            ! The coarse answer corresponding to this will be 12 + (2 + k)
            ! i.e. output = input_coarse + (1*(2+k) + 0*(3+k) )/1
            this%field_fine(this%map_fine(2,cell_f)+k) = real(lp_x + k + 1, r_def)

            if ( lp_x == 1 ) then
              this%mask_fine(this%map_fine(2,cell_f)+k) = 1.0_r_def
            else if ( lp_x == ncell_fine_per_coarse_x ) then
              this%mask_fine(this%map_fine(2,cell_f)+k) = 0.0_r_def
            end if

            ! Weight for W2 field is 1 (or 0.5 for a shared DoF)
            this%rmultiplicity(this%map_fine(2,cell_f)+k) = 1.0_r_def

          end if

          ! Vertical components (not incrementing, so no dependence
          ! on input_coarse)
          ! Total coarse answer will be (6 + 3*k)/3
          this%field_fine(this%map_fine(5, cell_f)+k) = real(lp_y + k, r_def)
          this%rmultiplicity(this%map_fine(5, cell_f)+k) = 1.0_r_def

          if (k == nlayers-1) then
            ! Total coarse answer will be (9 + 3*k)/3
            this%field_fine(this%map_fine(6, cell_f)+k) = real(lp_y + k +1, r_def)
            this%rmultiplicity(this%map_fine(6, cell_f)+k) = 1.0_r_def
          end if

          if ( lp_x == 1 ) then
            this%mask_fine(this%map_fine(5,cell_f)+k) = 1.0_r_def
            this%mask_fine(this%map_fine(6,cell_f)+k) = 1.0_r_def
          else if ( lp_x == ncell_fine_per_coarse_x ) then
            this%mask_fine(this%map_fine(5,cell_f)+k) = 0.0_r_def
            this%mask_fine(this%map_fine(6,cell_f)+k) = 0.0_r_def
          end if

        end do
      end do
    end do

    ! Fill coarse answer field using values from above
    do k = 0, nlayers - 1
      this%answer(this%map_coarse(1)+k) = real((12 + (6 + 3*k)/3.0_r_def), r_def)
      this%answer(this%map_coarse(2)+k) = real(12 + 2 + k, r_def)
      this%answer(this%map_coarse(3)+k) = 12.0_r_def
      this%answer(this%map_coarse(4)+k) = real(12 + 1 + k, r_def)
      this%answer(this%map_coarse(5)+k) = real((6 + 3*k)/3.0_r_def, r_def)
      if (k == nlayers-1) then
        this%answer(this%map_coarse(6)+k) = real((9 + 3*k)/3.0_r_def, r_def)
      end if
    end do

    call restrict_masked_w2_kernel_code( nlayers,                 &
                                         this%cell_map,           &
                                         ncell_fine_per_coarse_x, &
                                         ncell_fine_per_coarse_y, &
                                         this%ncell_fine,         &
                                         this%field_coarse,       &
                                         this%field_fine,         &
                                         this%rmultiplicity,      &
                                         this%mask_fine,          &
                                         undf_coarse,             &
                                         this%map_coarse,         &
                                         ndf_fine,                &
                                         undf_fine,               &
                                         this%map_fine            )

    ! Check answer for all DoFs
    do df = 1, undf_coarse
      @assertEqual( this%answer(df), this%field_coarse(df), tol )
    end do

  end subroutine test_edge

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_corner( this )

    implicit none

    class(restrict_masked_w2_test_type), intent(inout) :: this

    integer(kind=i_def) :: df, k, lp_x, lp_y, cell_f

    this%field_coarse(:) = input_coarse
    this%field_fine(:) = rmdi
    this%mask_fine(:) = rmdi
    this%rmultiplicity(:) = rmdi

    ! Set up fine level mask which determines which DoFs are used in
    ! restriction to corresponding DoFs on coarse field.  Only the outer
    ! most W2 DoFs are considered, so mask values at all other
    ! interior DoF locations are redundant (will remain rmdi) and are not
    ! shown (X).
    !
    ! Fine mask (2x3) 2D layer, top and bottom mask values not shown
    ! The hashed cells denote the cells corresponding to mask values of 1.
    !
    !    +--0--+--0--+
    !    |     |     |
    !    0     X     0
    !    |     |     |
    !    +--X--+--X--+
    !    |     |     |
    !    0     X     0
    !    |     |     |
    !    +--X--+--X--+
    !    |     | /// |
    !    0     X /F/ 1
    !    |     | /// |
    !    +--0--+--1--+

    !    Dof arrangements per cell
    !
    !    -- 4 --
    !    |      |
    !    1      3
    !    |      |
    !    -- 2 --

    do k = 0, nlayers - 1
      do lp_x = 1, ncell_fine_per_coarse_x
        do lp_y = 1, ncell_fine_per_coarse_y

          cell_f = this%cell_map(lp_x, lp_y)

          if ( lp_x == 1 ) then
            ! Fine DoFs contributing to the West edge of the coarse cell (DoF 1)
            ! The coarse answer corresponding to this will be 12
            ! i.e. Average over lp_y=1,3 so
            ! output = 12 + 0*((1+k)+(2+k)+(3+k))/3
            this%field_fine(this%map_fine(1,cell_f)+k) = real(lp_y + k, r_def)
            this%mask_fine(this%map_fine(1,cell_f)+k) = 0.0_r_def

            ! Weight for W2 field is 1 (or 0.5 for a shared DoF)
            this%rmultiplicity(this%map_fine(1,cell_f)+k) = 1.0_r_def

          else if ( lp_x == ncell_fine_per_coarse_x ) then
            ! Fine DoFs contributing to the East edge of the coarse cell (DoF 3)
            ! The coarse answer corresponding to this will be 12 + (4 + k)
            ! output = input_coarse + (0*(2+k)+0*(3+k)+1*(4+k))/ 1
            this%field_fine(this%map_fine(3,cell_f)+k) = real(lp_y + k + 1, r_def)
            if ( lp_y == ncell_fine_per_coarse_y ) then
              this%mask_fine(this%map_fine(3,cell_f)+k) = 1.0_r_def
            else
              this%mask_fine(this%map_fine(3,cell_f)+k) = 0.0_r_def
            end if

            ! Weight for W2 field is 1 (or 0.5 for a shared DoF)
            this%rmultiplicity(this%map_fine(3,cell_f)+k) = 1.0_r_def

          end if

          if ( lp_y == 1 ) then
            ! Fine DoFs contributing to the North edge of the coarse cell (DoF 4)
            ! The coarse answer corresponding to this will be 12
            ! output = input_coarse + (0*(1+k) + 0*(2+k) )
            this%field_fine(this%map_fine(4,cell_f)+k) = real(lp_x + k, r_def)
            this%mask_fine(this%map_fine(4,cell_f)+k) = 0.0_r_def

            ! Weight for W2 field is 1 (or 0.5 for a shared DoF)
            this%rmultiplicity(this%map_fine(4,cell_f)+k) = 1.0_r_def

          else if ( lp_y == ncell_fine_per_coarse_y ) then
            ! Fine DoFs contributing to the South edge of the coarse cell (DoF 2)
            ! The coarse answer corresponding to this will be 12 + (3 + k)
            ! output = input_coarse + (0*(2+k) + 1*(3+k) )/1
            this%field_fine(this%map_fine(2,cell_f)+k) = real(lp_x + k + 1, r_def)

            if ( lp_x == ncell_fine_per_coarse_x ) then
              this%mask_fine(this%map_fine(2,cell_f)+k) = 1.0_r_def
            else
              this%mask_fine(this%map_fine(2,cell_f)+k) = 0.0_r_def
            end if

            ! Weight for W2 field is 1 (or 0.5 for a shared DoF)
            this%rmultiplicity(this%map_fine(2,cell_f)+k) = 1.0_r_def

          end if

          ! Vertical components (not incrementing so no dependence on
          ! input_coarse).
          ! Total coarse answer will be (3+k)
          this%field_fine(this%map_fine(5, cell_f)+k) = real(lp_y + k, r_def)
          this%rmultiplicity(this%map_fine(5, cell_f)+k) = 1.0_r_def

          if (k == nlayers-1) then
            ! Total coarse answer will be (4+k)
            this%field_fine(this%map_fine(6, cell_f)+k) = real(lp_y + k +1, r_def)
            this%rmultiplicity(this%map_fine(6, cell_f)+k) = 1.0_r_def
          end if

          if ( lp_x == 1 ) then
            this%mask_fine(this%map_fine(5,cell_f)+k) = 0.0_r_def
            this%mask_fine(this%map_fine(6,cell_f)+k) = 0.0_r_def
          else if ( lp_x == ncell_fine_per_coarse_x ) then
            if ( lp_y == ncell_fine_per_coarse_y ) then
              this%mask_fine(this%map_fine(5,cell_f)+k) = 1.0_r_def
              this%mask_fine(this%map_fine(6,cell_f)+k) = 1.0_r_def
            else
              this%mask_fine(this%map_fine(5,cell_f)+k) = 0.0_r_def
              this%mask_fine(this%map_fine(6,cell_f)+k) = 0.0_r_def
            end if
          end if

        end do
      end do
    end do

    ! Fill coarse answer field using values from above
    do k = 0, nlayers - 1
      this%answer(this%map_coarse(1)+k) = 12.0_r_def
      this%answer(this%map_coarse(2)+k) = real(12 + 3 + k, r_def)
      this%answer(this%map_coarse(3)+k) = real(12 + 4 + k, r_def)
      this%answer(this%map_coarse(4)+k) = 12.0_r_def
      this%answer(this%map_coarse(5)+k) = real((3 + k), r_def)
      if (k == nlayers-1) then
        this%answer(this%map_coarse(6)+k) = real((4 + k), r_def)
      end if
    end do

    call restrict_masked_w2_kernel_code( nlayers,                 &
                                         this%cell_map,           &
                                         ncell_fine_per_coarse_x, &
                                         ncell_fine_per_coarse_y, &
                                         this%ncell_fine,         &
                                         this%field_coarse,       &
                                         this%field_fine,         &
                                         this%rmultiplicity,      &
                                         this%mask_fine,          &
                                         undf_coarse,             &
                                         this%map_coarse,         &
                                         ndf_fine,                &
                                         undf_fine,               &
                                         this%map_fine            )

    ! Check answer for all DoFs
    do df = 1, undf_coarse
      @assertEqual( this%answer(df), this%field_coarse(df), tol )
    end do

  end subroutine test_corner


end module restrict_masked_w2_kernel_mod_test
