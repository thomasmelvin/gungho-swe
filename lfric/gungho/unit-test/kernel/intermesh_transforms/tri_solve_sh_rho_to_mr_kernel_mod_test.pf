!-----------------------------------------------------------------------------
! (c) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> Test the tri_solve_sh_rho_to_mr kernel
!>
module tri_solve_sh_rho_to_mr_kernel_mod_test
  use constants_mod,         only : i_def, r_def
  use pFUnit_Mod

  implicit none

  private

  public :: tri_solve_sh_rho_to_mr_kernel_test_type, test_all

  @TestCase
  type, extends(TestCase) :: tri_solve_sh_rho_to_mr_kernel_test_type
    private

  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type tri_solve_sh_rho_to_mr_kernel_test_type

contains
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(tri_solve_sh_rho_to_mr_kernel_test_type), intent(inout) :: this

  end subroutine setUp
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod,        only: final_configuration

    implicit none


    class(tri_solve_sh_rho_to_mr_kernel_test_type), intent(inout) :: this

    call final_configuration()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  @Test
  subroutine test_all( this )

    use, intrinsic :: iso_fortran_env, only      : real64
    use tri_solve_sh_rho_to_mr_kernel_mod, only : tri_solve_sh_rho_to_mr_code

    implicit none

    class(tri_solve_sh_rho_to_mr_kernel_test_type), intent(inout) :: this


    integer(kind=i_def) :: nlayers_shifted, nlayers, ncells, cell
    integer(kind=i_def) :: ndf_wt, undf_wt, ndf_sh_w3, undf_sh_w3
    integer(kind=i_def), allocatable :: map_sh_w3(:,:)
    integer(kind=i_def), allocatable :: map_wt(:,:)
    real(kind=r_def), allocatable    :: tri_below(:)
    real(kind=r_def), allocatable    :: tri_diag(:)
    real(kind=r_def), allocatable    :: tri_above(:)
    real(kind=r_def), allocatable    :: field_wt(:)
    real(kind=r_def), allocatable    :: field_sh_w3(:)
    real(kind=r_def), allocatable    :: answer(:)
    real(kind=r_def)                 :: tol

    ! Set up a single column mesh
    nlayers = 3
    nlayers_shifted = nlayers + 1
    ndf_wt = 2
    ndf_sh_w3 = 1
    undf_wt = 4
    undf_sh_w3 = 4
    ncells = 1

    allocate( answer(undf_sh_w3) )
    allocate( field_sh_w3(undf_sh_w3) )
    allocate( tri_below(undf_sh_w3) )
    allocate( tri_diag(undf_sh_w3) )
    allocate( tri_above(undf_sh_w3) )
    allocate( field_wt(undf_wt) )
    allocate( map_wt(1, ncells) )
    allocate( map_sh_w3(1, ncells) )

    map_wt(1,:) = 1_i_def
    map_wt(2,:) = 2_i_def
    map_sh_w3(:,:) = 1_i_def

    ! Consider this multiplication (randomly chosen)
    ! ( 6   2   0   0 )  ( 1 )     ( 10 )
    ! ( 1  12   3   0 )  ( 2 )  =  ( 34 )
    ! ( 0   2   5   1 )  ( 3 )     ( 23 )
    ! ( 0   0   1   2 )  ( 4 )     ( 11 )

    tri_below    = (/  0.0_r_def,  1.0_r_def,  2.0_r_def,  1.0_r_def /)
    tri_diag     = (/  6.0_r_def, 12.0_r_def,  5.0_r_def,  2.0_r_def /)
    tri_above    = (/  2.0_r_def,  3.0_r_def,  1.0_r_def,  0.0_r_def /)
    answer       = (/  1.0_r_def,  2.0_r_def,  3.0_r_def,  4.0_r_def /)
    field_sh_w3  = (/ 10.0_r_def, 34.0_r_def, 23.0_r_def, 11.0_r_def /)

    cell = 1
    call tri_solve_sh_rho_to_mr_code(                         &
                                      nlayers,                &
                                      field_wt,               &
                                      field_sh_w3,            &
                                      tri_below,              &
                                      tri_diag,               &
                                      tri_above,              &
                                      ndf_wt, undf_wt,        &
                                      map_wt(:,cell),         &
                                      ndf_sh_w3, undf_sh_w3,  &
                                      map_sh_w3(:,cell)       &
                                    )

    if ( r_def == real64 ) then
       tol = 1.0e-12_r_def
    else
       tol = 10.0_r_def*spacing( maxval( field_wt ) )
    end if
    @assertEqual(answer, field_wt, tol)

    deallocate(map_sh_w3)
    deallocate(map_wt)
    deallocate(field_wt)
    deallocate(tri_below)
    deallocate(tri_diag)
    deallocate(tri_above)
    deallocate(answer)
    deallocate(field_sh_w3)

  end subroutine test_all

end module tri_solve_sh_rho_to_mr_kernel_mod_test
