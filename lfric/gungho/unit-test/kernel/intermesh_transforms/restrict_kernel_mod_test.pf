!-----------------------------------------------------------------------------
! (C) Crown copyright 2019 Met Office. All rights reserved.
! For further details please refer to the file COPYRIGHT.txt
! which you should have received as part of this distribution.
!-----------------------------------------------------------------------------
!> Test for the restriction kernel
module restrict_kernel_mod_test
  use pFUnit_mod
  use constants_mod, only : i_def, r_def

  implicit none
  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: restrict_test_type
     private
   contains
     procedure :: test_all
  end type restrict_test_type

contains
  @test
  subroutine test_all( this )
    use restrict_kernel_mod, only : restrict_kernel_code
    implicit none
    class(restrict_test_type), intent(inout) :: this

    integer(kind=i_def) :: lp_x, lp_y
    ! Scalars
    integer(kind=i_def) :: nlayers
    integer(kind=i_def) :: ncell_f_per_c_x ! number of fine cells per coarse in x
    integer(kind=i_def) :: ncell_f_per_c_y ! number of fine cells per coarse in y
    integer(kind=i_def) :: ncell_f         ! number of fine cells
    integer(kind=i_def) :: ndf             ! number of dofs per cell. Same on each mesh
    integer(kind=i_def) :: undf_f, undf_c
    ! Integer Arrays
    integer(kind=i_def), allocatable, dimension(:,:) :: cell_map
    integer(kind=i_def), allocatable, dimension(:,:) :: map_f ! Cell and dof valued
    integer(kind=i_def), allocatable, dimension(:)   :: map_c ! only dof valued
    ! Real Arrays
    real(kind=r_def), allocatable, dimension(:) :: fc, ff  ! fields on coarse and fine
    real(r_def), parameter :: tol = 1.0e-12_r_def

        ! set the scalars by hand
    nlayers = 3
    ncell_f_per_c_x = 2 ! quads
    ncell_f_per_c_y = 2 ! quads

    ncell_f = 1_i_def * ncell_f_per_c_x * ncell_f_per_c_y ! only need one coarse cell
    ndf = 1 ! keep it simple (W3, discontinuous)
    undf_f = nlayers * ncell_f * ndf ! true for W3 on a single coarse column
    undf_c = undf_f / (ncell_f_per_c_x * ncell_f_per_c_y)

    allocate( cell_map(ncell_f_per_c_x,  &
                       ncell_f_per_c_y), &
              map_f(ndf,ncell_f),        &
              map_c(ndf) )
    allocate( fc(undf_c),                &
              ff(undf_f) )

    ! set simple values for index sets
    do lp_y = 1, ncell_f_per_c_y
      do lp_x = 1, ncell_f_per_c_x
       cell_map(lp_x, lp_y) = lp_x + (lp_y - 1)*ncell_f_per_c_y
      end do
    end do
    do lp_x = 1, ncell_f
       map_f(1,lp_x) = 1 + (lp_x-1)*nlayers
    end do
    map_c(1) = 1


    ! set simple values for the fields
    ff(:) = 1.0_r_def
    fc(:) = 0.0_r_def

    call restrict_kernel_code( nlayers,        &
                              cell_map,        &
                              ncell_f_per_c_x, &
                              ncell_f_per_c_y, &
                              ncell_f,         &
                              fc,              &
                              ff,              &
                              undf_c,          &
                              map_c,           &
                              ndf,             &
                              undf_f,          &
                              map_f )


    @assertEqual( fc(1), 1.0_r_def, tol)
    @assertEqual( fc(2), 1.0_r_def, tol)
    @assertEqual( fc(3), 1.0_r_def, tol)



    deallocate( cell_map, &
                map_f,    &
                map_c,    &
                fc,       &
                ff )

  end subroutine test_all

end module restrict_kernel_mod_test
