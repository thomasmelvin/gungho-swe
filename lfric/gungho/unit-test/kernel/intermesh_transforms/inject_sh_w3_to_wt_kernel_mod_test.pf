!-----------------------------------------------------------------------------
! (c) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> Test the inject_sh_w3_to_wt_kernel
module inject_sh_w3_to_wt_kernel_mod_test

  use constants_mod,                       only : i_def, r_def
  use get_unit_test_m3x3_q3x3x3_sizes_mod, only : get_w3_m3x3_q3x3x3_size, &
                                                  get_wtheta_m3x3_q3x3x3_size
  use get_unit_test_m3x3_dofmap_mod,       only : get_w3_m3x3_dofmap, &
                                                  get_wtheta_m3x3_dofmap
  use pFUnit_Mod

  implicit none

  private
  public :: inject_sh_w3_to_wt_test_type, test_all

  @TestCase
  type, extends(TestCase) :: inject_sh_w3_to_wt_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type inject_sh_w3_to_wt_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use base_mesh_config_mod,      only : geometry_planar,    &
                                          topology_fully_periodic
    use feign_config_mod,          only : feign_base_mesh_config

    implicit none

    class(inject_sh_w3_to_wt_test_type), intent(inout) :: this

    call feign_base_mesh_config( filename='foo',                      &
                                 prime_mesh_name='unit_test',         &
                                 geometry=geometry_planar,            &
                                 offline_partitioning=.false.,        &
                                 topology=topology_fully_periodic,    &
                                 fplane=.false., f_lat_deg=0.0_r_def )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod,        only: final_configuration

    implicit none

    class(inject_sh_w3_to_wt_test_type), intent(inout) :: this

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( this )

    use inject_sh_w3_to_wt_kernel_mod, only : inject_sh_w3_to_wt_code

   implicit none

    class(inject_sh_w3_to_wt_test_type), intent(inout) :: this

    real(kind=r_def),      parameter :: tol = 1.0e-12_r_def
    real(kind=r_def),      parameter :: dx = 19.0_r_def
    real(kind=r_def),      parameter :: dy = 6.0_r_def
    real(kind=r_def),      parameter :: dz = 8.0_r_def

    ! Fields
    real(kind=r_def),    allocatable :: field_w3_sh(:)
    real(kind=r_def),    allocatable :: field_wt(:)
    real(kind=r_def),    allocatable :: answer(:)

    integer(kind=i_def)              :: i, j, k, cell
    integer(kind=i_def)              :: nlayers, nlayers_sh, ncells, ncells_sh
    integer(kind=i_def)              :: nqp_h, nqp_v
    integer(kind=i_def)              :: ndf_w3_sh, ndf_wt
    integer(kind=i_def)              :: dim_space, dim_space_diff
    integer(kind=i_def)              :: undf_w3_sh, undf_wt

    ! Dofmaps
    integer(kind=i_def), allocatable :: map_w3_sh(:,:)
    integer(kind=i_def), allocatable :: map_wt(:,:)

    nlayers = 3
    nlayers_sh = nlayers + 1
    call get_wtheta_m3x3_q3x3x3_size( ndf_wt, undf_wt, ncells,   &
                                      dim_space, dim_space_diff, &
                                      nqp_h, nqp_v,              &
                                      nlayers )
    call get_w3_m3x3_q3x3x3_size( ndf_w3_sh, undf_w3_sh, ncells_sh, &
                                  dim_space, dim_space_diff,        &
                                  nqp_h, nqp_v,                     &
                                  nlayers_sh )


    call get_wtheta_m3x3_dofmap(map_wt, nlayers)
    call get_w3_m3x3_dofmap(map_w3_sh, nlayers_sh)
    cell = 1

    ! Create the data
    allocate( field_w3_sh( undf_w3_sh ) )
    allocate( answer( undf_w3_sh ) )
    allocate( field_wt( undf_wt ) )

    field_w3_sh(:) = 0.0_r_def

    do cell = 1, ncells
      ! Fill values for interior of domain
      do k = 0, nlayers
        ! Consider a field increasing linearly with height
        answer(map_wt(1, cell) + k) = real(k+1, r_def)
        field_w3_sh(map_w3_sh(1, cell) + k) = real(k+1, r_def)
      end do

      ! Adjust original field at top and bottom
      field_w3_sh(map_w3_sh(1, cell)) = 1.25_r_def
      field_w3_sh(map_w3_sh(1, cell) + nlayers) = real(nlayers+1, r_def) - 0.25_r_def
    end do

    cell = 1
    call inject_sh_w3_to_wt_code(                   &
                                  nlayers,          &
                                  field_wt,         &
                                  field_w3_sh,      &
                                  ndf_wt,           &
                                  undf_wt,          &
                                  map_wt(:,cell),   &
                                  ndf_w3_sh,        &
                                  undf_w3_sh,       &
                                  map_w3_sh(:,cell) &
                                )

    do k = 0, nlayers_sh - 1
        @assertEqual(answer(map_wt(1, cell)+k), field_wt(map_wt(1, cell)+k), tol)
    end do

    deallocate( field_w3_sh )
    deallocate( answer )
    deallocate( field_wt )
    deallocate( map_w3_sh )
    deallocate( map_wt )

  end subroutine test_all

end module inject_sh_w3_to_wt_kernel_mod_test
