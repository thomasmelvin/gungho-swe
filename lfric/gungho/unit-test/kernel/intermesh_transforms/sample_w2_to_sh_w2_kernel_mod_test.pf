!-----------------------------------------------------------------------------
! (c) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the kernel sampling from W2 to the shifted W2 space
!>
module sample_w2_to_sh_w2_kernel_mod_test

  use constants_mod,         only: i_def, r_def
  use reference_element_mod, only: E, W, N, S, T, B
  use pFUnit_Mod


  implicit none

  private
  public :: sample_w2_to_sh_w2_test_type, test_all

  @TestCase
  type, extends(TestCase) :: sample_w2_to_sh_w2_test_type
    private
  contains

    procedure setUp
    procedure tearDown
    procedure test_all

  end type sample_w2_to_sh_w2_test_type

contains
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(sample_w2_to_sh_w2_test_type), intent(inout) :: this

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod, only: final_configuration

    implicit none

    class(sample_w2_to_sh_w2_test_type), intent(inout) :: this

    call final_configuration()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( this )

    use sample_w2_to_sh_w2_kernel_mod, only : sample_w2_to_sh_w2_code

    implicit none

    class(sample_w2_to_sh_w2_test_type), intent(inout) :: this

    real(r_def), parameter ::  tol = 1.0e-12_r_def
    real(r_def), parameter ::   dx = 5.0_r_def
    real(r_def), parameter ::   dy = 4.0_r_def
    real(r_def), parameter ::   u0 = 7.0_r_def

    ! Fields
    real(r_def), allocatable :: u_sh_field(:)
    real(r_def), allocatable :: u_field(:)
    real(r_def), allocatable :: answer(:)
    real(r_def), allocatable :: area_w2(:)
    real(r_def), allocatable :: area_w2_sh(:)
    real(r_def), allocatable :: area_w2_dl(:)
    real(r_def), allocatable :: height_w3(:)
    real(r_def), allocatable :: height_wt(:)
    real(r_def), allocatable :: height_wt_sh(:)
    real(r_def), allocatable :: height_wt_dl(:)

    integer(i_def) :: cell, k
    real(r_def) :: dz

    ! Sizes
    integer(i_def) :: nlayers, nlayers_sh, ncells, nlayers_dl
    integer(i_def) :: ndf_w2_sh, ndf_wt_sh
    integer(i_def) :: ndf_w2, ndf_wt, ndf_w3, ndf_w2_dl
    integer(i_def) :: undf_w2_sh, undf_wt_sh
    integer(i_def) :: undf_w2, undf_wt, undf_w3, undf_w2_dl

    ! Dofmaps
    integer(i_def), allocatable :: map_w2(:,:), map_w2_sh(:,:), map_w2_dl(:,:)
    integer(i_def), allocatable :: map_w3(:,:)
    integer(i_def), allocatable :: map_wt(:,:), map_wt_sh(:,:)

    ! just consider a single column of three layers
    nlayers = 3
    nlayers_sh = 4
    nlayers_dl = 2 * nlayers
    ndf_w2 = 6
    undf_w2 = 16
    ndf_w2_sh = 6
    undf_w2_sh = 21
    ndf_w2_dl = 6
    undf_w2_dl = 31
    ndf_w3 = 1
    undf_w3 = 3
    ndf_wt = 2
    undf_wt = 4
    ndf_wt_sh = 1
    undf_wt_sh = 5
    ncells = 1
    cell = 1

    ! Create the data
    allocate( u_sh_field(undf_w2_sh) )
    allocate( u_field(undf_w2) )
    allocate( answer(undf_w2_sh) )
    allocate( area_w2_sh(undf_w2_sh) )
    allocate( area_w2_dl(undf_w2_dl) )
    allocate( area_w2(undf_w2) )
    allocate( height_w3(undf_w3) )
    allocate( height_wt(undf_wt) )
    allocate( height_wt_sh(undf_wt_sh) )
    allocate( height_wt_dl(undf_wt + undf_w3) )
    allocate( map_w2_sh(6, ncells) )
    allocate( map_w2_dl(6, ncells) )
    allocate( map_w2(6, ncells) )
    allocate( map_w3(1, ncells) )
    allocate( map_wt(2, ncells) )
    allocate( map_wt_sh(2, ncells) )

    ! Only one cell so all maps are to first cell
    map_w2_sh(:,:) = reshape( [1_i_def, 5_i_def, 9_i_def, &
                                        13_i_def, 17_i_def, 18_i_def], [6,1])
    map_wt_sh(:,:) = reshape( [1_i_def, 2_i_def], [2,1])
    map_w2(:,:)    = reshape( [1_i_def, 4_i_def, 7_i_def, &
                               10_i_def, 13_i_def, 14_i_def], [6,1])
    map_w2_dl(:,:) = reshape( [1_i_def, 7_i_def, 13_i_def, &
                               19_i_def, 25_i_def, 26_i_def], [6,1])
    map_w3(:,:)    = 1_i_def
    map_wt(:,:)    = reshape( [1_i_def, 2_i_def], [2,1])

    ! Set up the height fields for the meshes
    ! Let's consider a quadratic extrusion
    height_w3    = (/ 0.5_r_def, 2.5_r_def, 6.5_r_def /)
    height_wt    = (/ 0.0_r_def, 1.0_r_def, 4.0_r_def, 9.0_r_def /)
    height_wt_sh = (/ 0.0_r_def, 0.5_r_def, 2.5_r_def, 6.5_r_def, 9.0_r_def /)

    ! Get heights on double layer mesh
    height_wt_dl(1) = height_wt(1)
    do k = 1, nlayers
      height_wt_dl(2*k) = height_w3(k)
      height_wt_dl(2*k+1) = height_wt(k+1)
    end do

    ! Set up the areas on each of the meshes
    ! First in W2 on the original mesh
    do k = 1, nlayers
      dz = height_wt(map_wt(2, cell)+k-1) - height_wt(map_wt(1, cell)+k-1)
      area_w2(map_w2(W, cell)+k-1) = dy * dz
      area_w2(map_w2(E, cell)+k-1) = dy * dz
      area_w2(map_w2(N, cell)+k-1) = dx * dz
      area_w2(map_w2(S, cell)+k-1) = dx * dz
      area_w2(map_w2(B, cell)+k-1) = dx * dy
    end do

    area_w2(map_w2(T, cell)+nlayers-1) = dx * dy

    ! Set up double layer W2 field
    do k = 1, nlayers_dl
      dz = height_wt_dl(map_wt(2, cell)+k-1) - height_wt_dl(map_wt(1, cell)+k-1)
      area_w2_dl(map_w2_dl(W, cell)+k-1) = dy * dz
      area_w2_dl(map_w2_dl(E, cell)+k-1) = dy * dz
      area_w2_dl(map_w2_dl(N, cell)+k-1) = dx * dz
      area_w2_dl(map_w2_dl(S, cell)+k-1) = dx * dz
      area_w2_dl(map_w2_dl(B, cell)+k-1) = dx * dy
    end do

    area_w2_dl(map_w2_dl(T, cell)+nlayers_dl-1) = dx * dy

    ! Set up shifted W2 fields (including the answer)
    do k = 1, nlayers_sh
      dz = height_wt_sh(map_wt_sh(2, cell)+k-1) - height_wt_sh(map_wt_sh(1, cell)+k-1)
      area_w2_sh(map_w2_sh(B, cell)+k-1) = dx * dy
      area_w2_sh(map_w2_sh(E, cell)+k-1) = dy * dz
      area_w2_sh(map_w2_sh(S, cell)+k-1) = dx * dz
      area_w2_sh(map_w2_sh(N, cell)+k-1) = dx * dz
      area_w2_sh(map_w2_sh(W, cell)+k-1) = dy * dz
    end do

    area_w2_sh(map_w2_sh(T, cell)+nlayers_sh-1) = dx * dy

    ! Now set up initial field in W2 and the answer in shifted W2
    ! Assume a velocity that is constant in the horizontal
    ! Velocity varies linearly in the vertical
    u_field(:) = 0.0
    answer(:) = 0.0

    do k = 1, nlayers
      dz = height_wt(map_wt(2, cell)+k-1) - height_wt(map_wt(1, cell)+k-1)
      u_field(map_w2(W, cell)+k-1) = u0 * dy * dz
      u_field(map_w2(E, cell)+k-1) = u0 * dy * dz
      u_field(map_w2(N, cell)+k-1) = u0 * dx * dz
      u_field(map_w2(S, cell)+k-1) = u0 * dx * dz
      u_field(map_w2(B, cell)+k-1) = height_wt(map_w3(1, cell)+k-1) * dx * dy
    end do

    u_field(map_w2(T, cell)+nlayers-1) = height_wt(map_wt(2, cell)+nlayers-1) * dx * dy

    ! Set up shifted W2 fields (including the answer)
    do k = 1, nlayers_sh
      dz = height_wt_sh(map_wt_sh(2, cell)+k-1) - height_wt_sh(map_wt_sh(1, cell)+k-1)

      answer(map_w2_sh(W, cell)+k-1) = u0 * dy * dz
      answer(map_w2_sh(E, cell)+k-1) = u0 * dy * dz
      answer(map_w2_sh(N, cell)+k-1) = u0 * dx * dz
      answer(map_w2_sh(S, cell)+k-1) = u0 * dx * dz
      answer(map_w2_sh(B, cell)+k-1) = height_wt_sh(map_wt_sh(1, cell)+k-1) * dx * dy
    end do

    answer(map_w2_sh(T, cell)+nlayers_sh-1) = &
      height_wt_sh(map_wt_sh(2, cell)+nlayers_sh-1) * dx * dy

    ! Perform kernel
    call sample_w2_to_sh_w2_code( nlayers_sh,   &
                                  u_sh_field,   &
                                  u_field,      &
                                  area_w2_sh,   &
                                  area_w2,      &
                                  area_w2_dl,   &
                                  height_wt_sh, &
                                  height_wt,    &
                                  ndf_w2_sh,    &
                                  undf_w2_sh,   &
                                  map_w2_sh,    &
                                  ndf_w2,       &
                                  undf_w2,      &
                                  map_w2,       &
                                  ndf_w2_dl,    &
                                  undf_w2_dl,   &
                                  map_w2_dl,    &
                                  ndf_wt_sh,    &
                                  undf_wt_sh,   &
                                  map_wt_sh,    &
                                  ndf_wt,       &
                                  undf_wt,      &
                                  map_wt        &
                                )

    @assertEqual(answer(:), u_sh_field(:), tol)

    deallocate( u_sh_field )
    deallocate( u_field )
    deallocate( answer )
    deallocate( area_w2_sh )
    deallocate( area_w2 )
    deallocate( area_w2_dl )
    deallocate( height_w3 )
    deallocate( height_wt )
    deallocate( height_wt_sh )
    deallocate( map_w2_sh )
    deallocate( map_w2 )
    deallocate( map_w3 )
    deallocate( map_wt )
    deallocate( map_wt_sh )

  end subroutine test_all

end module sample_w2_to_sh_w2_kernel_mod_test
