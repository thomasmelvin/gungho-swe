!-----------------------------------------------------------------------------
! (c) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> Test the matrix_vector_shifted kernel

module matrix_vector_shifted_mod_test

  use constants_mod, only : r_def, i_def
  use pFUnit_Mod

  implicit none

  private

  public :: matrix_vector_shifted_kernel_test_type, test_all

  @TestCase
  type, extends(TestCase) :: matrix_vector_shifted_kernel_test_type
    private

  contains
    procedure setUp
    procedure tearDown
    procedure test_all

  end type matrix_vector_shifted_kernel_test_type

contains
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(matrix_vector_shifted_kernel_test_type), intent(inout) :: this

  end subroutine setUp
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod,        only: final_configuration

    implicit none

    class(matrix_vector_shifted_kernel_test_type), intent(inout) :: this

    call final_configuration()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  @Test
  subroutine test_all( this )

    use matrix_vector_shifted_kernel_mod, only : matrix_vector_shifted_code

    implicit none

    class(matrix_vector_shifted_kernel_test_type), intent(inout) :: this

    integer(kind=i_def) :: nlayers
    integer(kind=i_def) :: nlayers_sh
    integer(kind=i_def) :: ndf_orig
    integer(kind=i_def) :: undf_orig
    integer(kind=i_def) :: ndf_sh
    integer(kind=i_def) :: undf_sh
    integer(kind=i_def) :: cell
    integer(kind=i_def) :: ncells
    integer(kind=i_def) :: ncell_3d_L
    integer(kind=i_def) :: ncell_3d_U
    integer(kind=i_def) :: i

    integer(kind=i_def), allocatable :: map_orig(:,:)
    integer(kind=i_def), allocatable :: map_sh(:,:)

    real(kind=r_def), allocatable :: T_U(:,:,:)
    real(kind=r_def), allocatable :: T_L(:,:,:)
    real(kind=r_def), allocatable :: y_sh(:), answer(:)
    real(kind=r_def), allocatable :: x(:)
    real(kind=r_def) :: tol

    nlayers = 4
    nlayers_sh = nlayers + 1
    ndf_orig = 1
    undf_orig = 4
    ndf_sh = 1
    undf_sh = 5
    cell = 1
    ncells = 1
    ncell_3d_L = 4
    ncell_3d_U = 4

    allocate(map_orig(ndf_orig, ncells))
    allocate(map_sh(ndf_orig, ncells))
    allocate(T_U(ndf_sh, ndf_orig, ncell_3d_U))
    allocate(T_L(ndf_sh, ndf_orig, ncell_3d_L))
    allocate(y_sh(undf_sh))
    allocate(answer(undf_sh))
    allocate(x(undf_orig))

    map_orig = reshape([ 1_i_def ], [ndf_orig, ncells])
    map_sh = reshape([ 1_i_def ], [ndf_sh, ncells])

    ! We are going to compute y_sh[i] = T_L[i,j]*x[j] + T_U[i,j-1]*x[j-1]
    ! T_U and T_L represent values corresponding to lower and upper half levels

    ! Make up matrices
    T_U = reshape([ 1.0_r_def, 2.0_r_def, 3.0_r_def, 5.0_r_def], &
                  [ndf_sh, ndf_orig, ncell_3d_U])

    T_L = reshape([ 7.0_r_def, 4.0_r_def, 5.0_r_def, 1.0_r_def], &
                  [ndf_sh, ndf_orig, ncell_3d_L])

    ! rhs vector
    x(:) = (/ 0.25_r_def, 1.5_r_def, 1.0_r_def, 4.0_r_def /)

    ! lhs vector
    y_sh(:) = 0.0_r_def
    answer(:) = (/ 1.75_r_def, 6.25_r_def, 8.0_r_def, 7.0_r_def, 20.0_r_def /)

    call matrix_vector_shifted_code(                     &
                                      cell,              &
                                      nlayers_sh,        &
                                      y_sh,              &
                                      x,                 &
                                      ncell_3d_L,        &
                                      T_L,               &
                                      ncell_3d_U,        &
                                      T_U,               &
                                      ndf_sh,            &
                                      undf_sh,           &
                                      map_sh(:,cell),    &
                                      ndf_orig,          &
                                      undf_orig,         &
                                      map_orig(:,cell)   &
                                   )

    tol = 1.0e-14_r_def

    @assertEqual( answer(:), y_sh(:), tol )

    deallocate(map_orig)
    deallocate(map_sh)
    deallocate(T_U)
    deallocate(T_L)
    deallocate(answer)
    deallocate(y_sh)
    deallocate(x)

  end subroutine test_all

end module matrix_vector_shifted_mod_test
