!-----------------------------------------------------------------------------
! (C) Crown copyright 2022 Met Office. All rights reserved.
! For further details please refer to the file COPYRIGHT.txt
! which you should have received as part of this distribution.
!-----------------------------------------------------------------------------
!> Test for the masked restriction kernel
module restrict_masked_kernel_mod_test

  use pFUnit_mod
  use constants_mod,              only : i_def, r_def, rmdi
  use restrict_masked_kernel_mod, only : restrict_masked_kernel_code

  implicit none

  private
  public :: restrict_test_type, test_mask_one, test_mask_zero, test_mask_mixed

  @TestCase
  type, extends(TestCase) :: restrict_test_type
     private
     integer(kind=i_def) :: ncell_fine, undf_fine, undf_coarse
     integer(kind=i_def), allocatable, dimension(:,:) :: cell_map
     integer(kind=i_def), allocatable, dimension(:,:) :: map_fine
     integer(kind=i_def), allocatable, dimension(:)   :: map_coarse
     real(kind=r_def), allocatable, dimension(:) :: field_fine
     real(kind=r_def), allocatable, dimension(:) :: field_coarse
     real(kind=r_def), allocatable, dimension(:) :: mask_fine
   contains
     procedure setUp
     procedure tearDown
     procedure test_mask_one
     procedure test_mask_zero
     procedure test_mask_mixed
  end type restrict_test_type

     integer(kind=i_def), parameter :: nlayers = 3

     ! Number of fine cells per coarse cell in x-direction (for quad elements)
     integer(kind=i_def), parameter :: ncell_fine_per_coarse_x = 2

     ! Number of fine cells per coarse cell in y-direction (for quad elements)
     integer(kind=i_def), parameter :: ncell_fine_per_coarse_y = 2

     ! Number of dofs per cell (W3)
     integer(kind=i_def), parameter :: ndf = 1

     real(kind=r_def),    parameter :: tol = 1.0e-12_r_def

     ! The restrict_masked_kernel is NOT an incremental operator, so the output coarse
     ! does not depend on the input coarse value. The output value
     ! is output_coarse = average(mask_fine * input_fine).
     ! The input coarse field is specified as a field of an arbitrary number - rmdi.
     ! The input fine field is specified as a field of 2s.
     ! If mask=1 this gives an output field of 1 * 2 = 2
     ! If mask=0 this gives an output field of 0 * 2 = 0
     real(kind=r_def), parameter :: input_fine = 2.0_r_def
     real(kind=r_def), parameter :: input_coarse = rmdi
     real(kind=r_def), parameter :: answer_one = 2.0_r_def
     real(kind=r_def), parameter :: answer_zero = 0.0_r_def
contains

  subroutine setUp( this )

    implicit none
    class(restrict_test_type), intent(inout) :: this

    integer(kind=i_def) :: lp_x, lp_y, k

    ! Configure test as a single coarse column on W3 function space
    ! mapped to 4 fine columns in a 2x2 arrangement
    this%ncell_fine = ncell_fine_per_coarse_x * ncell_fine_per_coarse_y

    this%undf_fine = nlayers * this%ncell_fine * ndf

    this%undf_coarse = this%undf_fine / &
                       (ncell_fine_per_coarse_x * ncell_fine_per_coarse_y)

    allocate( this%cell_map(ncell_fine_per_coarse_x,  &
                            ncell_fine_per_coarse_y), &
              this%map_fine(ndf,this%ncell_fine),     &
              this%map_coarse(ndf) )
    allocate( this%field_coarse(this%undf_coarse),    &
              this%field_fine(this%undf_fine),        &
              this%mask_fine(this%undf_fine) )

    ! Construct coarse to fine cell id mappings based on x/y array index
    do lp_y = 1, ncell_fine_per_coarse_y
      do lp_x = 1, ncell_fine_per_coarse_x
       this%cell_map(lp_x, lp_y) = lp_x + (lp_y - 1)*ncell_fine_per_coarse_x
      end do
    end do
    do lp_x = 1, this%ncell_fine
      this%map_fine(1,lp_x) = 1 + (lp_x-1)*nlayers
    end do
    this%map_coarse(1) = 1

  end subroutine setUp

  subroutine tearDown( this )

    implicit none

    class(restrict_test_type), intent(inout) :: this

    deallocate( this%cell_map,     &
                this%map_fine,     &
                this%map_coarse,   &
                this%mask_fine,    &
                this%field_coarse, &
                this%field_fine )

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_mask_one( this )

    implicit none

    class(restrict_test_type), intent(inout) :: this
    integer(kind=i_def) :: k

    this%field_coarse(:) = input_coarse
    this%field_fine(:) = input_fine
    this%mask_fine(:) = 1.0_r_def

    call restrict_masked_kernel_code( nlayers,                 &
                                      this%cell_map,           &
                                      ncell_fine_per_coarse_x, &
                                      ncell_fine_per_coarse_y, &
                                      this%ncell_fine,         &
                                      this%field_coarse,       &
                                      this%field_fine,         &
                                      this%mask_fine,          &
                                      this%undf_coarse,        &
                                      this%map_coarse,         &
                                      ndf,                     &
                                      this%undf_fine,          &
                                      this%map_fine )

    do k = 1, nlayers
      @assertEqual( answer_one, this%field_coarse(k), tol)
    end do

  end subroutine test_mask_one

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_mask_zero( this )

    implicit none

    class(restrict_test_type), intent(inout) :: this
    integer(kind=i_def) :: k

    this%field_coarse(:) = input_coarse
    this%field_fine(:) = input_fine
    this%mask_fine(:) = 0.0_r_def

    call restrict_masked_kernel_code( nlayers,                 &
                                      this%cell_map,           &
                                      ncell_fine_per_coarse_x, &
                                      ncell_fine_per_coarse_y, &
                                      this%ncell_fine,         &
                                      this%field_coarse,       &
                                      this%field_fine,         &
                                      this%mask_fine,          &
                                      this%undf_coarse,        &
                                      this%map_coarse,         &
                                      ndf,                     &
                                      this%undf_fine,          &
                                      this%map_fine )

    do k = 1, nlayers
      @assertEqual( answer_zero, this%field_coarse(k), tol)
    end do

  end subroutine test_mask_zero

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_mask_mixed( this )

    implicit none

    class(restrict_test_type), intent(inout) :: this
    integer(kind=i_def) :: k, lp_y

    this%field_coarse(:) = input_coarse

    do k = 0, nlayers-1
      do lp_y = 1, ncell_fine_per_coarse_y
        this%mask_fine( this%map_fine(1,this%cell_map(1, lp_y)) + k ) = 1.0_r_def
        this%mask_fine( this%map_fine(1,this%cell_map(2, lp_y)) + k ) = 0.0_r_def
        this%field_fine( this%map_fine(1,this%cell_map(1, lp_y)) + k ) = input_fine
        this%field_fine( this%map_fine(1,this%cell_map(2, lp_y)) + k ) = rmdi
      end do
    end do

    call restrict_masked_kernel_code( nlayers,                 &
                                      this%cell_map,           &
                                      ncell_fine_per_coarse_x, &
                                      ncell_fine_per_coarse_y, &
                                      this%ncell_fine,         &
                                      this%field_coarse,       &
                                      this%field_fine,         &
                                      this%mask_fine,          &
                                      this%undf_coarse,        &
                                      this%map_coarse,         &
                                      ndf,                     &
                                      this%undf_fine,          &
                                      this%map_fine )

    do k = 1, nlayers
      @assertEqual( answer_one, this%field_coarse(k), tol)
    end do

  end subroutine test_mask_mixed

end module restrict_masked_kernel_mod_test
