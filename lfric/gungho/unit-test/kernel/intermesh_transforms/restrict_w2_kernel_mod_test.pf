!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! For further details please refer to the file COPYRIGHT.txt
! which you should have received as part of this distribution.
!-----------------------------------------------------------------------------
!> Test for the W2 restriction kernel
module restrict_w2_kernel_mod_test
  use pFUnit_mod
  use constants_mod, only : i_def, r_def

  implicit none
  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: restrict_w2_test_type
     private
   contains
     procedure :: test_all
  end type restrict_w2_test_type

contains

  @test
  subroutine test_all( this )
    use restrict_w2_kernel_mod, only : restrict_w2_kernel_code
    implicit none
    class(restrict_w2_test_type), intent(inout) :: this

    integer(kind=i_def) :: lp_x, lp_y, k, df, cell_f

    ! Scalars
    integer(kind=i_def) :: nlayers
    integer(kind=i_def) :: ncell_f_per_c_x ! number of fine cells per coarse in x
    integer(kind=i_def) :: ncell_f_per_c_y ! number of fine cells per coarse in y
    integer(kind=i_def) :: ncell_f         ! number of fine cells
    integer(kind=i_def) :: ndf_f           ! number of dofs per fine cell
    integer(kind=i_def) :: ndf_c           ! number of dofs per coarse cell
    integer(kind=i_def) :: undf_f, undf_c  ! unique number of dofs over whole field

    ! Integer Arrays
    integer(kind=i_def), allocatable, dimension(:,:) :: cell_map
    integer(kind=i_def), allocatable, dimension(:,:) :: map_f ! Cell and dof valued
    integer(kind=i_def), allocatable, dimension(:)   :: map_c ! only dof valued

    ! Real Arrays
    real(kind=r_def), allocatable, dimension(:) :: coarse_field, fine_field
    real(kind=r_def), allocatable, dimension(:) :: answer, rmultiplicity
    real(r_def), parameter :: tol = 1.0e-12_r_def

    ! set the scalars by hand
    nlayers = 3
    ncell_f_per_c_x = 2
    ncell_f_per_c_y = 3

    ncell_f = 1_i_def * ncell_f_per_c_x * ncell_f_per_c_y ! only need one coarse cell
    ndf_f = 6
    ndf_c = 6
    undf_c = 16
    undf_f = 75

    allocate( cell_map(ncell_f_per_c_x, ncell_f_per_c_y) )
    allocate( map_f(ndf_f, ncell_f) )
    allocate( map_c(ndf_c) )
    allocate( coarse_field(undf_c) )
    allocate( fine_field(undf_f) )
    allocate( rmultiplicity(undf_f) )
    allocate( answer(undf_c) )

    ! set simple values for cell map
    do lp_y = 1, ncell_f_per_c_y
      do lp_x = 1, ncell_f_per_c_x
       cell_map(lp_x, lp_y) = lp_x + (lp_y - 1)*ncell_f_per_c_x
      end do
    end do

    ! Make a W2 DoF map for 2*3*3 cells
    map_f = reshape( (/  1,  4,  7, 10, 13, 14, &
                         7, 17, 20, 23, 26, 27, &
                        30, 33, 36,  4, 39, 40, &
                        36, 43, 46, 17, 49, 50, &
                        53, 56, 59, 33, 62, 63, &
                        59, 66, 69, 43, 72, 73  &
                      /), (/ ndf_f, ncell_f /) )

    ! DoF map for single coarse cell
    map_c = (/ 1, 4, 7, 10, 13, 14 /)

    rmultiplicity(:) = 0.0_r_def
    answer(:) = 0.0_r_def
    coarse_field(:) = 0.0_r_def

    ! Set values of the fields and rmultiplicity
    do k = 0, nlayers - 1
      do lp_x = 1, ncell_f_per_c_x
        do lp_y = 1, ncell_f_per_c_y
          ! work out fine cell ID
          cell_f = lp_x + ncell_f_per_c_x * (lp_y - 1)

          ! Strategy is to set specific values on the edges of the coarse cell
          ! but notably different values internal to the the coarse cell

          ! West values (dof 1) and east values (dof 3)
          if ( lp_x == 1 ) then
            ! The coarse answer corresponding to this will be (6 + 3*k)
            fine_field(map_f(1,cell_f)+k) = real(lp_y + k, r_def)

            ! Weight for W2 field should just be 1 or 0.5 for a shared DoF
            rmultiplicity(map_f(1,cell_f)+k) = 1.0_r_def

          else if ( lp_x == ncell_f_per_c_x ) then
            ! The coarse answer corresponding to this will be (9 + 3*k)
            fine_field(map_f(3,cell_f)+k) = real(lp_y + k + 1, r_def)

            ! Weight for W2 field should just be 1 or 0.5 for a shared DoF
            rmultiplicity(map_f(3,cell_f)+k) = 1.0_r_def

          else
            ! Pick a random large negative number
            fine_field(map_f(1, cell_f)+k) = -100.0_r_def
            fine_field(map_f(3, cell_f)+k) = -100.0_r_def
          end if

          ! North values (dof 4) and south values (dof 2)
          if ( lp_y == 1 ) then
            ! The coarse answer corresponding to this will be (3 + 2*k)
            fine_field(map_f(4,cell_f)+k) = real(lp_x + k, r_def)

            ! Weight for W2 field should just be 1 or 0.5 for a shared DoF
            rmultiplicity(map_f(4,cell_f)+k) = 1.0_r_def

          else if ( lp_y == ncell_f_per_c_y ) then
            ! The coarse answer corresponding to this will be (5 + 2*k)
            fine_field(map_f(2,cell_f)+k) = real(lp_x + k + 1, r_def)

            ! Weight for W2 field should just be 1 or 0.5 for a shared DoF
            rmultiplicity(map_f(2,cell_f)+k) = 1.0_r_def

          else
            ! Pick a random large negative number
            fine_field(map_f(4, cell_f)+k) = -100.0_r_def
            fine_field(map_f(2, cell_f)+k) = -100.0_r_def
          end if

          ! Vertical components
          ! Total coarse answer will be (12 + 6*k)
          fine_field(map_f(5, cell_f)+k) = real(lp_y + k, r_def)
          rmultiplicity(map_f(5, cell_f)+k) = 1.0_r_def

          ! Top layer
          if ( k == nlayers - 1 ) then
            ! Total coarse answer should be 21
            fine_field(map_f(6, cell_f)+k) = real(lp_x + k, r_def)
            rmultiplicity(map_f(6, cell_f)+k) = 1.0_r_def
          end if

        end do
      end do
    end do

    ! Fill coarse answer field using values from above
    do k = 0, nlayers - 1
      answer(map_c(1)+k) = real(6 + 3*k, r_def)
      answer(map_c(2)+k) = real(5 + 2*k, r_def)
      answer(map_c(3)+k) = real(9 + 3*k, r_def)
      answer(map_c(4)+k) = real(3 + 2*k, r_def)
      answer(map_c(5)+k) = real(12 + 6*k, r_def)

      if ( k == nlayers - 1 ) then
        answer(map_c(6)+k) = real(9 + 6*k, r_def)
      end if
    end do

    call restrict_w2_kernel_code( nlayers,         &
                                  cell_map,        &
                                  ncell_f_per_c_x, &
                                  ncell_f_per_c_y, &
                                  ncell_f,         &
                                  coarse_field,    &
                                  fine_field,      &
                                  rmultiplicity,   &
                                  undf_c,          &
                                  map_c,           &
                                  ndf_f,           &
                                  undf_f,          &
                                  map_f            )

    ! Check answer for all DoFs
    do df = 1, undf_c
      @assertEqual( coarse_field(df), answer(df), tol )
    end do

    deallocate( cell_map,      &
                map_f,         &
                map_c,         &
                rmultiplicity, &
                answer,        &
                coarse_field,  &
                fine_field     )

  end subroutine test_all

end module restrict_w2_kernel_mod_test
