!-----------------------------------------------------------------------------
! (C) Crown copyright 2018 Met Office. All rights reserved.
! For further details please refer to the file COPYRIGHT.txt
! which you should have received as part of this distribution.
!-----------------------------------------------------------------------------

!> Test the curl computation
!>
module strong_curl_kernel_mod_test

  use constants_mod, only : i_def, r_def
  use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: strong_curl_test_type
    private
  contains
    procedure test_all
  end type strong_curl_test_type

contains

  @test
  subroutine test_all( this )

    use strong_curl_kernel_mod, only : strong_curl_code

    implicit none

    class(strong_curl_test_type), intent(inout) :: this

    real(kind=r_def), parameter       :: tol = 1.0e-9_r_def
    real(kind=r_def), dimension(6,12) :: d21
    real(kind=r_def), dimension(6)    :: answer

    ! Mesh
    integer(kind=i_def), parameter :: nlayers = 1

    ! W2 Space
    integer(kind=i_def), parameter              :: ndf2  = 6_i_def
    integer(kind=i_def), parameter              :: undf2 = 6_i_def
    integer(kind=i_def), dimension(ndf2)        :: map2
    real(kind=r_def),    dimension(3,ndf2,ndf2) :: basis_2
    real(kind=r_def),    dimension(undf2)       :: xi
    real(kind=r_def),    dimension(ndf2)        :: x, y, z
    ! W1 Space
    integer(kind=i_def), parameter              :: ndf1  = 12_i_def
    integer(kind=i_def), parameter              :: undf1 = 12_i_def
    integer(kind=i_def), dimension(ndf1)        :: map1
    real(kind=r_def),    dimension(3,ndf1,ndf2) :: diff_basis_1
    real(kind=r_def),    dimension(undf1)       :: u

    integer(kind=i_def) :: i


    d21 = real(reshape( [ &
     1,  0,  0,  0, -1,  0, &
     0,  1,  0,  0,  1,  0, &
     0,  0,  1,  0,  1,  0, &
     0,  0,  0,  1, -1,  0, &
    -1, -1,  0,  0,  0,  0, &
     0,  1, -1,  0,  0,  0, &
     0,  0,  1,  1,  0,  0, &
     1,  0,  0, -1,  0,  0, &
    -1,  0,  0,  0,  0, -1, &
     0, -1,  0,  0,  0,  1, &
     0,  0, -1,  0,  0,  1, &
     0,  0,  0, -1,  0, -1  &
    ], shape(d21) ),r_def)

    do i = 1,ndf1
      map1(i) = i
    end do
    do i = 1,ndf2
      map2(i) = i
    end do

     basis_2(:,:,:) = 0.0_r_def
     basis_2(1,1,1) =  1.0_r_def
     basis_2(2,2,2) = -1.0_r_def
     basis_2(1,3,3) =  1.0_r_def
     basis_2(2,4,4) = -1.0_r_def
     basis_2(3,5,5) =  1.0_r_def
     basis_2(3,6,6) =  1.0_r_def

     x(:) = (/ 0.0_r_def, 0.5_r_def, 1.0_r_def, 0.5_r_def, 0.5_r_def, 0.5_r_def /)
     y(:) = (/ 0.5_r_def, 0.0_r_def, 0.5_r_def, 1.0_r_def, 0.5_r_def, 0.5_r_def /)
     z(:) = (/ 0.5_r_def, 0.5_r_def, 0.5_r_def, 0.5_r_def, 0.0_r_def, 1.0_r_def /)
     u(:) = (/ 1.0_r_def,-1.2_r_def,-0.5_r_def,-3.0_r_def, 4.0_r_def,-3.2_r_def, &
               1.0_r_def,-1.2_r_def,-0.5_r_def,-3.0_r_def, 4.0_r_def,-3.2_r_def /)

     diff_basis_1(:,:,:) = 0.0_r_def
     do i = 1,ndf2
       diff_basis_1(:,1, i) = (/ 1.0_r_def-x(i), 0.0_r_def,     -1.0_r_def+z(i) /)
       diff_basis_1(:,2, i) = (/ 0.0_r_def,     -1.0_r_def+y(i), 1.0_r_def-z(i) /)
       diff_basis_1(:,3, i) = (/           x(i), 0.0_r_def,      1.0_r_def-z(i) /)
       diff_basis_1(:,4, i) = (/ 0.0_r_def,               -y(i),-1.0_r_def+z(i) /)
       diff_basis_1(:,5, i) = (/-1.0_r_def+x(i), 1.0_r_def-y(i), 0.0_r_def      /)
       diff_basis_1(:,6, i) = (/          -x(i),-1.0_r_def+y(i), 0.0_r_def      /)
       diff_basis_1(:,7, i) = (/           x(i),          -y(i), 0.0_r_def      /)
       diff_basis_1(:,8, i) = (/ 1.0_r_def-x(i),           y(i), 0.0_r_def      /)
       diff_basis_1(:,9, i) = (/-1.0_r_def+x(i), 0.0_r_def,               -z(i) /)
       diff_basis_1(:,10,i) = (/ 0.0_r_def,      1.0_r_def-y(i),           z(i) /)
       diff_basis_1(:,11,i) = (/          -x(i), 0.0_r_def,                z(i) /)
       diff_basis_1(:,12,i) = (/ 0.0_r_def,                y(i),          -z(i) /)
     end do

     xi = 0.0_r_def


     call strong_curl_code(nlayers,                         &
                           xi, u,                           &
                           ndf2, undf2, map2, basis_2,      &
                           ndf1, undf1, map1, diff_basis_1  &
                           )

    answer = matmul(d21,u)
    @assertEqual(answer,xi,tol)

  end subroutine test_all

end module strong_curl_kernel_mod_test
