!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the get height kernel. Sets up a planar domain with quadratic height
!> extrusion, and tests answer in W3 and Wtheta spaces
!>
module get_height_kernel_mod_test

    use constants_mod,                       only : i_def, r_def
    use pFUnit_Mod
    use get_unit_test_m3x3_q3x3x3_sizes_mod, only : get_w0_m3x3_q3x3x3_size,  &
                                                    get_w3_m3x3_q3x3x3_size, &
                                                    get_wtheta_m3x3_q3x3x3_size
    use get_unit_test_m3x3_dofmap_mod,       only : get_w0_m3x3_dofmap, &
                                                    get_w3_m3x3_dofmap, &
                                                    get_wtheta_m3x3_dofmap
    use get_unit_test_3x3x3_chi_mod,         only : get_w0_3x3x3_field
    use get_unit_test_w3nodal_basis_mod,     only : get_w0_w3nodal_basis
    use get_unit_test_wthetanodal_basis_mod, only : get_w0_wthetanodal_basis
  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: get_height_kernel_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type get_height_kernel_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use base_mesh_config_mod,      only : geometry_planar, &
                                          topology_fully_periodic
    use finite_element_config_mod, only : cellshape_quadrilateral, &
                                          coord_system_xyz
    use feign_config_mod,          only : feign_finite_element_config, &
                                          feign_base_mesh_config

    implicit none

    class(get_height_kernel_test_type), intent(inout) :: this

    call feign_base_mesh_config( filename='foo',                   &
                                 prime_mesh_name='unit_test',      &
                                 geometry=geometry_planar,         &
                                 offline_partitioning=.false.,     &
                                 topology=topology_fully_periodic, &
                                 fplane=.false., f_lat_deg=45.0_r_def )

    call feign_finite_element_config(           &
             cellshape=cellshape_quadrilateral, &
             coord_order=0_i_def,               &
             coord_system=coord_system_xyz,     &
             element_order=0_i_def,             &
             rehabilitate=.true.,               &
             vorticity_in_w1=.false. )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod,        only: final_configuration

    implicit none

    class(get_height_kernel_test_type), intent(inout) :: this

    call final_configuration()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( this )

    use get_height_kernel_mod, only : get_height_code

    implicit none

    class(get_height_kernel_test_type), intent(inout) :: this

    real(r_def), parameter :: dx     = 4.0_r_def, &
                              dy     = 3.0_r_def, &
                              dz     = 2.0_r_def, &
                              radius = 0.0_r_def

    real(r_def), parameter :: tol    = 1.0e-6_r_def

    integer(i_def) :: i, j, k, df_w3, df_wtheta

    integer(i_def) :: nlayers, cell
    integer(i_def) :: ndf_w0, undf_w0, ndf_w3, undf_w3, ndf_wtheta, undf_wtheta
    integer(i_def) :: unused

    integer(i_def), allocatable :: map_w0(:,:)
    integer(i_def), allocatable :: map_w3(:,:)
    integer(i_def), allocatable :: map_wtheta(:,:)

    real(r_def),    allocatable :: basis_w0_on_w3(:,:,:)
    real(r_def),    allocatable :: basis_w0_on_wtheta(:,:,:)

    real(r_def),    allocatable :: chi_1(:), chi_2(:), chi_3(:)

    real(r_def),    allocatable :: height_w3(:)
    real(r_def),    allocatable :: height_wtheta(:)
    real(r_def),    allocatable :: height_w3_answer(:)
    real(r_def),    allocatable :: height_wtheta_answer(:)

    ! Set number of layers
    nlayers = 3

    ! Set up degrees of freedom information
    call get_w0_m3x3_q3x3x3_size( ndf_w0, undf_w0, unused, &
                                  unused, unused, &
                                  unused, unused, &
                                  nlayers )
    call get_w3_m3x3_q3x3x3_size( ndf_w3, undf_w3, unused, &
                                  unused, unused, &
                                  unused, unused, &
                                  nlayers )
    call get_wtheta_m3x3_q3x3x3_size( ndf_wtheta, undf_wtheta, unused, &
                                      unused, unused, &
                                      unused, unused, &
                                      nlayers )

    ! Set up dof maps
    call get_w0_m3x3_dofmap(map_w0)
    call get_w3_m3x3_dofmap(map_w3)
    call get_wtheta_m3x3_dofmap(map_wtheta)

    ! chi basis on W3 and Wtheta
    call get_w0_w3nodal_basis(basis_w0_on_w3)
    call get_w0_wthetanodal_basis(basis_w0_on_wtheta)

    ! Set up chi coefficients with quadratic extrusion
    allocate( chi_1(undf_w0) )
    allocate( chi_2(undf_w0) )
    allocate( chi_3(undf_w0) )

    cell = 1
     do j = 1,3
       do i = 1,3
         do k = 0,nlayers
           chi_1(map_w0(1,cell)+k) = real(i-1)*dx
           chi_2(map_w0(1,cell)+k) = real(j-1)*dy
           chi_3(map_w0(1,cell)+k) = (real(k)**2)*dz
         end do
         cell = cell + 1
       end do
     end do

    ! Allocate W3 and Wtheta height arrays
    allocate( height_w3(undf_w3) )
    allocate( height_w3_answer(undf_w3) )
    allocate( height_wtheta(undf_wtheta) )
    allocate( height_wtheta_answer(undf_wtheta) )

    ! Test the operator kernel
    cell = 1
    ! Create data for W3 and Wtheta
    height_w3(:) = 0.0_r_def
    height_wtheta(:) = 0.0_r_def

    call get_height_code(nlayers,                            &
                         height_w3,                          &
                         chi_1, chi_2, chi_3,                &
                         radius,                             &
                         ndf_w3, undf_w3, map_w3(:,cell),    &
                         ndf_w0, undf_w0, map_w0(:,cell),    &
                         basis_w0_on_w3(:,:,:) )

    call get_height_code(nlayers,                                     &
                         height_wtheta,                               &
                         chi_1, chi_2, chi_3,                         &
                         radius,                                      &
                         ndf_wtheta, undf_wtheta, map_wtheta(:,cell), &
                         ndf_w0, undf_w0, map_w0(:,cell),             &
                         basis_w0_on_wtheta(:,:,:) )

    ! Create answers in first column
    cell = 1
    df_wtheta = 1
    df_w3 = 1

    ! Height at Wtheta DoFs
    do k = 0, nlayers-1
      height_wtheta_answer(map_wtheta(df_wtheta,cell)+k) = (real(k)**2)*dz
    end do

    ! Set top value
    k = nlayers-1
    height_wtheta_answer(map_wtheta(2,cell)+ k) = (real(k+1)**2)*dz

    ! Height at W3 DoFs
    df_w3 = 1
    do k = 0, nlayers-1
      height_w3_answer(map_w3(df_w3,cell)+k)=0.5_r_def*dz*(real(k)**2 + real(k+1)**2)
    end do

    ! Test the answer for k = 1, df_wtheta = 1 and df_w3 = 1
    do k = 1, nlayers-1
      @assertEqual(height_w3_answer(map_w3(df_w3,cell)+k), height_w3(map_w3(df_w3,cell)+k), tol)
      @assertEqual(height_wtheta_answer(map_wtheta(df_wtheta,cell)+k), height_wtheta(map_wtheta(df_wtheta,cell)+k), tol)
    end do

  end subroutine test_all

end module get_height_kernel_mod_test
