!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!> Test the rrho computation
!>
module rrho_kernel_mod_test

  use constants_mod,                 only : i_def, r_def

  use get_unit_test_m3x3_q3x3x3_sizes_mod, only : get_w2_m3x3_q3x3x3_size, &
                                                  get_w3_m3x3_q3x3x3_size

  use get_unit_test_m3x3_dofmap_mod,       only : get_w2_m3x3_dofmap,     &
                                                  get_w3_m3x3_dofmap

  use get_unit_test_q3x3x3_quadrature_mod, &
     only : get_gaussian_q3x3x3_quadrature_weights_xy, &
            get_gaussian_q3x3x3_quadrature_weights_z

  use get_unit_test_q3x3x3_basis_mod, only: get_w2_q3x3x3_diff_basis,  &
                                            get_w3_q3x3x3_basis

 use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: rrho_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type rrho_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(rrho_test_type), intent(inout) :: this

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(rrho_test_type), intent(inout) :: this

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( this )

    use rrho_kernel_mod, only : rrho_code

    implicit none

    class(rrho_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-6_r_def

    ! Fields
    real(r_def), allocatable :: r_rho(:)
    real(r_def), allocatable :: u_field(:)
    real(r_def), allocatable :: answer(:)

    integer(i_def) :: cell

    ! Sizes
    integer(i_def)      :: nlayers, ncells, nqp_v, nqp_h
    integer(i_def)      :: ndf_w2, ndf_w3
    integer(i_def)      :: undf_w2, undf_w3
    integer(i_def)      :: dim_space, dim_space_diff

    ! Dofmaps
    integer(i_def), allocatable :: map_w2(:,:)
    integer(i_def), allocatable :: map_w3(:,:)

   ! Basis functions
    real(r_def),    allocatable :: diff_basis_w2(:,:,:,:)
    real(r_def),    allocatable :: basis_w3(:,:,:,:)

    ! Weights
    real(r_def),    allocatable :: wh(:)
    real(r_def),    allocatable :: wv(:)

    nlayers = 3
    call get_w2_m3x3_q3x3x3_size( ndf_w2, undf_w2, ncells,   &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v,              &
                                  nlayers )
    call get_w3_m3x3_q3x3x3_size( ndf_w3, undf_w3, ncells,   &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v,              &
                                  nlayers )

    call get_w2_m3x3_dofmap(map_w2)
    call get_w3_m3x3_dofmap(map_w3)

    call get_gaussian_q3x3x3_quadrature_weights_xy( wh )
    call get_gaussian_q3x3x3_quadrature_weights_z( wv )

    ! Get canned basis functions
    call get_w2_q3x3x3_diff_basis(diff_basis_w2)
    call get_w3_q3x3x3_basis(basis_w3)

    ! Create the data
    allocate( u_field( undf_w2 ) )
    allocate( r_rho( undf_w3 ) )
    allocate( answer( undf_w3 ) )
    u_field(:) = 2.0_r_def
    r_rho(:)   = 0.0_r_def

    do cell = 1, ncells

       call rrho_code( nlayers,         &
                       r_rho,           &
                       u_field,         &
                       ndf_w3,          &
                       undf_w3,         &
                       map_w3(:, cell), &
                       basis_w3,        &
                       ndf_w2,          &
                       undf_w2,         &
                       map_w2(:, cell), &
                       diff_basis_w2,   &
                       nqp_h,           &
                       nqp_v,           &
                       wh,              &
                       wv               &
                       )
    end do

    ! Simple test, check when u = const, div(u) = 0
    answer(:) = 0.0_r_def
    @assertEqual(answer(:), r_rho(:), tol)

    deallocate( r_rho )
    deallocate( u_field )
    deallocate( answer )
    deallocate( map_w2 )
    deallocate( map_w3 )
    deallocate( diff_basis_w2 )
    deallocate( basis_w3 )
    deallocate( wv )
    deallocate( wh )

  end subroutine test_all

end module rrho_kernel_mod_test
