!-----------------------------------------------------------------------------
! (C) Crown copyright 2018 Met Office. All rights reserved.
! For further details please refer to the file COPYRIGHT.txt
! which you should have received as part of this distribution.
!-----------------------------------------------------------------------------

!> Test the galerkin projection between W2 and W1 spaces

module w2_to_w1_projection_kernel_mod_test

  use constants_mod, only : i_def, r_def
  use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: w2_to_w1_projection_test_type
    private
  contains
    procedure test_all
  end type w2_to_w1_projection_test_type

contains

  @test
  subroutine test_all( this )

    use w2_to_w1_projection_kernel_mod, only : w2_to_w1_projection_code

    implicit none

    class(w2_to_w1_projection_test_type), intent(inout) :: this

    real(kind=r_def), parameter       :: tol = 1.0e-9_r_def
    real(kind=r_def)                  :: answer

    ! Mesh
    integer(kind=i_def), parameter :: nlayers = 1

    ! W2 Space
    integer(kind=i_def), parameter              :: ndf2  = 6_i_def
    integer(kind=i_def), parameter              :: undf2 = 6_i_def
    integer(kind=i_def), dimension(ndf2)        :: map2
    real(kind=r_def),    dimension(3,ndf2)      :: basis_2
    real(kind=r_def),    dimension(undf2)       :: u
    ! W1 Space
    integer(kind=i_def), parameter              :: ndf1  = 12_i_def
    integer(kind=i_def), parameter              :: undf1 = 12_i_def
    integer(kind=i_def), dimension(ndf1)        :: map1
    real(kind=r_def),    dimension(3,ndf1)      :: basis_1
    real(kind=r_def),    dimension(undf1)       :: v
    ! Quadrature
    integer(kind=i_def), parameter              :: nqp = 1_i_def
    real(kind=r_def),    dimension(1)           :: wt

    integer(kind=i_def) :: i


    do i = 1,ndf1
      map1(i) = i
    end do
    do i = 1,ndf2
      map2(i) = i
    end do

     basis_2(:,:) = 0.0_r_def
     basis_2(1,1) =  0.5_r_def
     basis_2(2,2) = -0.5_r_def
     basis_2(1,3) =  0.5_r_def
     basis_2(2,4) = -0.5_r_def
     basis_2(3,5) =  0.5_r_def
     basis_2(3,6) =  0.5_r_def

     u(:) = (/ 1.0_r_def,-1.2_r_def,-0.5_r_def,-3.0_r_def, 4.0_r_def,-3.2_r_def /)
     v(:) = 0.0_r_def

     basis_1(:,:) = 0.0_r_def
     basis_1(2,1)  =  0.25_r_def
     basis_1(1,2)  =  0.25_r_def
     basis_1(2,3)  =  0.25_r_def
     basis_1(1,4)  =  0.25_r_def
     basis_1(3,5)  =  0.25_r_def
     basis_1(3,6)  =  0.25_r_def
     basis_1(3,7)  =  0.25_r_def
     basis_1(3,8)  =  0.25_r_def
     basis_1(2,9)  =  0.25_r_def
     basis_1(1,10) =  0.25_r_def
     basis_1(2,11) =  0.25_r_def
     basis_1(1,12) =  0.25_r_def

     wt(1) = 1.0_r_def


     call w2_to_w1_projection_code(nlayers,                    &
                                   v, u,                       &
                                   ndf1, undf1, map1, basis_1, &
                                   ndf2, undf2, map2, basis_2, &
                                   nqp, nqp, wt, wt  &
                                  )

    answer = 0.125_r_def*(u(1)+u(3))
    @assertEqual(answer,v(2), tol)
    @assertEqual(answer,v(4), tol)
    @assertEqual(answer,v(10),tol)
    @assertEqual(answer,v(12),tol)
    answer = -0.125_r_def*(u(2)+u(4))
    @assertEqual(answer,v(1), tol)
    @assertEqual(answer,v(3), tol)
    @assertEqual(answer,v(9), tol)
    @assertEqual(answer,v(11),tol)
    answer = 0.125_r_def*(u(5)+u(6))
    @assertEqual(answer,v(5), tol)
    @assertEqual(answer,v(6), tol)
    @assertEqual(answer,v(7), tol)
    @assertEqual(answer,v(8), tol)

  end subroutine test_all

end module w2_to_w1_projection_kernel_mod_test
