!-----------------------------------------------------------------------------
! (c) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> Test the kernel for translating flux through bottom into mass
!>
module compute_bottom_mass_from_flux_kernel_mod_test

  use constants_mod,                       only : i_def, r_def, r_second
  use get_unit_test_m3x3_q3x3x3_sizes_mod, only : get_w3_m3x3_q3x3x3_size, &
                                                  get_w2_m3x3_q3x3x3_size, &
                                                  get_w0_m3x3_q3x3x3_size
  use get_unit_test_m3x3_dofmap_mod,       only : get_w3_m3x3_dofmap,      &
                                                  get_w2_m3x3_dofmap,      &
                                                  get_w0_m3x3_dofmap
  use get_unit_test_q3x3x3_basis_mod,      only : get_w0_q3x3x3_diff_basis
  use calc_dA_at_w2_kernel_mod,            only : calc_dA_at_w2_code
  use pFUnit_Mod

  implicit none

  private

  public :: compute_bottom_mass_from_flux_kernel_test_type, test_all

  @TestCase
  type, extends(TestCase) :: compute_bottom_mass_from_flux_kernel_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type compute_bottom_mass_from_flux_kernel_test_type

  real(kind=r_def), parameter    :: dt = 7.0_r_def

contains
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use feign_config_mod,          only : feign_timestepping_config
    use timestepping_config_mod,   only : method_semi_implicit, &
                                          runge_kutta_method_ssp3
    implicit none

    class(compute_bottom_mass_from_flux_kernel_test_type), intent(inout) :: this

    call feign_timestepping_config(                                   &
             method=method_semi_implicit,                             &
             dt=real(dt, r_second), alpha=0.5_r_def, tau_u=0.5_r_def, &
             tau_t=0.5_r_def, tau_r=0.5_r_def,                        &
             outer_iterations=1_i_def, inner_iterations=1_i_def,      &
             runge_kutta_method=runge_kutta_method_ssp3,              &
             spinup_period=0.0_r_second, spinup_alpha=.false.,        &
             spinup_winds=.false.)

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod,        only: final_configuration

    implicit none

    class(compute_bottom_mass_from_flux_kernel_test_type), intent(inout) :: this

    call final_configuration()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( this)

    use compute_bottom_mass_from_flux_kernel_mod, only : compute_bottom_mass_from_flux_code

    implicit none

    class(compute_bottom_mass_from_flux_kernel_test_type), intent(inout) :: this

    real(kind=r_def), parameter      :: tol = 1.0e-16_r_def
    real(kind=r_def), parameter      :: dx  = 4.0_r_def
    real(kind=r_def), parameter      :: dy  = 7.0_r_def
    real(kind=r_def), parameter      :: dz  = 13.0_r_def
    real(kind=r_def)                 :: answer
    integer(kind=i_def)              :: nlayers, ncells
    integer(kind=i_def)              :: ndf_w3, undf_w3, ndf_w2
    integer(kind=i_def)              :: undf_w2, ndf_w0, undf_w0
    integer(kind=i_def)              :: dim_space, dim_space_diff
    integer(kind=i_def)              :: nqp_h, nqp_v
    integer(kind=i_def), allocatable :: map_w3(:,:)
    integer(kind=i_def), allocatable :: map_w2(:,:)
    integer(kind=i_def), allocatable :: map_w0(:,:)
    real(kind=r_def), allocatable    :: mass(:)
    real(kind=r_def), allocatable    :: flux(:)
    real(kind=r_def), allocatable    :: area(:)
    real(kind=r_def), allocatable    :: chi1(:), chi2(:), chi3(:)

    ! Basis function
    real(kind=r_def), allocatable    :: diff_basis_w0(:,:,:,:)
    integer(kind=i_def)              :: i, j, k, cell

    ! Make canned data
    nlayers=3
    call get_w3_m3x3_q3x3x3_size( ndf_w3, undf_w3, ncells,   &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v,              &
                                  nlayers )
    call get_w3_m3x3_dofmap(map_w3)
    call get_w2_m3x3_q3x3x3_size( ndf_w2, undf_w2, ncells,   &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v,              &
                                  nlayers )
    call get_w2_m3x3_dofmap(map_w2)
    call get_w0_m3x3_q3x3x3_size( ndf_w0, undf_w0, ncells,   &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v,              &
                                  nlayers )
    call get_w0_m3x3_dofmap(map_w0)
    call get_w0_q3x3x3_diff_basis(diff_basis_w0)

    ! Compute coordinates
    allocate(chi1(undf_w0))
    allocate(chi2(undf_w0))
    allocate(chi3(undf_w0))
    allocate(area(undf_w2))

    cell = 1
    do j = 1,3
      do i = 1,3
        do k = 0,3
          chi1(map_w0( 1 ,cell ) + k) = real(i-1,r_def) * dx
          chi2(map_w0( 1, cell ) + k) = real(j-1,r_def) * dy
          chi3(map_w0( 1, cell ) + k) = real(k,r_def)   * dz

          ! We only need to assign the bottom areas for this kernel
          area(map_w2( 5, cell ) + k) = dx * dy
        end do
        cell = cell + 1
      end do
    end do

    ! Obtain the area data

    cell = 1
    area(5) = dx * dy

    ! Allocate variables, with mass initially wrong
    allocate(mass(undf_w3))
    allocate(flux(undf_w3))

    mass(:) = 0.0_r_def
    flux(:) = 2.0_r_def

    ! Now call the code to compute mass from the flux
    call compute_bottom_mass_from_flux_code(                         &
                                            nlayers,                 &
                                            mass,                    &
                                            flux,                    &
                                            area, dt,                &
                                            ndf_w3, undf_w3, map_w3, &
                                            ndf_w2, undf_w2, map_w2  &
                                            )

    answer = flux(1) * dx * dy * dt
    @assertEqual(answer, mass(map_w3(1, cell)), tol)

    deallocate(map_w3)
    deallocate(map_w0)
    deallocate(map_w2)
    deallocate(mass)
    deallocate(flux)
    deallocate(area)
    deallocate(chi1)
    deallocate(chi2)
    deallocate(chi3)
    deallocate(diff_basis_w0)

  end subroutine test_all

end module compute_bottom_mass_from_flux_kernel_mod_test
