!-----------------------------------------------------------------------------
! (C) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the calculation of flux through a vertical cell edge for Cosmic
!> transport.

module ffsl_vertical_flux_kernel_mod_test

  use constants_mod,      only : i_def, r_def
  use pFUnit_Mod

  implicit none

  private
  public :: ffsl_vertical_flux_test_type,         &
            test_positive_flux_small_cfl,         &
            test_positive_flux_large_cfl,         &
            test_negative_flux_small_cfl,         &
            test_negative_flux_large_cfl

  @TestCase
  type, extends(TestCase) :: ffsl_vertical_flux_test_type
    private
    real(kind=r_def), allocatable :: dep_pts(:), flux(:), rho(:)
    real(kind=r_def), allocatable :: a0_coeffs(:), a1_coeffs(:), a2_coeffs(:)

    integer(i_def) :: map_w2(1:6)
  contains
    procedure setUp
    procedure tearDown
    procedure test_positive_flux_small_cfl
  end type ffsl_vertical_flux_test_type

    integer(i_def), parameter :: nlayers = 5
    integer(i_def), parameter :: ndf_w2  = 6
    integer(i_def), parameter :: undf_w2 = nlayers*4+nlayers+1
    integer(i_def), parameter :: ndf_w3  = 1
    integer(i_def), parameter :: undf_w3 = nlayers

    real(r_def),    parameter :: deltaT  = 1.0_r_def

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(ffsl_vertical_flux_test_type), intent(inout) :: this

    this%map_w2 = (/ 1,6,11,16,21,22 /)

    allocate( this%dep_pts(1:undf_w2) )
    allocate( this%flux(1:undf_w2) )
    allocate( this%rho(1:undf_w3) )
    allocate( this%a0_coeffs(1:undf_w3) )
    allocate( this%a1_coeffs(1:undf_w3) )
    allocate( this%a2_coeffs(1:undf_w3) )

    this%flux(:) = 0.0_r_def

    this%a0_coeffs(:) = (/ 1.0_r_def, 3.0_r_def, 4.5_r_def, 11.5_r_def, 18.0_r_def /)
    this%a1_coeffs(:) = (/ 0.0_r_def, 0.0_r_def, 3.5_r_def, 0.0_r_def, 0.0_r_def /)
    this%a2_coeffs(:) = (/ 0.0_r_def, 0.0_r_def, 0.75_r_def, 0.0_r_def, 0.0_r_def /)
    this%rho(:) = (/ 1.0_r_def, 3.0_r_def, 6.5_r_def, 11.5_r_def, 18.0_r_def /)

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(ffsl_vertical_flux_test_type), intent(inout) :: this

    deallocate( this%a2_coeffs )
    deallocate( this%a1_coeffs )
    deallocate( this%a0_coeffs )
    deallocate( this%rho )
    deallocate( this%flux )
    deallocate( this%dep_pts )

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_positive_flux_small_cfl( this )

    use ffsl_vertical_flux_kernel_mod, only : ffsl_vertical_flux_code

    implicit none

    class(ffsl_vertical_flux_test_type), intent(inout) :: this

    real(r_def), parameter :: tol    = 1.0e-6_r_def

    integer(i_def) :: map_w3(1)

    map_w3(1) = 1

    ! Since we have 5 layers there are 26 unique degrees of freedom for W2.
    ! The unique dofs which relate to the vertical components of W2 are
    ! 21,22,23,24,25 and 26.
    ! Hence in dep_pts variable below the vertical departure points are
    ! 0.0,0.5,0.5,0.5,0.5,0.0, taking into account 0.0 departure points for the
    ! top and bottom boundaries.
    this%dep_pts(:) = (/ 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, &
                         0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, &
                         0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, &
                         0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, &
                         0.0_r_def, 0.5_r_def, 0.5_r_def, 0.5_r_def, 0.5_r_def, &
                         0.0_r_def /)

    call ffsl_vertical_flux_code( nlayers,          &
                                  this%flux,        &
                                  this%dep_pts,     &
                                  this%rho,         &
                                  this%a0_coeffs,   &
                                  this%a1_coeffs,   &
                                  this%a2_coeffs,   &
                                  deltaT,           &
                                  ndf_w2,           &
                                  undf_w2,          &
                                  this%map_w2,      &
                                  ndf_w3,           &
                                  undf_w3,          &
                                  map_w3 )

    ! The density values for the 5 layers are (1.0,3.0,6.5,11.5,18.0)
    ! The mass flux is a half for all cells except the middle cell since this is
    ! the only cell which uses PPM.
    @assertEqual(0.0_r_def, this%flux(21), tol)
    @assertEqual(0.5_r_def, this%flux(22), tol)
    @assertEqual(1.5_r_def, this%flux(23), tol)
    @assertEqual(3.78125_r_def, this%flux(24), tol)
    @assertEqual(5.75_r_def, this%flux(25), tol)
    @assertEqual(0.0_r_def, this%flux(26), tol)

  end subroutine test_positive_flux_small_cfl

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_positive_flux_large_cfl( this )

    use ffsl_vertical_flux_kernel_mod, only : ffsl_vertical_flux_code

    implicit none

    class(ffsl_vertical_flux_test_type), intent(inout) :: this

    real(r_def), parameter :: tol    = 1.0e-6_r_def

    integer(i_def) :: map_w3(1)

    map_w3(1) = 1

    this%dep_pts(:) = (/ 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, &
                         0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, &
                         0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, &
                         0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, &
                         0.0_r_def, 0.5_r_def, 1.2_r_def, 0.7_r_def, 0.2_r_def, &
                         0.0_r_def /)

    call ffsl_vertical_flux_code( nlayers,          &
                                  this%flux,        &
                                  this%dep_pts,     &
                                  this%rho,         &
                                  this%a0_coeffs,   &
                                  this%a1_coeffs,   &
                                  this%a2_coeffs,   &
                                  deltaT,           &
                                  ndf_w2,           &
                                  undf_w2,          &
                                  this%map_w2,      &
                                  ndf_w3,           &
                                  undf_w3,          &
                                  map_w3 )

    @assertEqual(0.0_r_def, this%flux(21), tol)
    @assertEqual(0.5_r_def, this%flux(22), tol)
    @assertEqual(3.2_r_def, this%flux(23), tol)
    @assertEqual(4.985750_r_def, this%flux(24), tol)
    @assertEqual(2.3_r_def, this%flux(25), tol)
    @assertEqual(0.0_r_def, this%flux(26), tol)

  end subroutine test_positive_flux_large_cfl

 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_negative_flux_small_cfl( this )

    use ffsl_vertical_flux_kernel_mod, only : ffsl_vertical_flux_code

    implicit none

    class(ffsl_vertical_flux_test_type), intent(inout) :: this

    real(r_def), parameter :: tol    = 1.0e-6_r_def

    integer(i_def) :: map_w3(1)

    map_w3(1) = 1

    this%dep_pts(:) = (/ 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, &
                         0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, &
                         0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, &
                         0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, &
                         0.0_r_def, -0.3_r_def, -0.4_r_def, -0.35_r_def, -0.2_r_def, &
                         0.0_r_def /)

    call ffsl_vertical_flux_code( nlayers,          &
                                  this%flux,        &
                                  this%dep_pts,     &
                                  this%rho,         &
                                  this%a0_coeffs,   &
                                  this%a1_coeffs,   &
                                  this%a2_coeffs,   &
                                  deltaT,           &
                                  ndf_w2,           &
                                  undf_w2,          &
                                  this%map_w2,      &
                                  ndf_w3,           &
                                  undf_w3,          &
                                  map_w3 )

    @assertEqual(0.0_r_def, this%flux(21), tol)
    @assertEqual(-0.9_r_def, this%flux(22), tol)
    @assertEqual(-2.096_r_def, this%flux(23), tol)
    @assertEqual(-4.025_r_def, this%flux(24), tol)
    @assertEqual(-3.6_r_def, this%flux(25), tol)
    @assertEqual(0.0_r_def, this%flux(26), tol)

  end subroutine test_negative_flux_small_cfl

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_negative_flux_large_cfl( this )

    use ffsl_vertical_flux_kernel_mod, only : ffsl_vertical_flux_code

    implicit none

    class(ffsl_vertical_flux_test_type), intent(inout) :: this

    real(r_def), parameter :: tol    = 1.0e-6_r_def

    integer(i_def) :: map_w3(1)

    map_w3(1) = 1

    this%dep_pts(:) = (/ 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, &
                         0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, &
                         0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, &
                         0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, 0.0_r_def, &
                         0.0_r_def,-0.5_r_def,-1.2_r_def,-0.4_r_def,-0.2_r_def, &
                         0.0_r_def /)

    call ffsl_vertical_flux_code( nlayers,          &
                                  this%flux,        &
                                  this%dep_pts,     &
                                  this%rho,         &
                                  this%a0_coeffs,   &
                                  this%a1_coeffs,   &
                                  this%a2_coeffs,   &
                                  deltaT,           &
                                  ndf_w2,           &
                                  undf_w2,          &
                                  this%map_w2,      &
                                  ndf_w3,           &
                                  undf_w3,          &
                                  map_w3 )

    @assertEqual(0.0_r_def, this%flux(21), tol)
    @assertEqual(-1.5_r_def, this%flux(22), tol)
    @assertEqual(-8.8_r_def, this%flux(23), tol)
    @assertEqual(-4.6_r_def, this%flux(24), tol)
    @assertEqual(-3.6_r_def, this%flux(25), tol)
    @assertEqual(0.0_r_def, this%flux(26), tol)

  end subroutine test_negative_flux_large_cfl

end module ffsl_vertical_flux_kernel_mod_test
