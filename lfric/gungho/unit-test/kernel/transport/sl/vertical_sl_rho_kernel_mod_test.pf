!-----------------------------------------------------------------------------
! (c) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!

!> Test the vertical_sl_rho_kernel.
!>
module vertical_sl_rho_kernel_mod_test

  use constants_mod, only : i_def, r_def
  use pFUnit_Mod

  implicit none

  private

  public :: test_all

  @TestCase
  type, public, extends(TestCase) :: vertical_sl_rho_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type vertical_sl_rho_test_type

contains
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

  use feign_config_mod,      only : feign_transport_config
  use transport_config_mod,  only : operators_fv,                  &
                                    runge_kutta_method_ssp2,       &
                                    slice_order_cubic,             &
                                    vertical_sl_order_quintic,     &
                                    ffsl_flux_splitting_full,      &
                                    ffsl_advective_splitting_full, &
                                    max_vert_cfl_calc_uniform,     &
                                    moisture_eqn_advective,        &
                                    ffsl_scheme_three_dim


    implicit none

    class(vertical_sl_rho_test_type), intent(inout) :: this

    call feign_transport_config( operators = operators_fv,                                 &
                                 runge_kutta_method = runge_kutta_method_ssp2,             &
                                 fv_vertical_order = 2,                                    &
                                 fv_horizontal_order = 2,                                  &
                                 consistent_metric  = .false.,                             &
                                 oned_reconstruction = .false.,                            &
                                 cfl_mol_1d_stab = 1.0_r_def,                              &
                                 cfl_mol_2d_stab = 1.0_r_def,                              &
                                 cfl_mol_3d_stab = 1.0_r_def,                              &
                                 slice_order = slice_order_cubic,                          &
                                 vertical_sl_order = vertical_sl_order_quintic,            &
                                 use_density_predictor = .false.,                          &
                                 ffsl_flux_splitting = ffsl_flux_splitting_full,           &
                                 ffsl_advective_splitting = ffsl_advective_splitting_full, &
                                 moisture_eqn=moisture_eqn_advective,                      &
                                 dry_field_name='tracer',                                  &
                                 profile_size = 1,                                         &
                                 field_names = (/'tracer'/),                               &
                                 scheme = (/1/),                                           &
                                 splitting = (/1/),                                        &
                                 horizontal_method = (/1/),                                &
                                 vertical_method = (/1/),                                  &
                                 monotone = (/1/),                                         &
                                 log_space = (/.false./),                                  &
                                 enforce_min_value = (/.false./),                          &
                                 min_value = (/0.0_r_def/),                                &
                                 max_vert_cfl_calc = max_vert_cfl_calc_uniform,            &
                                 ffsl_scheme = ffsl_scheme_three_dim,                      &
                                 reversible = (/.false./)                                  &
                                 )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod,  only: final_configuration

    implicit none

    class(vertical_sl_rho_test_type), intent(inout) :: this

    call final_configuration()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( this )

    use vertical_sl_rho_kernel_mod, only: vertical_sl_rho_code

    implicit none

    class(vertical_sl_rho_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-12_r_def
    real(r_def) :: answer

    integer(i_def), parameter :: nlayers = 10
    integer(i_def), parameter :: ndf_w2 = 6
    integer(i_def), parameter :: nfaces_h  = 4
    integer(i_def), parameter :: undf_w2 = nfaces_h*nlayers & ! Horizontal dofs
                                         + nlayers + 1        ! + vertical dofs
    integer(i_def), parameter :: ndf_w3  = 1
    integer(i_def), parameter :: undf_w3 = nlayers

    integer(i_def), dimension(ndf_w2) :: map_w2
    integer(i_def), dimension(ndf_w3) :: map_w3
    real(r_def), dimension(undf_w2)   :: dep_pts_z
    real(r_def), dimension(undf_w3)   :: rho_in, rho_out
    real(r_def), dimension(6)         :: quintic_param, quintic_coeff
    real(r_def), dimension(6)         :: cubic_coeff, linear_coeff
    real(r_def)     :: dt_here, wind_const, x, xd
    integer(i_def)  :: i, im3, im2, im1, ip1, ip2, df

    ! Create the dof map for any number of layers
    ! Dofs are contiguous in the vertical and so each entry is
    ! offset by nlayers

    do df = 1, nfaces_h
      map_w2(df) = 1 + (df-1)*nlayers
    end do

    ! Vertical dofs are contiguous and so
    ! map(6) needs to be 1 more than map(5)

    map_w2(nfaces_h+1) = 1 + nfaces_h*nlayers
    map_w2(ndf_w2)     = map_w2(nfaces_h+1) + 1
    map_w3(:) = 1

    ! Set 6 parameters to define a unique global quintic function f(x)
    quintic_param(:) = (/1.0_r_def, -2.0_r_def,  1.0_r_def,  2.0_r_def,  0.5_r_def, 1.5_r_def/)

    ! Set the interpolation weights (quinctic, cubic, linear) for a displacement of 0.5
    quintic_coeff(:) = (/3.0_r_def,-25.0_r_def,150.0_r_def,150.0_r_def,-25.0_r_def, 3.0_r_def/)
      cubic_coeff(:) = (/0.0_r_def, -1.0_r_def,  9.0_r_def,  9.0_r_def, -1.0_r_def, 0.0_r_def/)
     linear_coeff(:) = (/0.0_r_def,  0.0_r_def,  0.5_r_def,  0.5_r_def,  0.0_r_def, 0.0_r_def/)
      cubic_coeff(:) =   cubic_coeff(:)/16.0_r_def
    quintic_coeff(:) = quintic_coeff(:)/256.0_r_def

    wind_const = 1.0_r_def
    dt_here = 0.5_r_def
    dep_pts_z = wind_const*dt_here

    do i = 1, nlayers
      x  = real(i-1_i_def,r_def)
      rho_in(i) = quintic_param(1)*(x**5) + quintic_param(2)*(x**4) + &
                  quintic_param(3)*(x**3) + quintic_param(4)*(x**2) + &
                  quintic_param(5)*x      + quintic_param(6)
    end do

    ! The default interpolation is quintic, but reduces to cubic or linear
    ! as the setencil of data reduces near the boundaries. This is also the rule
    ! inside the kernel "vertical_sl_rho_code"

    do i = 1, nlayers
      im1 = max(i-1_i_def,1_i_def)
      im2 = max(i-2_i_def,1_i_def)
      im3 = max(i-3_i_def,1_i_def)
      ip1 = min(i+1_i_def,nlayers)
      ip2 = min(i+2_i_def,nlayers)
      if ( im3 == im2 .or. ip1 == ip2 ) then
          if ( im2 == im1 .or. i == ip1 ) then
             rho_out(i) = linear_coeff(1)*rho_in(im3) + linear_coeff(2)*rho_in(im2) + &
                          linear_coeff(3)*rho_in(im1) + linear_coeff(4)*rho_in(i  ) + &
                          linear_coeff(5)*rho_in(ip1) + linear_coeff(6)*rho_in(ip2)
          else
             rho_out(i) = cubic_coeff(1)*rho_in(im3) + cubic_coeff(2)*rho_in(im2) + &
                          cubic_coeff(3)*rho_in(im1) + cubic_coeff(4)*rho_in(i  ) + &
                          cubic_coeff(5)*rho_in(ip1) + cubic_coeff(6)*rho_in(ip2)

          end if
      else
        rho_out(i) = quintic_coeff(1)*rho_in(im3) + quintic_coeff(2)*rho_in(im2) + &
                     quintic_coeff(3)*rho_in(im1) + quintic_coeff(4)*rho_in(i  ) + &
                     quintic_coeff(5)*rho_in(ip1) + quintic_coeff(6)*rho_in(ip2)
      end if
    end do
    ! For i=1 the depature is clipped (zd=z(1)) because it oustide the data range
    ! and the dispalcement is 0
    rho_out(1) = rho_in(1)

    ! rho_in gets overwitten by the new values on exit

    call vertical_sl_rho_code( nlayers,                 &
                               dep_pts_z,               &
                               rho_in,                  &
                               ndf_w2, undf_w2, map_w2, &
                               ndf_w3, undf_w3, map_w3  )
    do i = 1,nlayers
      @assertEqual(rho_out(i), rho_in(i) , tol)
    end do

  end subroutine test_all

end module vertical_sl_rho_kernel_mod_test
