!-----------------------------------------------------------------------------
! (C) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the flux computation using 1d polynomials
!> (valid for lowest order quadrilateral elements)
module poly1d_w3_reconstruction_kernel_mod_test

  use constants_mod, only : i_def, r_def
  use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: poly1d_w3_reconstruction_test_type
    private
  contains
    procedure test_all
  end type poly1d_w3_reconstruction_test_type

contains

  @Test
  subroutine test_all( this )

    use, intrinsic :: iso_fortran_env, only: real64
    use poly1d_w3_reconstruction_kernel_mod,        only: poly1d_w3_reconstruction_code

    use get_unit_test_planar_mesh_mod, &
                                only: get_outward_normals_to_horizontal_faces

    implicit none

    class(poly1d_w3_reconstruction_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-12_r_def   ! r_def 64bit
    real(r_def) :: answer, use_tol

    integer(i_def), parameter :: nlayers = 1
    integer(i_def), parameter :: ndf_w2 = 4
    integer(i_def), parameter :: ndf_w3 = 1
    integer(i_def), parameter :: ndf_c  = 1
    integer(i_def), parameter :: nfaces_h = 4
    integer(i_def), parameter :: stencil_size = 5
    integer(i_def), parameter :: mol_order = 2
    integer(i_def), parameter :: ndata = (mol_order+1)*nfaces_h
    integer(i_def), parameter :: undf_w2 = ndf_w2*nlayers
    integer(i_def), parameter :: undf_w3 = ndf_w3*nlayers*stencil_size
    integer(i_def), parameter :: undf_c  = ndata*nlayers

    integer(i_def), dimension(ndf_w2)              :: map_w2
    integer(i_def), dimension(ndf_w3)              :: map_w3
    integer(i_def), dimension(ndf_w3,stencil_size) :: smap
    integer(i_def), dimension(ndf_c)               :: map_c

    real(r_def), dimension(3,ndf_w2,ndf_w2)  :: basis_w2
    real(r_def), allocatable, dimension(:,:) :: outward_normals_to_horizontal_faces

    real(r_def), dimension(undf_w2) :: reconstruction
    real(r_def), dimension(undf_w2) :: wind
    real(r_def), dimension(undf_w3) :: density
    real(r_def), dimension(undf_c)  :: coeff

    smap(1,:) = (/ 1, 2, 3, 4, 5 /)
    map_w2(:) = (/ 1, 2, 3, 4 /)
    map_w3(1) = 1
    map_c(1)  = 1

    ! Get canned information for the reference cube
    call get_outward_normals_to_horizontal_faces(outward_normals_to_horizontal_faces)

    wind(:) = 1.0_r_def

    basis_w2 = 0.0_r_def
    basis_w2(1,1,1) = 1.0_r_def
    basis_w2(2,2,2) = -1.0_r_def
    basis_w2(1,3,3) = 1.0_r_def
    basis_w2(2,4,4) = -1.0_r_def

    density(:) = (/ 3.0_r_def, 1.0_r_def, 1.0_r_def, 5.0_r_def, 5.0_r_def /)

    coeff = 0.0_r_def
    coeff(1 + (mol_order+1)) =  5.0_r_def/6.0_r_def
    coeff(2 + (mol_order+1)) =  2.0_r_def/6.0_r_def
    coeff(3 + (mol_order+1)) = -1.0_r_def/6.0_r_def
    coeff(1 + 2*(mol_order+1)) =  5.0_r_def/6.0_r_def
    coeff(2 + 2*(mol_order+1)) = -1.0_r_def/6.0_r_def
    coeff(3 + 2*(mol_order+1)) =  2.0_r_def/6.0_r_def

    reconstruction = 0.0_r_def

    call poly1d_w3_reconstruction_code( nlayers,              &
                                        reconstruction,       &
                                        wind,                 &
                                        density,              &
                                        stencil_size,         &
                                        smap,                 &
                                        coeff,                &
                                        mol_order,            &
                                        ndata,                &
                                        ndf_w2,               &
                                        undf_w2,              &
                                        map_w2,               &
                                        basis_w2,             &
                                        ndf_w3,               &
                                        undf_w3,              &
                                        map_w3,               &
                                        ndf_c,                &
                                        undf_c,               &
                                        map_c,                &
                                        nfaces_h,             &
                                        outward_normals_to_horizontal_faces )

    if ( r_def == real64 ) then
      use_tol = tol
    else
      use_tol = 10.0_r_def*spacing( maxval( reconstruction(1:4) ) )
    end if

    answer = 2.0_r_def
    @assertEqual(answer, reconstruction(2), use_tol)
    answer = 4.0_r_def
    @assertEqual(answer, reconstruction(3), use_tol)
    ! These reconstruction points should not have been computed so check
    ! they are unchanged
    answer = 0.0_r_def
    @assertEqual(answer, reconstruction(1), use_tol)
    @assertEqual(answer, reconstruction(4), use_tol)

  end subroutine test_all

end module poly1d_w3_reconstruction_kernel_mod_test
