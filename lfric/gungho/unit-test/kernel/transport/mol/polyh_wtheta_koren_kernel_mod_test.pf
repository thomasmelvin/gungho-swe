!-----------------------------------------------------------------------------
! (C) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the horizontal edge_values computed for a wtheta-field using the Koren scheme
module polyh_wtheta_koren_kernel_mod_test

  use constants_mod, only : i_def, r_def
  use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: polyh_wtheta_koren_test_type
    private
  contains
    procedure test_all
  end type polyh_wtheta_koren_test_type

contains

  @Test
  subroutine test_all( this )

    use, intrinsic :: iso_fortran_env, only: real64
    use polyh_wtheta_koren_kernel_mod, only: polyh_wtheta_koren_code
    use get_unit_test_planar_mesh_mod, &
                                     only: get_outward_normals_to_horizontal_faces

    implicit none

    class(polyh_wtheta_koren_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-12_r_def
    real(r_def)            :: answer, use_tol

    integer(i_def), parameter                      :: nlayers = 3
    integer(i_def), parameter                      :: ndf_w1 = 8
    integer(i_def), parameter                      :: ndf_w2 = 4
    integer(i_def), parameter                      :: ndf_wt = 2
    integer(i_def), parameter                      :: ndf_c  = 2
    integer(i_def), parameter                      :: nfaces_h = 4
    integer(i_def), parameter                      :: undf_w1 = nfaces_h*(nlayers+1)
    integer(i_def), parameter                      :: undf_w2 = ndf_w2*nlayers
    integer(i_def), dimension(ndf_w1)              :: map_w1
    integer(i_def), dimension(ndf_w2)              :: map_w2
    integer(i_def), parameter                      :: stencil_size = 5
    integer(i_def), dimension(ndf_wt,stencil_size) :: stencil_map
    integer(i_def), parameter                      :: undf_wt = (nlayers+1)*stencil_size
    real(r_def), dimension(3,ndf_w2,ndf_w1)        :: basis_w2
    integer(i_def), parameter                      :: order = 2
    integer(i_def), parameter                      :: ndata = (order+1)*nfaces_h
    integer(i_def), parameter                      :: undf_c = ndata*(nlayers+1)
    real(r_def), allocatable, dimension(:,:)       :: outward_normals_to_horizontal_faces

    real(r_def), dimension(undf_w1) :: reconstruction
    real(r_def), dimension(undf_w2) :: wind
    real(r_def), dimension(undf_wt) :: tracer

    integer(i_def) :: i

    do i = 1,ndf_w2
      map_w2(i) = 1 + (i-1)*nlayers
    end do
    do i = 1,nfaces_h
      map_w1(i) = 1 + (i-1)*(nlayers+1)
      map_w1(i+nfaces_h) = map_w1(i) + 1
    end do
    do i = 1,stencil_size
      stencil_map(1,i) = 1 + (i-1)*(nlayers+1)
      stencil_map(2,i) = 2 + (i-1)*(nlayers+1)
    end do

    ! Get canned information for the reference cube
    call get_outward_normals_to_horizontal_faces(outward_normals_to_horizontal_faces)

    basis_w2 = 0.0_r_def
    basis_w2(1,1,1) = 1.0_r_def
    basis_w2(1,1,5) = 1.0_r_def
    basis_w2(2,2,2) = -1.0_r_def
    basis_w2(2,2,6) = -1.0_r_def
    basis_w2(1,3,3) = 1.0_r_def
    basis_w2(1,3,7) = 1.0_r_def
    basis_w2(2,4,4) = -1.0_r_def
    basis_w2(2,4,8) = -1.0_r_def

    wind(:) = 1.0_r_def

    ! Set up tracer field so that d(tracer)/dx = 10
    tracer(:) = 300.0_r_def
    do i = 0,nlayers
      tracer(stencil_map(1,1)+i) = 300.0_r_def
      tracer(stencil_map(1,2)+i) = 290.0_r_def
      tracer(stencil_map(1,4)+i) = 310.0_r_def
   end do

    call polyh_wtheta_koren_code( nlayers,              &
                                  reconstruction,       &
                                  wind,                 &
                                  tracer,               &
                                  stencil_size,         &
                                  stencil_map,          &
                                  ndata,                &
                                  ndf_w1,               &
                                  undf_w1,              &
                                  map_w1,               &
                                  ndf_w2,               &
                                  undf_w2,              &
                                  map_w2,               &
                                  basis_w2,             &
                                  ndf_wt,               &
                                  undf_wt,              &
                                  stencil_map(:,1),     &
                                  nfaces_h,             &
                                  outward_normals_to_horizontal_faces )

   if ( r_def == real64 ) then
      use_tol = tol
    else
      use_tol = 10.0_r_def*spacing(maxval(reconstruction))
    end if
    answer = 305.0_r_def
    do i = 1,nlayers
      @assertEqual(answer, reconstruction(map_w1(3)+i), use_tol)
    end do

  end subroutine test_all

end module polyh_wtheta_koren_kernel_mod_test
