!-----------------------------------------------------------------------------
! (C) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the flux computation using 1d polynomials
module poly1d_vert_adv_kernel_mod_test

  use constants_mod, only : i_def, r_def, l_def, EPS
  use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: poly1d_vert_adv_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type poly1d_vert_adv_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(poly1d_vert_adv_test_type), intent(inout) :: this

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod, only: final_configuration

    implicit none

    class(poly1d_vert_adv_test_type), intent(inout) :: this

    call final_configuration()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( this )

    use, intrinsic :: iso_fortran_env, only: real64
    use poly1d_vert_adv_kernel_mod, only: poly1d_vert_adv_code
    implicit none

    class(poly1d_vert_adv_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-12_r_def   ! r_def 64bit
    real(r_def)            :: answer, tst, use_tol

    integer(i_def), parameter :: nfaces_v = 2
    integer(i_def), parameter :: nfaces_h = 4
    integer(i_def), parameter :: nlayers = 6
    integer(i_def), parameter :: mol_order = 3
    integer(i_def), parameter :: ndata = (mol_order+1)*nfaces_v
    integer(i_def), parameter :: ndf_w2 = 6
    integer(i_def), parameter :: ndf_wt = 2
    integer(i_def), parameter :: ndf_c  = 2
    integer(i_def), parameter :: undf_w2 = nlayers*nlayers + (nlayers+1)
    integer(i_def), parameter :: undf_wt = nlayers+1
    integer(i_def), parameter :: undf_c  = ndata*(nlayers+1)

    integer(i_def), dimension(ndf_w2) :: map_w2
    integer(i_def), dimension(ndf_wt) :: map_wt
    integer(i_def), dimension(ndf_c)  :: map_c

    real(r_def), dimension(undf_wt) :: flux
    real(r_def), dimension(undf_wt) :: flux_answer
    real(r_def), dimension(undf_w2) :: wind
    real(r_def), dimension(undf_wt) :: density
    real(r_def), dimension(undf_c)  :: coeff

    integer(i_def) :: df, k, f
    logical(l_def) :: logspace

    map_wt(:) = (/ 1, 2 /)
    map_c(:)  = (/ 1, 1+ndata /)
    do df = 1,nfaces_h
      map_w2(df) = 1 + (df-1)*nlayers
    end do
    map_w2(5) = 1 + nfaces_h*nlayers
    map_w2(6) = map_w2(5) + 1

    wind(:) = 1.0_r_def

    do k = 1,nlayers+1
      density(k) = real(k,r_def)
    end do

    do k = 0,nlayers
      do f = 1,nfaces_v
        coeff(0 + (f-1)*(mol_order+1) + k*ndata + map_c(1)) = -2.0_r_def/6.0_r_def
        coeff(1 + (f-1)*(mol_order+1) + k*ndata + map_c(1)) = -3.0_r_def/6.0_r_def
        coeff(2 + (f-1)*(mol_order+1) + k*ndata + map_c(1)) =  6.0_r_def/6.0_r_def
        coeff(3 + (f-1)*(mol_order+1) + k*ndata + map_c(1)) = -1.0_r_def/6.0_r_def
      end do
    end do
    flux = 0.0_r_def

    ! First test standard polynomial interpolation
    logspace = .false.
    call poly1d_vert_adv_code( nlayers,              &
                               flux,                 &
                               wind,                 &
                               density,              &
                               coeff,                &
                               ndata,                &
                               mol_order,            &
                               logspace,             &
                               ndf_wt,               &
                               undf_wt,              &
                               map_wt,               &
                               ndf_w2,               &
                               undf_w2,              &
                               map_w2,               &
                               ndf_c,                &
                               undf_c,               &
                               map_c)

    answer = 1.0_r_def
    if ( r_def == real64 ) then
      use_tol = tol
    else
      use_tol = 10.0_r_def*spacing( maxval( flux(map_wt(1)+2:map_wt(1)+4) ) )
    end if
    @assertEqual(answer, flux(map_wt(1)+2), use_tol)
    @assertEqual(answer, flux(map_wt(1)+3), use_tol)
    @assertEqual(answer, flux(map_wt(1)+4), use_tol)

    ! Next test polynomial interpolation in log-space

    flux = 0.0_r_def

    do k = 1,nlayers+1
      density(k) = exp(-real(k,r_def))
    end do

    logspace = .true.
    call poly1d_vert_adv_code( nlayers,              &
                               flux,                 &
                               wind,                 &
                               density,              &
                               coeff,                &
                               ndata,                &
                               mol_order,            &
                               logspace,             &
                               ndf_wt,               &
                               undf_wt,              &
                               map_wt,               &
                               ndf_w2,               &
                               undf_w2,              &
                               map_w2,               &
                               ndf_c,                &
                               undf_c,               &
                               map_c )
    if ( r_def == real64 ) then
      use_tol = tol
    else
      use_tol = 10.0_r_def*spacing( maxval( flux(map_wt(1)+2:map_wt(1)+3) ) )
    end if
    do k = 2,3
      answer = -density(map_wt(1)+k)
      @assertEqual(answer, flux(map_wt(1)+k), use_tol)
    end do

    ! ------------------------------------------------------------------------ !
    ! Test that zero values don't cause blow up
    ! ------------------------------------------------------------------------ !

    ! Do reconstruction with zero density
    density(:) = 0.0_r_def
    flux(:) = 0.0_r_def
    call poly1d_vert_adv_code( nlayers,              &
                               flux,                 &
                               wind,                 &
                               density,              &
                               coeff,                &
                               ndata,                &
                               mol_order,            &
                               logspace,             &
                               ndf_wt,               &
                               undf_wt,              &
                               map_wt,               &
                               ndf_w2,               &
                               undf_w2,              &
                               map_w2,               &
                               ndf_c,                &
                               undf_c,               &
                               map_c )
    ! Now do reconstruction with tiny density as a control
    density(:) = EPS
    flux_answer(:) = 0.0_r_def
    call poly1d_vert_adv_code( nlayers,              &
                               flux_answer,          &
                               wind,                 &
                               density,              &
                               coeff,                &
                               ndata,                &
                               mol_order,            &
                               logspace,             &
                               ndf_wt,               &
                               undf_wt,              &
                               map_wt,               &
                               ndf_w2,               &
                               undf_w2,              &
                               map_w2,               &
                               ndf_c,                &
                               undf_c,               &
                               map_c )

    @assertEqual(flux_answer, flux, use_tol)

  end subroutine test_all

end module poly1d_vert_adv_kernel_mod_test
