!-----------------------------------------------------------------------------
! (C) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the computation of 1d advective coeffs
module poly1d_advective_coeffs_kernel_mod_test

  use constants_mod, only : i_def, r_def
  use pFUnit_Mod
  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: poly1d_advective_coeffs_test_type
    private
  contains
    procedure setUp
    procedure test_all
    procedure tearDown
  end type poly1d_advective_coeffs_test_type

contains

  subroutine setUp( this )
    use feign_config_mod,          only: feign_base_mesh_config, &
                                         feign_domain_size_config, &
                                         feign_finite_element_config
    use base_mesh_config_mod,      only: geometry_planar,    &
                                         topology_fully_periodic
    use finite_element_config_mod, only: coord_system_xyz, &
                                         cellshape_quadrilateral
    use chi_transform_mod,         only: init_chi_transforms

    implicit none
    class(poly1d_advective_coeffs_test_type), intent(inout) :: this

    call feign_base_mesh_config( filename='foo',                      &
                                 prime_mesh_name='unit_test',         &
                                 geometry=geometry_planar,            &
                                 offline_partitioning=.false.,        &
                                 topology=topology_fully_periodic,    &
                                 fplane=.false., f_lat_deg=0.0_r_def )

    call  feign_domain_size_config(planar_domain_min_x = -10.0_r_def, &
                                   planar_domain_max_x = 10.0_r_def,  &
                                   planar_domain_min_y = -10.0_r_def, &
                                   planar_domain_max_y = 10.0_r_def )

    call  feign_finite_element_config( cellshape = cellshape_quadrilateral, &
                                       coord_order = 1, &
                                       coord_system = coord_system_xyz, &
                                       element_order = 0, &
                                       rehabilitate = .true., &
                                       vorticity_in_w1 = .true. )

    call init_chi_transforms()

  end subroutine setUp


  @Test
  subroutine test_all( this )

    use, intrinsic :: iso_fortran_env,      only : real64
    use poly1d_advective_coeffs_kernel_mod, only : poly1d_advective_coeffs_code

    implicit none

    class(poly1d_advective_coeffs_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-12_r_def      ! r_def 64bit tolerance
    real(r_def), dimension(3) :: answer, tst
    real(r_def)               :: use_tol

    integer(i_def), parameter :: nlayers = 3
    integer(i_def), parameter :: ndf_wt = 2
    integer(i_def), parameter :: ndf_wx = 8
    integer(i_def), parameter :: ndf_pid = 1
    integer(i_def), parameter :: stencil_size = 5
    integer(i_def), parameter :: mol_order = 2
    integer(i_def), parameter :: nqp = 3
    integer(i_def), parameter :: nqp_h = nqp**2
    integer(i_def), parameter :: nqp_v = 2
    integer(i_def), parameter :: nqp_e = 1
    integer(i_def), parameter :: nfaces = 4
    integer(i_def), parameter :: undf_wt = (nlayers+1)*stencil_size
    integer(i_def), parameter :: undf_wx = ndf_wx*nlayers*stencil_size
    integer(i_def), parameter :: undf_pid = stencil_size
    integer(i_def), parameter :: ndata = (mol_order+1)*nfaces
    integer(i_def), parameter :: ndf_c = 1
    integer(i_def), parameter :: undf_c = ndata

    integer(i_def), dimension(ndf_c)                :: map_c
    integer(i_def), dimension(ndf_wt,stencil_size)  :: smap_wt
    integer(i_def), dimension(ndf_wx,stencil_size)  :: smap_wx
    integer(i_def), dimension(ndf_pid,stencil_size) :: smap_pid


    real(r_def), dimension(ndf_wx,nqp_h,nqp_v) :: basis_wx
    real(r_def), dimension(ndf_wx,nqp_e,4,2) :: edge_basis_wx
    real(r_def), dimension(nqp_h)            :: wqp_h
    real(r_def), dimension(nqp_v), parameter :: wqp_v = (/ 0.5_r_def, 0.5_r_def /)
    real(r_def), dimension(nqp_e), parameter :: wqp_e = (/ 1.0_r_def /)

    real(r_def), dimension(undf_c)   :: coeff
    real(r_def), dimension(undf_wt)  :: mdwt
    real(r_def), dimension(undf_wx)  :: x, y, z
    real(r_def), dimension(undf_pid) :: panel_id

    real(r_def), dimension(stencil_size) :: stencil_dx, stencil_dy
    real(r_def), dimension(3) :: xq, wqp

    real(r_def), parameter :: dx = 2.0_r_def
    real(r_def), parameter :: dy = 3.0_r_def
    real(r_def), parameter :: dz = 4.0_r_def
    real(r_def), parameter :: dv = dx*dy*dz
    real(r_def), parameter :: h0 = 0.0_r_def

    integer(i_def) :: k, df, s, ij, i, j

    xq(:) = 0.5_r_def + 0.5_r_def*(/ -sqrt(3.0_r_def/5.0_r_def), 0.0_r_def, sqrt(3.0_r_def/5.0_r_def) /)
    wqp(:) = (/5.0_r_def, 8.0_r_def, 5.0_r_def/)/18.0_r_def
    do j = 1,nqp
      do i = 1,nqp
        ij = i+(j-1)*nqp
        wqp_h(ij) = wqp(i)*wqp(j)
      end do
    end do

    panel_id(:) = 1.0_r_def

    do s = 1,stencil_size
      smap_pid(1,s) = s
      smap_wt(1,s) = 1 + (s-1)*(nlayers+1)
      smap_wt(2,s) = 2 + (s-1)*(nlayers+1)

      do df = 1, ndf_wx
        smap_wx(df,s) = 1 + (df-1)*nlayers + (s-1)*nlayers*ndf_wx
      end do
    end do

    map_c(:) = (/ 1 /)

    stencil_dx = (/ 0.0_r_def, -dx, 0.0_r_def, dx, 0.0_r_def /)
    stencil_dy = (/ 0.0_r_def, 0.0_r_def, -dy, 0.0_r_def, dy /)

    do k = 0,nlayers-1
      x(smap_wx(1,1)+k) = 0.0_r_def
      x(smap_wx(2,1)+k) = dx
      x(smap_wx(3,1)+k) = 0.0_r_def
      x(smap_wx(4,1)+k) = dx
      y(smap_wx(1,1)+k) = 0.0_r_def
      y(smap_wx(2,1)+k) = 0.0_r_def
      y(smap_wx(3,1)+k) = dy
      y(smap_wx(4,1)+k) = dy
      z(smap_wx(1,1)+k) = k*dz
      z(smap_wx(2,1)+k) = k*dz
      z(smap_wx(3,1)+k) = k*dz
      z(smap_wx(4,1)+k) = k*dz
      do df = 1,4
        x(smap_wx(4+df,1)+k) = x(smap_wx(df,1)+k)
        y(smap_wx(4+df,1)+k) = y(smap_wx(df,1)+k)
        z(smap_wx(4+df,1)+k) = z(smap_wx(df,1)+k) + dz
      end do
      do i = 2, stencil_size
        do df = 1,8
          x(smap_wx(df,i)+k) = x(smap_wx(df,1)+k) + stencil_dx(i)
          y(smap_wx(df,i)+k) = y(smap_wx(df,1)+k) + stencil_dy(i)
          z(smap_wx(df,i)+k) = z(smap_wx(df,1)+k)
         end do
      end do

    end do

    mdwt(:) = dv

    basis_wx = 0.0_r_def
    do j = 1,nqp
      do i = 1,nqp
        ij = i+(j-1)*nqp
        basis_wx(1,ij,1) = (1.0_r_def - xq(i))*(1.0_r_def - xq(j))
        basis_wx(2,ij,1) =              xq(i) *(1.0_r_def - xq(j))
        basis_wx(3,ij,1) = (1.0_r_def - xq(i))*             xq(j)
        basis_wx(4,ij,1) =              xq(i) *             xq(j)
        basis_wx(5,ij,2) = (1.0_r_def - xq(i))*(1.0_r_def - xq(j))
        basis_wx(6,ij,2) =              xq(i) *(1.0_r_def - xq(j))
        basis_wx(7,ij,2) = (1.0_r_def - xq(i))*             xq(j)
        basis_wx(8,ij,2) =              xq(i) *             xq(j)
      end do
    end do

    edge_basis_wx(:,:,:,:) = 0.0_r_def
    edge_basis_wx(1,1,1,1) = 0.5_r_def
    edge_basis_wx(1,1,2,1) = 0.5_r_def
    edge_basis_wx(2,1,2,1) = 0.5_r_def
    edge_basis_wx(2,1,3,1) = 0.5_r_def
    edge_basis_wx(3,1,1,1) = 0.5_r_def
    edge_basis_wx(3,1,4,1) = 0.5_r_def
    edge_basis_wx(4,1,3,1) = 0.5_r_def
    edge_basis_wx(4,1,4,1) = 0.5_r_def
    edge_basis_wx(5,1,1,2) = 0.5_r_def
    edge_basis_wx(5,1,2,2) = 0.5_r_def
    edge_basis_wx(6,1,2,2) = 0.5_r_def
    edge_basis_wx(6,1,3,2) = 0.5_r_def
    edge_basis_wx(7,1,1,2) = 0.5_r_def
    edge_basis_wx(7,1,4,2) = 0.5_r_def
    edge_basis_wx(8,1,3,2) = 0.5_r_def
    edge_basis_wx(8,1,4,2) = 0.5_r_def

    call poly1d_advective_coeffs_code(nlayers,                   &
                                      coeff,                     &
                                      mdwt,                      &
                                      stencil_size,              &
                                      smap_wt,                   &
                                      x, y, z,                   &
                                      stencil_size,              &
                                      smap_wx,                   &
                                      panel_id,                  &
                                      stencil_size,              &
                                      smap_pid,                  &
                                      ndata,                     &
                                      mol_order,                 &
                                      nfaces,                    &
                                      h0,                        &
                                      nlayers,                   &
                                      ndf_c,                     &
                                      undf_c,                    &
                                      map_c,                     &
                                      ndf_wt,                    &
                                      undf_wt,                   &
                                      smap_wt(:,1),              &
                                      ndf_wx,                    &
                                      undf_wx,                   &
                                      smap_wx(:,1),              &
                                      basis_wx,                  &
                                      edge_basis_wx,             &
                                      ndf_pid, undf_pid,         &
                                      smap_pid(:,1),             &
                                      nqp_h, nqp_v, wqp_h, wqp_v,&
                                      nfaces, nqp_e, wqp_e )

    answer = (/  5.0_r_def/6.0_r_def,  2.0_r_def/6.0_r_def, -1.0_r_def/6.0_r_def /)

    if ( r_def == real64 ) then
      use_tol = tol
    else
      use_tol = 10.0_r_def*spacing( maxval( answer ) )
    end if
    do df = 1,3
      @assertEqual(answer(df), coeff(1 + (df-1)), use_tol)
    end do
  end subroutine test_all

  subroutine tearDown( this )

    use configuration_mod,   only: final_configuration
    use chi_transform_mod,   only: final_chi_transforms

    implicit none

    class(poly1d_advective_coeffs_test_type), intent(inout) :: this

    call final_configuration()
    call final_chi_transforms()

  end subroutine tearDown

end module poly1d_advective_coeffs_kernel_mod_test
