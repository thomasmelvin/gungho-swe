!-----------------------------------------------------------------------------
! (c) Crown copyright 2019 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> Test the advective wind update computation
module w3_advective_update_kernel_mod_test

  use, intrinsic :: iso_fortran_env, only : real64, real32
  use constants_mod,                 only : i_def, r_def
  use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: w3_advective_update_test_type
    private
  contains
    procedure test_all
  end type w3_advective_update_test_type

contains

  @test
  subroutine test_all( this )

    use w3_advective_update_kernel_mod, only : w3_advective_update_code

    implicit none

    class(w3_advective_update_test_type), intent(inout) :: this

    real(kind=r_def) :: tol
    real(kind=r_def) :: answer

    ! Mesh
    integer(kind=i_def), parameter :: nlayers = 2
    integer(kind=i_def), parameter :: ncell_3d = nlayers
    integer(kind=i_def), parameter :: cell = 1
    ! Scalar Space
    integer(kind=i_def), parameter                           :: ndf_ws = 1_i_def
    integer(kind=i_def), parameter                           :: undf_ws = ndf_ws*nlayers
    integer(kind=i_def), dimension(ndf_ws)                   :: map_ws
    real(kind=r_def),    dimension(undf_ws)                  :: advective_update
    real(kind=r_def),    dimension(ndf_ws, ndf_ws, ncell_3d) :: m3_inv
    ! Vector Space
    integer(kind=i_def), parameter          :: ndf_wv  = 6_i_def
    integer(kind=i_def), parameter          :: undf_wv = (ndf_wv-2_i_def)*nlayers + nlayers + 1
    integer(kind=i_def), dimension(ndf_wv)  :: map_wv
    real(kind=r_def),    dimension(undf_wv) :: wind, wind_recon

    integer(kind=i_def) :: k, df, d

    map_ws = (/ 1 /)
    map_wv(1) = 1
    do df = 2,5
      map_wv(df) = map_wv(df-1) + nlayers
    end do
    map_wv(6) = map_wv(5) + 1

    ! Set some values for the initial field
    do k = 0,nlayers - 1
      wind(map_wv(1)+k) = 0.25_r_def + real(k,r_def)
      wind(map_wv(3)+k) = 0.75_r_def + real(k,r_def)
      wind(map_wv(2)+k) = -1.25_r_def - real(k,r_def)
      wind(map_wv(4)+k) =  1.25_r_def + real(k,r_def)
      wind(map_wv(5)+k) = 0.0_r_def
      wind(map_wv(6)+k) = 0.0_r_def
      wind_recon(map_wv(1)+k) =-19.0_r_def - 3.52_r_def*real(k,r_def)
      wind_recon(map_wv(2)+k) =-23.0_r_def + 1.46_r_def*real(k,r_def)
      wind_recon(map_wv(3)+k) = 19.0_r_def + 3.52_r_def*real(k,r_def)
      wind_recon(map_wv(4)+k) = 0.0_r_def
      wind_recon(map_wv(5)+k) = 21.0_r_def + 3.52_r_def*real(k,r_def)
      wind_recon(map_wv(6)+k) =-64.1_r_def - 0.46_r_def*real(df,r_def)
    end do

    m3_inv(:,:,:) = 0.1_r_def
    advective_update = 0.0_r_def

    call w3_advective_update_code(cell, nlayers,           &
                                  advective_update,        &
                                  wind_recon,              &
                                  wind,                    &
                                  ncell_3d, m3_inv,        &
                                  ndf_ws, undf_ws, map_ws, &
                                  ndf_wv, undf_wv, map_wv  &
                                 )

    select case(r_def)
    case(real64)
      tol = 1.0e-9_r_def
    case(real32)
      tol = 1.0e-6_r_def
    case default
      @assertFail("r_def precision not implemented")
    end select

    do k = 0,nlayers-1
      answer = 0.2_r_def*(0.5_r_def + real(k,r_def))*wind_recon(map_wv(3)+k)
      @assertEqual(answer, advective_update(map_ws(1)+k), tol)
    end do

  end subroutine test_all

end module w3_advective_update_kernel_mod_test
