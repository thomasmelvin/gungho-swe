!-----------------------------------------------------------------------------
! (C) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Does the W2 mask give 1 for dofs in the interior and 0 elsewhere?
module create_w2mask_kernel_mod_test

  use constants_mod,                       only: i_def, r_def
  use get_unit_test_m3x3_dofmap_mod,       only: get_w0_m3x3_dofmap,       &
                                                 get_w2_m3x3_dofmap
  use get_unit_test_m3x3_q3x3x3_sizes_mod, only: get_w0_m3x3_q3x3x3_size,  &
                                                 get_w2_m3x3_q3x3x3_size
  use get_unit_test_w2nodal_basis_mod,     only: get_w0_w2nodal_basis
  use get_unit_test_3x3x3_chi_mod,         only: get_w0_3x3x3_field
  use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: create_w2mask_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type create_w2mask_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use base_mesh_config_mod, only: geometry_planar, &
                                    topology_non_periodic
    use feign_config_mod,          only : feign_base_mesh_config,  &
                                          feign_finite_element_config
    use finite_element_config_mod, only : cellshape_quadrilateral, &
                                          coord_system_xyz

    implicit none

    class(create_w2mask_test_type), intent(inout) :: this

    call feign_base_mesh_config( filename        = 'foo',                 &
                                 prime_mesh_name = 'unit_test',           &
                                 geometry        = geometry_planar,       &
                                 offline_partitioning = .false.,          &
                                 topology        = topology_non_periodic, &
                                 fplane          = .false.,               &
                                 f_lat_deg       = 0.0_r_def )

    call feign_finite_element_config(                                  &
                    cellshape=cellshape_quadrilateral,                 &
                    coord_order=0_i_def,                               &
                    coord_system=coord_system_xyz,                     &
                    element_order=0_i_def,                             &
                    rehabilitate=.true.,                               &
                    vorticity_in_w1=.false. )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod,        only: final_configuration

    implicit none

    class(create_w2mask_test_type), intent(inout) :: this

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( this )

    use create_w2mask_kernel_mod, only: create_w2mask_code
    implicit none

    class(create_w2mask_test_type), intent(inout) :: this

    real(r_def), parameter    :: tol = 1.0e-6_r_def
    real(r_def), parameter    :: dx = 6000.0_r_def, &
                                 dy = 1000.0_r_def, &
                                 dz = 2000.0_r_def
    real(r_def), parameter    :: boundary_s = 1000.0_r_def, &
                                 boundary_n = 3000.0_r_def, &
                                 boundary_w = 6000.0_r_def, &
                                 boundary_e = 18000.0_r_def
    integer(i_def), parameter :: rim_width_ns = 0_i_def,    &
                                 rim_width_ew = 0_i_def

    real(kind=r_def) :: answer

    integer(i_def) :: ndf_chi, undf_chi
    integer(i_def), allocatable :: map_chi(:,:)
    integer(i_def), allocatable :: map_w0(:,:)
    integer(i_def), allocatable :: map_w2(:,:)
    real(r_def), allocatable :: basis_w0(:,:,:)
    real(r_def), allocatable :: basis_chi(:,:,:)
    real(r_def), allocatable :: chi1(:), chi2(:), chi3(:)
    real(r_def), allocatable :: u_mask(:)

    integer(i_def) :: nlayers
    integer(i_def) :: ncells
    integer(i_def) :: dim_space
    integer(i_def) :: dim_space_diff
    integer(i_def) :: nqp_h
    integer(i_def) :: nqp_v
    integer(i_def) :: ndf_w0
    integer(i_def) :: undf_w0
    integer(i_def) :: ndf_w2
    integer(i_def) :: undf_w2

    integer(i_def) :: i, j, k, cell, dof

    !=====================================
    ! Get infrastructure support data
    !=====================================
    nlayers = 3

    ! Get sizes
    call get_w0_m3x3_q3x3x3_size( ndf_w0, undf_w0, ncells,   &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v,              &
                                  nlayers )
    call get_w2_m3x3_q3x3x3_size( ndf_w2, undf_w2, ncells,   &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v,              &
                                  nlayers )

    ! Get maps
    call get_w0_m3x3_dofmap( map_w0 )
    call get_w2_m3x3_dofmap( map_w2 )

    ! Get basis functions
    call get_w0_w2nodal_basis( basis_w0 )

    ! Compute coordinates
    allocate( chi1(undf_w0) )
    allocate( chi2(undf_w0) )
    allocate( chi3(undf_w0) )

    call get_w0_3x3x3_field(chi1, chi2, chi3, dx, dy, dz, &
                            map_w0, nlayers)

    !=====================================
    ! Assign data for testing
    !=====================================
    allocate( map_chi, source = map_w0 )
    allocate( basis_chi, source = basis_w0 )
    ndf_chi  = ndf_w0
    undf_chi = undf_w0
    allocate( u_mask(undf_w2) )

    ! Cell ordering with boundaries
    !
    !  --> x
    !
    !  |  1  2  3
    !  v    ------
    !  y  4 |5  6|
    !       |    |
    !     7 |8  9|
    !       ------

    ! Face ordering on a cell in the w2 dofmap
    ! ----2----
    ! |       |
    ! 1       3
    ! |       |
    ! ----4----

    ! The W2 mask assigns 1 to dofs on interior, and 0 to dofs
    ! on exterior, and 0 to dofs on the boundary.

    !=====================================
    ! Apply test on interior cell 5
    !=====================================
    cell = 5
    dof = 3
    answer = 1.0_r_def

    ! Call the kernel to create mask
    call create_w2mask_code( nlayers,         &
                             boundary_s,      &
                             boundary_n,      &
                             boundary_e,      &
                             boundary_w,      &
                             rim_width_ns,    &
                             rim_width_ew,    &
                             u_mask,          &
                             chi1,            &
                             chi2,            &
                             chi3,            &
                             ndf_w2,          &
                             undf_w2,         &
                             map_w2(:,cell),  &
                             ndf_chi,         &
                             undf_chi,        &
                             map_chi(:,cell), &
                             basis_chi )
    k = 2
    @assertEqual( u_mask(map_w2(dof,cell) + k), answer, tol )

    !=====================================
    ! Apply test on boundary of cell 5
    !=====================================
    cell = 5
    dof = 1
    answer = 0.0_r_def

    ! Call the kernel to create mask
    call create_w2mask_code( nlayers,         &
                             boundary_s,      &
                             boundary_n,      &
                             boundary_e,      &
                             boundary_w,      &
                             rim_width_ns,    &
                             rim_width_ew,    &
                             u_mask,          &
                             chi1,            &
                             chi2,            &
                             chi3,            &
                             ndf_w2,          &
                             undf_w2,         &
                             map_w2(:,cell),  &
                             ndf_chi,         &
                             undf_chi,        &
                             map_chi(:,cell), &
                             basis_chi )
    k = 2
    @assertEqual( u_mask(map_w2(dof,cell) + k), answer, tol )

    !=====================================
    ! Apply test on exterior cell 1
    !=====================================
    cell = 1
    dof = 3
    answer = 0.0_r_def

    ! Call the kernel to create mask
    call create_w2mask_code( nlayers,         &
                             boundary_s,      &
                             boundary_n,      &
                             boundary_e,      &
                             boundary_w,      &
                             rim_width_ns,    &
                             rim_width_ew,    &
                             u_mask,          &
                             chi1,            &
                             chi2,            &
                             chi3,            &
                             ndf_w2,          &
                             undf_w2,         &
                             map_w2(:,cell),  &
                             ndf_chi,         &
                             undf_chi,        &
                             map_chi(:,cell), &
                             basis_chi )
    k = 2
    @assertEqual( u_mask(map_w2(dof,cell) + k), answer, tol )

    deallocate( map_chi )
    deallocate( map_w0 )
    deallocate( map_w2 )
    deallocate( chi1 )
    deallocate( chi2 )
    deallocate( chi3 )
    deallocate( basis_w0 )
    deallocate( basis_chi )
    deallocate( u_mask )

  end subroutine test_all

end module create_w2mask_kernel_mod_test
