!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

module departure_point_kernel_mod_test

  use pFUnit_Mod
  use constants_mod,      only : i_def, r_def, r_second
  use mesh_mod,           only : mesh_type

  implicit none

  private
  public :: developed_departure_point_test_type , test_all

  @TestCase
  type, extends(TestCase) :: developed_departure_point_test_type
    private
    type(mesh_type)          :: mesh
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type developed_departure_point_test_type

  real(r_second), parameter :: dt  = 10.0_r_second
  real(r_def), parameter    :: alpha   = 0.5_r_def
  real(r_def), parameter    :: tau_u   = 0.5_r_def
  real(r_def), parameter    :: tau_t   = 0.5_r_def
  real(r_def), parameter    :: tau_r   = 0.5_r_def
  integer(i_def), parameter :: inner_iterations = 0
  integer(i_def), parameter :: outer_iterations = 0
  integer(i_def), parameter :: n_dep_pt_iterations = 1
  real(r_second), parameter :: spinup_period = 0.0_r_second
  logical, parameter        :: spinup_winds  = .false.
  logical, parameter        :: spinup_alpha  = .false.

contains


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use feign_config_mod,          only : feign_timestepping_config
    use timestepping_config_mod,   only : method_semi_implicit, &
                                          runge_kutta_method_ssp3

    implicit none

    class(developed_departure_point_test_type), intent(inout) :: this

    call feign_timestepping_config(                                       &
             method=method_semi_implicit,                                 &
             dt=dt,                                                       &
             alpha=alpha,                                                 &
             tau_u=tau_u,                                                 &
             tau_t=tau_t,                                                 &
             tau_r=tau_r,                                                 &
             outer_iterations=outer_iterations,                           &
             inner_iterations=inner_iterations,                           &
             runge_kutta_method=runge_kutta_method_ssp3,                  &
             spinup_period=spinup_period,                                 &
             spinup_alpha=spinup_alpha,                                   &
             spinup_winds=spinup_winds )


  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod,        only: final_configuration

    implicit none

    class(developed_departure_point_test_type), intent(inout) :: this

    call final_configuration()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( this )

    use calc_departure_point_kernel_mod, only : calc_departure_point_code
    use flux_direction_mod,              only : x_direction
    use departure_points_config_mod,     only : method_euler, method_trapezoidal

    implicit none

    class(developed_departure_point_test_type), intent(inout) :: this

    real(r_def), parameter        :: tol    = 1.0e-6_r_def
    real(kind=r_def),allocatable  :: u_field(:), dep_pts(:)
    integer                       :: nlayers
    integer                       :: ndf_w0, ndf_w2, ndf_w3
    integer                       :: undf_w0, undf_w2, undf_w3
    integer                       :: departure_pt_stencil_length
    integer, allocatable          :: stencil_map_W2(:,:)
    integer, allocatable          :: stencil_map_w3(:,:)
    real(kind=r_def), allocatable :: cell_orientation(:)

    nlayers = 1
    undf_w2 = 28
    ndf_w2 = 4
    ndf_w3 = 1
    departure_pt_stencil_length = 9
    undf_w3 = 9

    allocate(u_field(1:undf_w2))
    allocate(dep_pts(1:undf_w2))
    allocate(stencil_map_W2(1:ndf_w2,1:departure_pt_stencil_length))
    allocate(stencil_map_w3(1:ndf_w3,1:departure_pt_stencil_length))
    allocate(cell_orientation(1:departure_pt_stencil_length))

    ! Assume a constant wind field
    u_field(:) = 0.1_r_def

    stencil_map_w3(1,1:9) = (/ 1,2,3,4,5,6,7,8,9 /)

    ! Define the W2 stencil dofmap
    stencil_map_W2(1:4,1) = (/ 1,2,3,4 /)
    stencil_map_W2(1:4,2) = (/ 5,6,1,7 /)
    stencil_map_W2(1:4,3) = (/ 11,12,5,13 /)
    stencil_map_W2(1:4,4) = (/ 17,18,11,19 /)
    stencil_map_W2(1:4,5) = (/ 23,24,17,25 /)
    stencil_map_W2(1:4,6) = (/ 3,8,9,10 /)
    stencil_map_W2(1:4,7) = (/ 9,14,15,16 /)
    stencil_map_W2(1:4,8) = (/ 15,20,21,22 /)
    stencil_map_W2(1:4,9) = (/ 21,26,27,28 /)

    ! Assume all cells in stencil have orientation 1
    cell_orientation(1:departure_pt_stencil_length) = 1.0_r_def

    dep_pts(:) = 0.0_r_def

    call calc_departure_point_code( nlayers,                       &
                                    dep_pts,                       &
                                    departure_pt_stencil_length,   &
                                    n_dep_pt_iterations,           &
                                    real(dt, r_def),               &
                                    undf_w2,                       &
                                    ndf_w2,                        &
                                    stencil_map_W2,                &
                                    undf_w3,                       &
                                    ndf_w3,                        &
                                    stencil_map_w3,                &
                                    cell_orientation,              &
                                    u_field,                       &
                                    u_field,                       &
                                    x_direction,                   &
                                    method_euler)
    @assertEqual(1.0_r_def, dep_pts(1), tol)

    ! Linearly varying wind field values which are determined by the above
    ! stencil map for W2
    u_field(:)  = 0.0_r_def
    u_field(23) = 0.11_r_def
    u_field(17) = 0.12_r_def
    u_field(11) = 0.13_r_def
    u_field(5)  = 0.14_r_def
    u_field(1)  = 0.15_r_def
    u_field(3)  = 0.16_r_def
    u_field(9)  = 0.17_r_def
    u_field(15) = 0.18_r_def
    u_field(21) = 0.19_r_def
    u_field(27) = 0.20_r_def


    dep_pts(:) = 0.0_r_def
    call calc_departure_point_code( nlayers,                       &
                                    dep_pts,                       &
                                    departure_pt_stencil_length,   &
                                    n_dep_pt_iterations,           &
                                    real(dt, r_def),               &
                                    undf_w2,                       &
                                    ndf_w2,                        &
                                    stencil_map_W2,                &
                                    undf_w3,                       &
                                    ndf_w3,                        &
                                    stencil_map_w3,                &
                                    cell_orientation,              &
                                    u_field,                       &
                                    u_field,                       &
                                    x_direction,                   &
                                    method_euler)
    @assertEqual(1.5_r_def, dep_pts(1), tol)
    @assertEqual(0.0_r_def, dep_pts(2), tol)
    @assertEqual(1.6_r_def, dep_pts(3), tol)
    @assertEqual(0.0_r_def, dep_pts(4), tol)

    ! Test departure_point_code subroutine with cells with varying cell orientations
    cell_orientation(1:departure_pt_stencil_length) = &
    (/ 1.0_r_def,4.0_r_def,2.0_r_def,3.0_r_def,3.0_r_def,2.0_r_def,4.0_r_def,1.0_r_def,1.0_r_def /)

    stencil_map_w3(1,1:9) = (/ 1,2,3,4,5,6,7,8,9 /)

    ! The resulting stencil map for W2 determined by the above cell orientation values
    stencil_map_W2(1:4,1) = (/ 1,2,3,4 /)
    stencil_map_W2(1:4,2) = (/ 5,1,6,7 /)
    stencil_map_W2(1:4,3) = (/ 7,11,12,13 /)
    stencil_map_W2(1:4,4) = (/ 17,18,19,12 /)
    stencil_map_W2(1:4,5) = (/ 23,24,18,25 /)
    stencil_map_W2(1:4,6) = (/ 8,3,9,10 /)
    stencil_map_W2(1:4,7) = (/ 14,15,10,16 /)
    stencil_map_W2(1:4,8) = (/ 20,21,22,14 /)
    stencil_map_W2(1:4,9) = (/ 21,26,27,28 /)

    ! Corresponding linearly varying wind field
    u_field(:)  = 0.0_r_def
    u_field(23) = 0.11_r_def
    u_field(18) = 0.12_r_def
    u_field(12) = 0.13_r_def
    u_field(7)  = 0.14_r_def
    u_field(1)  = 0.15_r_def
    u_field(3)  = 0.16_r_def
    u_field(10) = 0.17_r_def
    u_field(14) = 0.18_r_def
    u_field(21) = 0.19_r_def
    u_field(27) = 0.20_r_def


    dep_pts(:) = 0.0_r_def
    call calc_departure_point_code( nlayers,                       &
                                    dep_pts,                       &
                                    departure_pt_stencil_length,   &
                                    n_dep_pt_iterations,           &
                                    real(dt, r_def),               &
                                    undf_w2,                       &
                                    ndf_w2,                        &
                                    stencil_map_W2,                &
                                    undf_w3,                       &
                                    ndf_w3,                        &
                                    stencil_map_w3,                &
                                    cell_orientation,              &
                                    u_field,                       &
                                    u_field,                       &
                                    x_direction,                   &
                                    method_euler )
    @assertEqual(1.5_r_def, dep_pts(1), tol)
    @assertEqual(0.0_r_def, dep_pts(2), tol)
    @assertEqual(1.6_r_def, dep_pts(3), tol)
    @assertEqual(0.0_r_def, dep_pts(4), tol)

  end subroutine test_all


end module departure_point_kernel_mod_test
