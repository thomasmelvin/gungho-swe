!-----------------------------------------------------------------------------
! (c) Crown copyright 2019 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the scale by detJ kernel
module scale_by_detj_kernel_mod_test

  use constants_mod, only : i_def, r_def
  use pFUnit_Mod
  use get_unit_test_wthetanodal_basis_mod, only : get_w0_wthetanodal_basis, &
                                                  get_w0_wthetanodal_diff_basis


  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: scale_by_detj_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type scale_by_detj_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use finite_element_config_mod, only : cellshape_quadrilateral, &
                                          coord_system_xyz
    use feign_config_mod,          only : feign_finite_element_config

    implicit none

    class(scale_by_detj_test_type), intent(inout) :: this

    call feign_finite_element_config(           &
             cellshape=cellshape_quadrilateral, &
             coord_order=0_i_def,               &
             coord_system=coord_system_xyz,     &
             element_order=0_i_def,             &
             rehabilitate=.true.,               &
             vorticity_in_w1=.false. )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod,        only: final_configuration

    implicit none

    class(scale_by_detj_test_type), intent(inout) :: this

    call final_configuration()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  @Test
  subroutine test_all( this )

    use scale_by_detj_kernel_mod, only : scale_by_detj_code

    implicit none

    class(scale_by_detj_test_type), intent(inout) :: this

    real(kind=r_def), parameter :: tol = 1.0e-9_r_def

    ! Mesh
    integer(kind=i_def), parameter :: nlayers = 2

    ! Scalar Space
    integer(kind=i_def), parameter          :: ndf_ws = 2_i_def
    integer(kind=i_def), parameter          :: undf_ws = nlayers + 1_i_def
    integer(kind=i_def), dimension(ndf_ws)  :: map_ws
    real(kind=r_def),    dimension(undf_ws) :: field
    ! Coordinate Space
    integer(kind=i_def), parameter          :: ndf_wx  = 8_i_def
    integer(kind=i_def), parameter          :: undf_wx = (nlayers + 1_i_def) * 4_i_def
    integer(kind=i_def), dimension(ndf_wx)  :: map_wx
    real(kind=r_def),    dimension(undf_wx) :: x, y, z

    integer(kind=i_def), parameter          :: ndf_w3 = 1_i_def
    integer(kind=i_def), parameter          :: undf_w3 = nlayers
    integer(kind=i_def), dimension(ndf_w3)  :: map_w3
    real(kind=r_def),    dimension(undf_w3) :: panel_id


    real(kind=r_def), allocatable :: diff_basis_wx(:,:,:)
    real(kind=r_def), allocatable :: basis_wx(:,:,:)

    real(kind=r_def), parameter              :: dx = 10.0_r_def
    real(kind=r_def), parameter              :: dy = 5.0_r_def
    real(kind=r_def), dimension(0:nlayers)   :: r
    real(kind=r_def), dimension(0:nlayers-1) :: vol

    integer(kind=i_def)                   :: k, df, d
    real(kind=r_def), dimension(ndf_ws,3) :: nodes
    real(kind=r_def), dimension(3)        :: f1, f2
    real(kind=r_def), dimension(undf_ws)  :: answer

    map_ws = (/ 1, 2 /)
    map_w3 = (/ 1 /)
    map_wx = (/ 1, 4, 7, 10, 2, 5, 8, 11 /)

    ! Set variable vertical resolution
    r(0) = 0.0_r_def
    do k = 1,nlayers
      r(k) = r(k-1) + real(k,r_def)
    end do

    ! Compute the coordinate fields
    x = 0.0_r_def
    y = 0.0_r_def
    z = 0.0_r_def
    do k = 0,nlayers-1
      x(map_wx(2)+k) = dx
      x(map_wx(3)+k) = dx
      x(map_wx(6)+k) = dx
      x(map_wx(7)+k) = dx
      y(map_wx(3)+k) = dy
      y(map_wx(4)+k) = dy
      y(map_wx(7)+k) = dy
      y(map_wx(8)+k) = dy
      do df = 1,4
        z(map_wx(df)+k)   = r(k)
        z(map_wx(df+4)+k) = r(k+1)
      end do
      vol(k) = dx*dy*(r(k+1)-r(k))
    end do

    panel_id(:) = 1.0_r_def

    call get_w0_wthetanodal_basis( basis_wx )
    call get_w0_wthetanodal_diff_basis( diff_basis_wx )

    ! Set some values for the initial field
    do df = 1, undf_ws
      field(df) = real(df,r_def)
    end do

    answer(1) = field(1)/vol(0)
    do k = 1,nlayers-1
      answer(k+1) = 2.0_r_def*field(k+1)/(vol(k-1)+vol(k))
    end do
    answer(nlayers+1) = field(nlayers+1)/vol(nlayers-1)

    call scale_by_detj_code(nlayers,                 &
                            field,                   &
                            x, y, z, panel_id,       &
                            ndf_ws, undf_ws, map_ws, &
                            ndf_wx, undf_wx, map_wx, &
                            basis_wx, diff_basis_wx, &
                            ndf_w3, undf_w3, map_w3  &
                            )

    @assertEqual(answer,field, tol)

  end subroutine test_all

end module scale_by_detj_kernel_mod_test
