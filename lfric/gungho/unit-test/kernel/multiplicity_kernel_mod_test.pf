!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

module multiplicity_kernel_mod_test

  use constants_mod,                 only : i_def, r_def

  use get_unit_test_m3x3_q3x3x3_sizes_mod, only : get_w1_m3x3_q3x3x3_size, &
                                                  get_w2_m3x3_q3x3x3_size

  use get_unit_test_m3x3_dofmap_mod,       only : get_w1_m3x3_dofmap, &
                                                  get_w2_m3x3_dofmap

  use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: multiplicity_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type multiplicity_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(multiplicity_test_type), intent(inout) :: this

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(multiplicity_test_type), intent(inout) :: this

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( this )

    use multiplicity_kernel_mod, only : multiplicity_code

    implicit none

    class(multiplicity_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-12_r_def

    ! Fields
    real(r_def), allocatable :: field(:)

    real(r_def) :: answer

    integer(i_def) :: df, cell
    integer(i_def) :: err

    ! Sizes
    integer(i_def)          :: nlayers, ncells, nqp_h, nqp_v
    integer(i_def)          :: ndf, undf
    integer(i_def)          :: dim_space, dim_space_diff

    ! Dofmap
    integer(i_def), allocatable :: map_field(:,:)

    nlayers = 3

    ! Test multiplicity computation for lowest order W1 field

    call get_w1_m3x3_q3x3x3_size( ndf, undf, ncells,         &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v,              &
                                  nlayers )
    call get_w1_m3x3_dofmap(map_field)

    allocate( field(undf) )
    field(:) = 0

    do cell = 1, ncells

      call multiplicity_code(nlayers,           &
                             field,             &
                             ndf,               &
                             undf,              &
                             map_field(:, cell) &
                             )
    end do
    cell = 1
    ! Check edges at bottom of first layer. Each is visited by 2 neighbours
    answer = 2.0_r_def
    do df = 1,4
      @assertEqual(answer, field(map_field(df, cell) ), tol)
    end do
    ! Other edges are visited by either 4 cells on first level or 2 cells on
    ! first level plus 2 cells on second level.
    answer = 4.0_r_def
    do df = 5,12
      @assertEqual(answer, field(map_field(df, cell) ), tol)
    end do

    deallocate( field )
    deallocate( map_field)

    ! Test multiplicity computation for lowest order W2 field

    call get_w2_m3x3_q3x3x3_size( ndf, undf, ncells,         &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v,              &
                                  nlayers )
    call get_w2_m3x3_dofmap(map_field)

    allocate( field(undf) )
    field(:) = 0

    do cell = 1, ncells

      call multiplicity_code(nlayers,           &
                             field,             &
                             ndf,               &
                             undf,              &
                             map_field(:, cell) &
                             )
    end do
    cell = 1

    ! Check side faces of first layer
    answer = 2.0_r_def
    do df = 1,4
      @assertEqual(answer, field(map_field(df, cell) ), tol)
    end do

    ! Check bottom of first layer (visited by cell in first layer only)
    answer = 1.0_r_def
    @assertEqual(answer, field(map_field(5, cell) ), tol)
    ! Check top of first layer (visited by cell in first and second layer)
    answer = 2.0_r_def
    @assertEqual(answer, field(map_field(6, cell) ), tol)

    deallocate( field )
    deallocate( map_field)

  end subroutine test_all

end module multiplicity_kernel_mod_test
