!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!> Test the Wtheta mass matrix computation
!>
module compute_mass_matrix_kernel_wtheta_mod_test

  use constants_mod,                       only : i_def, r_def, r_single, r_double

  use get_unit_test_m3x3_q3x3x3_sizes_mod, only : get_w0_m3x3_q3x3x3_size,     &
                                                  get_wtheta_m3x3_q3x3x3_size, &
                                                  get_w3_m3x3_q3x3x3_size
  use get_unit_test_m3x3_dofmap_mod,       only : get_w0_m3x3_dofmap,          &
                                                  get_w3_m3x3_dofmap
  use get_unit_test_q3x3x3_basis_mod,      only : get_w0_q3x3x3_diff_basis,    &
                                                  get_w0_q3x3x3_basis,         &
                                                  get_wtheta_q3x3x3_basis
  use get_unit_test_q3x3x3_quadrature_mod, only : &
                                    get_gaussian_q3x3x3_quadrature_weights_xy, &
                                    get_gaussian_q3x3x3_quadrature_weights_z
  use get_unit_test_3x3x3_chi_mod,         only : get_w0_3x3x3_field
  use pFUnit_Mod

  implicit none

  private
  public :: test_r_single, test_mixed_precision, test_r_double

  @TestCase
  type, extends(TestCase), public :: compute_mass_matrix_wtheta_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_r_single
    procedure test_mixed_precision
    procedure test_r_double
  end type compute_mass_matrix_wtheta_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use finite_element_config_mod, only : cellshape_quadrilateral, &
                                          coord_system_xyz
    use feign_config_mod,          only : feign_finite_element_config

    implicit none

    class(compute_mass_matrix_wtheta_test_type), intent(inout) :: this

    call feign_finite_element_config( &
             cellshape              = cellshape_quadrilateral,    &
             coord_order            = 0_i_def,                    &
             coord_system           = coord_system_xyz,           &
             element_order          = 0_i_def,                    &
             rehabilitate           = .true.,                     &
             vorticity_in_w1        = .false. )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod,        only: final_configuration

    implicit none

    class(compute_mass_matrix_wtheta_test_type), intent(inout) :: this

    call final_configuration()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! TEST R_SINGLE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  @Test
  subroutine test_r_single( this )

    use compute_mass_matrix_kernel_w_scalar_mod, only : &
                                 compute_mass_matrix_w_scalar_code

    implicit none

    class(compute_mass_matrix_wtheta_test_type), intent(inout) :: this

    real(r_def),    parameter :: dx = 6000.0_r_def, &
                                 dy = 1000.0_r_def, &
                                 dz = 2000.0_r_def
    integer(i_def), parameter :: nlayers = 3_i_def
    real(r_single), parameter :: tol = 1.0e-6_r_single
    real(r_single)            :: answer

    ! Required for calling mass matrix kernel
    integer(i_def) :: ncells, ncell_3d, cell
    integer(i_def) :: ndf_wtheta, undf_wtheta
    integer(i_def) :: ndf_w0, undf_w0
    integer(i_def) :: ndf_pid, undf_pid
    integer(i_def) :: dim_space, dim_space_diff
    integer(i_def) :: nqp_h, nqp_v

    integer(i_def), allocatable :: map_w0(:,:), map_pid(:,:)
    real(r_single), allocatable :: local_stencil_r32(:,:,:)

    ! Canned test data is kept as r_def
    real(r_def),    allocatable :: chi1(:), chi2(:), chi3(:)
    real(r_def),    allocatable :: panel_id(:)
    real(r_def),    allocatable :: diff_basis_w0(:,:,:,:)
    real(r_def),    allocatable :: basis_w0(:,:,:,:)
    real(r_def),    allocatable :: basis_wtheta(:,:,:,:)
    real(r_def),    allocatable :: wh(:), wv(:)

    ! Coerced versions of canned data
    real(r_single), allocatable :: chi1_r32(:), chi2_r32(:), chi3_r32(:)
    real(r_single), allocatable :: panel_id_r32(:)
    real(r_single), allocatable :: basis_wtheta_r32(:,:,:,:)
    real(r_single), allocatable :: basis_w0_r32(:,:,:,:)
    real(r_single), allocatable :: diff_basis_w0_r32(:,:,:,:)
    real(r_single), allocatable :: wh_r32(:), wv_r32(:)


   ! Get pre-set test data (in i_def and r_def)
    call get_w0_m3x3_q3x3x3_size( ndf_w0, undf_w0, ncells, &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v, nlayers )
    call get_wtheta_m3x3_q3x3x3_size( ndf_wtheta, undf_wtheta, ncells, &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v, nlayers )
    call get_w3_m3x3_q3x3x3_size( ndf_pid, undf_pid, ncells, &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v, 1 )
    call get_w0_m3x3_dofmap(map_w0)
    call get_w3_m3x3_dofmap(map_pid, 1)
    call get_w0_q3x3x3_basis(basis_w0)
    call get_w0_q3x3x3_diff_basis(diff_basis_w0)
    call get_wtheta_q3x3x3_basis(basis_wtheta)
    call get_gaussian_q3x3x3_quadrature_weights_xy(wh)
    call get_gaussian_q3x3x3_quadrature_weights_z(wv)

    ! Compute coordinates
    allocate(chi1(undf_w0))
    allocate(chi2(undf_w0))
    allocate(chi3(undf_w0))
    allocate(panel_id(undf_pid))

    panel_id(:) = 1.0_r_def

    call get_w0_3x3x3_field(chi1, chi2, chi3, dx, dy, dz, &
                            map_w0, nlayers)

    ! Coerce test data into required word size
    basis_wtheta_r32  = real( basis_wtheta,  kind=r_single )
    basis_w0_r32      = real( basis_w0,      kind=r_single )
    diff_basis_w0_r32 = real( diff_basis_w0, kind=r_single )
    wh_r32            = real( wh,            kind=r_single )
    wv_r32            = real( wv,            kind=r_single )
    chi1_r32          = real( chi1,          kind=r_single )
    chi2_r32          = real( chi2,          kind=r_single )
    chi3_r32          = real( chi3,          kind=r_single )
    panel_id_r32      = real( panel_id,      kind=r_single )

    ! Test Wtheta mass matrix kernel
    cell = 1
    ncell_3d = ncells*nlayers
    allocate(local_stencil_r32(ndf_wtheta, ndf_wtheta, ncell_3d))
    local_stencil_r32(:,:,:) = 0.0_r_single

    call compute_mass_matrix_w_scalar_code( &
                                      cell,                      &
                                      nlayers,                   &
                                      ncell_3d,                  &
                                      local_stencil_r32,         &
                                      chi1_r32,                  &
                                      chi2_r32,                  &
                                      chi3_r32,                  &
                                      panel_id_r32,              &
                                      ndf_wtheta,                &
                                      basis_wtheta_r32,          &
                                      ndf_w0,                    &
                                      undf_w0,                   &
                                      map_w0(:,cell),            &
                                      basis_w0_r32,              &
                                      diff_basis_w0_r32,         &
                                      ndf_pid,                   &
                                      undf_pid,                  &
                                      map_pid(:,cell),           &
                                      nqp_h,                     &
                                      nqp_v,                     &
                                      wh_r32,                    &
                                      wv_r32                     &
                                             )

    answer = (1.0_r_single/3.0_r_single)
    @assertEqual(answer, local_stencil_r32(1, 1, 1 )/real((dx*dy*dz), r_single), tol)
    answer = (1.0_r_single/6.0_r_single)
    @assertEqual(answer, local_stencil_r32(1, 2, 1 )/real((dx*dy*dz), r_single), tol)

    answer = (1.0_r_single/3.0_r_single)
    @assertEqual(answer, local_stencil_r32(1, 1, 2 )/real((dx*dy*dz), r_single), tol)
    answer = (1.0_r_single/6.0_r_single)
    @assertEqual(answer, local_stencil_r32(1, 2, 2 )/real((dx*dy*dz), r_single), tol)

    deallocate(map_w0)
    deallocate(diff_basis_w0, diff_basis_w0_r32)
    deallocate(basis_w0,      basis_w0_r32)
    deallocate(basis_wtheta,  basis_wtheta_r32)
    deallocate(wh,   wh_r32)
    deallocate(wv,   wv_r32)
    deallocate(chi1, chi1_r32)
    deallocate(chi2, chi2_r32)
    deallocate(chi3, chi3_r32)
    deallocate(local_stencil_r32)
    deallocate(panel_id)
    deallocate(map_pid)

  end subroutine test_r_single


  !!!!!!!!!!!!!!!!!!!!!!!!!!! TEST MIXED PRECISION !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_mixed_precision( this )

    use compute_mass_matrix_kernel_w_scalar_mod, only : &
                                compute_mass_matrix_w_scalar_code

    implicit none

    class(compute_mass_matrix_wtheta_test_type), intent(inout) :: this

    real(r_def),    parameter :: dx = 6000.0_r_def, &
                                 dy = 1000.0_r_def, &
                                 dz = 2000.0_r_def
    integer(i_def), parameter :: nlayers = 3_i_def
    real(r_single), parameter :: tol = 1.0e-6_r_single
    real(r_single)            :: answer

    ! Required for calling mass matrix kernel
    integer(i_def) :: ncells, ncell_3d, cell
    integer(i_def) :: ndf_wtheta, undf_wtheta
    integer(i_def) :: ndf_w0, undf_w0
    integer(i_def) :: ndf_pid, undf_pid
    integer(i_def) :: dim_space, dim_space_diff
    integer(i_def) :: nqp_h, nqp_v

    integer(i_def), allocatable :: map_w0(:,:), map_pid(:,:)
    real(r_single), allocatable :: local_stencil_r32(:,:,:)

    ! Canned test data is kept as r_def
    real(r_def),    allocatable :: chi1(:), chi2(:), chi3(:)
    real(r_def),    allocatable :: panel_id(:)
    real(r_def),    allocatable :: diff_basis_w0(:,:,:,:)
    real(r_def),    allocatable :: basis_w0(:,:,:,:)
    real(r_def),    allocatable :: basis_wtheta(:,:,:,:)
    real(r_def),    allocatable :: wh(:), wv(:)

    ! Coerced versions of canned data
    real(r_double), allocatable :: chi1_r64(:), chi2_r64(:), chi3_r64(:)
    real(r_double), allocatable :: panel_id_r64(:)
    real(r_double), allocatable :: basis_wtheta_r64(:,:,:,:)
    real(r_double), allocatable :: basis_w0_r64(:,:,:,:)
    real(r_double), allocatable :: diff_basis_w0_r64(:,:,:,:)
    real(r_double), allocatable :: wh_r64(:), wv_r64(:)


   ! Get pre-set test data (in i_def and r_def)
    call get_w0_m3x3_q3x3x3_size( ndf_w0, undf_w0, ncells, &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v, nlayers )
    call get_wtheta_m3x3_q3x3x3_size( ndf_wtheta, undf_wtheta, ncells, &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v, nlayers )
    call get_w3_m3x3_q3x3x3_size( ndf_pid, undf_pid, ncells, &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v, 1 )
    call get_w0_m3x3_dofmap(map_w0)
    call get_w3_m3x3_dofmap(map_pid, 1)
    call get_w0_q3x3x3_basis(basis_w0)
    call get_w0_q3x3x3_diff_basis(diff_basis_w0)
    call get_wtheta_q3x3x3_basis(basis_wtheta)
    call get_gaussian_q3x3x3_quadrature_weights_xy(wh)
    call get_gaussian_q3x3x3_quadrature_weights_z(wv)

    ! Compute coordinates
    allocate(chi1(undf_w0))
    allocate(chi2(undf_w0))
    allocate(chi3(undf_w0))
    allocate(panel_id(undf_pid))

    panel_id(:) = 1.0_r_def

    call get_w0_3x3x3_field(chi1, chi2, chi3, dx, dy, dz, &
                            map_w0, nlayers)

    ! Coerce test data into required word size
    basis_wtheta_r64  = real( basis_wtheta,  kind=r_double )
    basis_w0_r64      = real( basis_w0,      kind=r_double )
    diff_basis_w0_r64 = real( diff_basis_w0, kind=r_double )
    wh_r64            = real( wh,            kind=r_double )
    wv_r64            = real( wv,            kind=r_double )
    chi1_r64          = real( chi1,          kind=r_double )
    chi2_r64          = real( chi2,          kind=r_double )
    chi3_r64          = real( chi3,          kind=r_double )
    panel_id_r64      = real( panel_id,      kind=r_double )

    ! Test Wtheta mass matrix kernel
    cell = 1
    ncell_3d = ncells*nlayers
    allocate(local_stencil_r32(ndf_wtheta, ndf_wtheta, ncell_3d))
    local_stencil_r32(:,:,:) = 0.0_r_single

    call compute_mass_matrix_w_scalar_code( &
                                      cell,                      &
                                      nlayers,                   &
                                      ncell_3d,                  &
                                      local_stencil_r32,         &
                                      chi1_r64,                  &
                                      chi2_r64,                  &
                                      chi3_r64,                  &
                                      panel_id_r64,              &
                                      ndf_wtheta,                &
                                      basis_wtheta_r64,          &
                                      ndf_w0,                    &
                                      undf_w0,                   &
                                      map_w0(:,cell),            &
                                      basis_w0_r64,              &
                                      diff_basis_w0_r64,         &
                                      ndf_pid,                   &
                                      undf_pid,                  &
                                      map_pid(:,cell),           &
                                      nqp_h,                     &
                                      nqp_v,                     &
                                      wh_r64,                    &
                                      wv_r64                     &
                                             )

    answer = (1.0_r_single/3.0_r_single)
    @assertEqual(answer, local_stencil_r32(1, 1, 1 )/real((dx*dy*dz), r_single), tol)
    answer = (1.0_r_single/6.0_r_single)
    @assertEqual(answer, local_stencil_r32(1, 2, 1 )/real((dx*dy*dz), r_single), tol)

    answer = (1.0_r_single/3.0_r_single)
    @assertEqual(answer, local_stencil_r32(1, 1, 2 )/real((dx*dy*dz), r_single), tol)
    answer = (1.0_r_single/6.0_r_single)
    @assertEqual(answer, local_stencil_r32(1, 2, 2 )/real((dx*dy*dz), r_single), tol)

    deallocate(map_w0)
    deallocate(diff_basis_w0, diff_basis_w0_r64)
    deallocate(basis_w0,      basis_w0_r64)
    deallocate(basis_wtheta,  basis_wtheta_r64)
    deallocate(wh,   wh_r64)
    deallocate(wv,   wv_r64)
    deallocate(chi1, chi1_r64)
    deallocate(chi2, chi2_r64)
    deallocate(chi3, chi3_r64)
    deallocate(local_stencil_r32)
    deallocate(panel_id)
    deallocate(map_pid)

  end subroutine test_mixed_precision


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! TEST R_DOUBLE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_r_double( this )

    use compute_mass_matrix_kernel_w_scalar_mod, only : &
                                compute_mass_matrix_w_scalar_code

    implicit none

    class(compute_mass_matrix_wtheta_test_type), intent(inout) :: this

    real(r_def),    parameter :: dx = 6000.0_r_def, &
                                 dy = 1000.0_r_def, &
                                 dz = 2000.0_r_def
    integer(i_def), parameter :: nlayers = 3_i_def
    real(r_double), parameter :: tol = 1.0e-6_r_double
    real(r_double)            :: answer

    ! Required for calling mass matrix kernel
    integer(i_def) :: ncells, ncell_3d, cell
    integer(i_def) :: ndf_wtheta, undf_wtheta
    integer(i_def) :: ndf_w0, undf_w0
    integer(i_def) :: ndf_pid, undf_pid
    integer(i_def) :: dim_space, dim_space_diff
    integer(i_def) :: nqp_h, nqp_v

    integer(i_def), allocatable :: map_w0(:,:), map_pid(:,:)
    real(r_double), allocatable :: local_stencil_r64(:,:,:)

    ! Canned test data is kept as r_def
    real(r_def),    allocatable :: chi1(:), chi2(:), chi3(:)
    real(r_def),    allocatable :: panel_id(:)
    real(r_def),    allocatable :: diff_basis_w0(:,:,:,:)
    real(r_def),    allocatable :: basis_w0(:,:,:,:)
    real(r_def),    allocatable :: basis_wtheta(:,:,:,:)
    real(r_def),    allocatable :: wh(:), wv(:)

    ! Coerced versions of canned data
    real(r_double), allocatable :: chi1_r64(:), chi2_r64(:), chi3_r64(:)
    real(r_double), allocatable :: panel_id_r64(:)
    real(r_double), allocatable :: basis_wtheta_r64(:,:,:,:)
    real(r_double), allocatable :: basis_w0_r64(:,:,:,:)
    real(r_double), allocatable :: diff_basis_w0_r64(:,:,:,:)
    real(r_double), allocatable :: wh_r64(:), wv_r64(:)


   ! Get pre-set test data (in i_def and r_def)
    call get_w0_m3x3_q3x3x3_size( ndf_w0, undf_w0, ncells, &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v, nlayers )
    call get_wtheta_m3x3_q3x3x3_size( ndf_wtheta, undf_wtheta, ncells, &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v, nlayers )
    call get_w3_m3x3_q3x3x3_size( ndf_pid, undf_pid, ncells, &
                                  dim_space, dim_space_diff, &
                                  nqp_h, nqp_v, 1 )
    call get_w0_m3x3_dofmap(map_w0)
    call get_w3_m3x3_dofmap(map_pid, 1)
    call get_w0_q3x3x3_basis(basis_w0)
    call get_w0_q3x3x3_diff_basis(diff_basis_w0)
    call get_wtheta_q3x3x3_basis(basis_wtheta)
    call get_gaussian_q3x3x3_quadrature_weights_xy(wh)
    call get_gaussian_q3x3x3_quadrature_weights_z(wv)

    ! Compute coordinates
    allocate(chi1(undf_w0))
    allocate(chi2(undf_w0))
    allocate(chi3(undf_w0))
    allocate(panel_id(undf_pid))

    panel_id(:) = 1.0_r_def

    call get_w0_3x3x3_field(chi1, chi2, chi3, dx, dy, dz, &
                            map_w0, nlayers)

    ! Coerce test data into required word size
    basis_wtheta_r64  = real( basis_wtheta,  kind=r_double )
    basis_w0_r64      = real( basis_w0,      kind=r_double )
    diff_basis_w0_r64 = real( diff_basis_w0, kind=r_double )
    wh_r64            = real( wh,            kind=r_double )
    wv_r64            = real( wv,            kind=r_double )
    chi1_r64          = real( chi1,          kind=r_double )
    chi2_r64          = real( chi2,          kind=r_double )
    chi3_r64          = real( chi3,          kind=r_double )
    panel_id_r64      = real( panel_id,      kind=r_double )

    ! Test Wtheta mass matrix kernel
    cell = 1
    ncell_3d = ncells*nlayers
    allocate(local_stencil_r64(ndf_wtheta, ndf_wtheta, ncell_3d))
    local_stencil_r64(:,:,:) = 0.0_r_double

    call compute_mass_matrix_w_scalar_code( &
                                      cell,                      &
                                      nlayers,                   &
                                      ncell_3d,                  &
                                      local_stencil_r64,         &
                                      chi1_r64,                  &
                                      chi2_r64,                  &
                                      chi3_r64,                  &
                                      panel_id_r64,              &
                                      ndf_wtheta,                &
                                      basis_wtheta_r64,          &
                                      ndf_w0,                    &
                                      undf_w0,                   &
                                      map_w0(:,cell),            &
                                      basis_w0_r64,              &
                                      diff_basis_w0_r64,         &
                                      ndf_pid,                   &
                                      undf_pid,                  &
                                      map_pid(:,cell),           &
                                      nqp_h,                     &
                                      nqp_v,                     &
                                      wh_r64,                    &
                                      wv_r64                     &
                                             )

    answer = (1.0_r_double/3.0_r_double)
    @assertEqual(answer, local_stencil_r64(1, 1, 1 )/real((dx*dy*dz), r_double), tol)
    answer = (1.0_r_double/6.0_r_double)
    @assertEqual(answer, local_stencil_r64(1, 2, 1 )/real((dx*dy*dz), r_double), tol)

    answer = (1.0_r_double/3.0_r_double)
    @assertEqual(answer, local_stencil_r64(1, 1, 2 )/real((dx*dy*dz), r_double), tol)
    answer = (1.0_r_double/6.0_r_double)
    @assertEqual(answer, local_stencil_r64(1, 2, 2 )/real((dx*dy*dz), r_double), tol)

    deallocate(map_w0)
    deallocate(diff_basis_w0, diff_basis_w0_r64)
    deallocate(basis_w0,      basis_w0_r64)
    deallocate(basis_wtheta,  basis_wtheta_r64)
    deallocate(wh,   wh_r64)
    deallocate(wv,   wv_r64)
    deallocate(chi1, chi1_r64)
    deallocate(chi2, chi2_r64)
    deallocate(chi3, chi3_r64)
    deallocate(local_stencil_r64)
    deallocate(panel_id)
    deallocate(map_pid)

  end subroutine test_r_double

end module compute_mass_matrix_kernel_wtheta_mod_test
