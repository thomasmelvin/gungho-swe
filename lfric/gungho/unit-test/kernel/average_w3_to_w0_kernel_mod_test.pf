!-----------------------------------------------------------------------
! (C) Crown copyright 2020 Met Office. All rights reserved.
! For further details please refer to the file COPYRIGHT.txt
! which you should have received as part of this distribution.
!-----------------------------------------------------------------------
module average_w3_to_w0_kernel_mod_test

  use constants_mod,                       only : i_def, r_def

  use get_unit_test_m3x3_q3x3x3_sizes_mod, only : get_w0_m3x3_q3x3x3_size, &
                                                  get_w3_m3x3_q3x3x3_size

  use get_unit_test_m3x3_dofmap_mod,       only : get_w0_m3x3_dofmap, &
                                                  get_w3_m3x3_dofmap

  use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: average_w3_to_w0_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type average_w3_to_w0_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(average_w3_to_w0_test_type), intent(inout) :: this

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(average_w3_to_w0_test_type), intent(inout) :: this

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( this )

    use average_w3_to_w0_kernel_mod, only : average_w3_to_w0_code

    implicit none

    class(average_w3_to_w0_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-12_r_def

    ! Fields
    real(r_def), allocatable :: srf_alt_w3(:)
    real(r_def), allocatable :: srf_alt_w0(:)
    real(r_def), allocatable :: multipl_w0(:)

    real(r_def) :: answer

    integer(i_def) :: df, cell
    integer(i_def) :: err

    ! Sizes
    integer(i_def)          :: nlayers, ncells, nqp_h, nqp_v
    integer(i_def)          :: ndf_w0, undf_w0
    integer(i_def)          :: dim_space_w0, dim_space_diff_w0
    integer(i_def)          :: ndf_w3, undf_w3
    integer(i_def)          :: dim_space_w3, dim_space_diff_w3

    ! Dofmap
    integer(i_def), allocatable :: map_w0(:,:)
    integer(i_def), allocatable :: map_w3(:,:)

    ! kernel targets single layer fields
    nlayers = 1

    call get_w0_m3x3_q3x3x3_size( ndf_w0, undf_w0, ncells,         &
                                  dim_space_w0, dim_space_diff_w0, &
                                  nqp_h, nqp_v,              &
                                  nlayers )
    call get_w0_m3x3_dofmap(map_w0, nlayers)

    call get_w3_m3x3_q3x3x3_size( ndf_w3, undf_w3, ncells,         &
                                  dim_space_w3, dim_space_diff_w3, &
                                  nqp_h, nqp_v,              &
                                  nlayers )
    call get_w3_m3x3_dofmap(map_w3, nlayers)

    allocate( srf_alt_w3(undf_w3) )
    allocate( srf_alt_w0(undf_w0) )
    allocate( multipl_w0(undf_w0) )

    srf_alt_w0(:)=0.0_r_def
    ! Each node has 4 neighbours
    multipl_w0(:)=4.0_r_def

    ! Set a single mountain in the middle of the domain
    srf_alt_w3(:)=0.0_r_def
    srf_alt_w3(5)=1.0_r_def
    do cell = 1, ncells

      call average_w3_to_w0_code(nlayers,        &
                                 srf_alt_w0,      &
                                 srf_alt_w3,      &
                                 multipl_w0,      &
                                 ndf_w0,          &
                                 undf_w0,         &
                                 map_w0(:, cell), &
                                 ndf_w3,          &
                                 undf_w3,         &
                                 map_w3(:, cell)  &
                                 )
    end do

    cell = 5
    answer = 1.0_r_def/4.0_r_def
    do df = 1,4
      @assertEqual(answer, srf_alt_w0(map_w0(df, cell) ), tol)
    end do

    cell = 3
    answer = 0.0_r_def
    do df = 1,3
      @assertEqual(answer, srf_alt_w0(map_w0(df, cell) ), tol)
    end do
    df=4
    answer = 1.0_r_def/4.0_r_def
    @assertEqual(answer, srf_alt_w0(map_w0(df, cell) ), tol)

    deallocate( srf_alt_w3 )
    deallocate( srf_alt_w0 )
    deallocate( multipl_w0 )
    deallocate( map_w0 )
    deallocate( map_w3 )


  end subroutine test_all

end module average_w3_to_w0_kernel_mod_test
