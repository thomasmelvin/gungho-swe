!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
!> @brief Test the functionality of cosmic_flux_mod

module cosmic_flux_mod_test
  implicit none

contains

  @test
  subroutine frac_and_int_part_test()
    use pFUnit_Mod
    use constants_mod, only: r_def
    use cosmic_flux_mod, only : frac_and_int_part

    implicit none

    real(kind=r_def) :: x_value, frac_x, tol
    integer          :: int_x

    tol = 1.0e-6_r_def
    x_value = -3.4_r_def
    call frac_and_int_part(x_value,int_x,frac_x)
    @assertEqual(4, int_x)
    @assertEqual(0.4_r_def, frac_x, tol)

    x_value = 3.4_r_def
    call frac_and_int_part(x_value,int_x,frac_x)
    @assertEqual(4, int_x)
    @assertEqual(0.4_r_def, frac_x, tol)

  end subroutine frac_and_int_part_test


  @test
  subroutine populate_array_test()
    use pFUnit_Mod
    use constants_mod, only: r_def
    use cosmic_flux_mod, only : populate_array

    implicit none

    real(kind=r_def) :: departure_dist
    integer          :: edge_option, nCells
    integer, allocatable :: index_array(:)

    nCells = 4

    allocate(index_array(1:nCells))

    departure_dist = 3.4_r_def
    edge_option = 0
    call populate_array(ncells,index_array,departure_dist, edge_option)
    @assertEqual(-1, index_array(1))
    @assertEqual(-2, index_array(2))
    @assertEqual(-3, index_array(3))
    @assertEqual(-4, index_array(4))

    edge_option = 1
    call populate_array(ncells,index_array,departure_dist, edge_option)
    @assertEqual(0, index_array(1))
    @assertEqual(-1, index_array(2))
    @assertEqual(-2, index_array(3))
    @assertEqual(-3, index_array(4))

    departure_dist = -3.4
    edge_option = 0
    call populate_array(ncells,index_array,departure_dist, edge_option)
    @assertEqual(0, index_array(1))
    @assertEqual(1, index_array(2))
    @assertEqual(2, index_array(3))
    @assertEqual(3, index_array(4))

    edge_option = 1
    call populate_array(ncells,index_array,departure_dist, edge_option)
    @assertEqual(1, index_array(1))
    @assertEqual(2, index_array(2))
    @assertEqual(3, index_array(3))
    @assertEqual(4, index_array(4))

    deallocate(index_array)

  end subroutine populate_array_test


  @test
  subroutine calc_integration_limits_test()
    use pFUnit_Mod
    use constants_mod, only: r_def
    use cosmic_flux_mod, only : calc_integration_limits

    implicit none

    real(kind=r_def) :: departure_dist
    real(kind=r_def) :: frac_x
    real(kind=r_def) :: x_left_limit
    real(kind=r_def) :: x_right_limit
    real(kind=r_def) :: tol

    departure_dist = 3.4_r_def
    frac_x = 0.4_r_def
    tol = 1.0e-6_r_def
    call calc_integration_limits(departure_dist,frac_x,x_left_limit,x_right_limit)
    @assertEqual(0.6_r_def, x_left_limit,tol)
    @assertEqual(1.0_r_def, x_right_limit,tol)

    departure_dist = -3.4_r_def
    frac_x = 0.4_r_def
    call calc_integration_limits(departure_dist,frac_x,x_left_limit,x_right_limit)
    @assertEqual(0.0_r_def, x_left_limit,tol)
    @assertEqual(0.4_r_def, x_right_limit,tol)

  end subroutine calc_integration_limits_test


  @test
  subroutine map_cell_index_test()
    use pFUnit_Mod
    use cosmic_flux_mod, only : map_cell_index

    implicit none

    integer :: cell_index, ii, stencil_length

    stencil_length = 9

    ii = -4
    cell_index = map_cell_index(ii,stencil_length)
    @assertEqual(1, cell_index)

    ii = -3
    cell_index = map_cell_index(ii,stencil_length)
    @assertEqual(2, cell_index)

    ii = -2
    cell_index = map_cell_index(ii,stencil_length)
    @assertEqual(3, cell_index)

    ii = 1
    cell_index = map_cell_index(ii,stencil_length)
    @assertEqual(6, cell_index)

    ii = 4
    cell_index = map_cell_index(ii,stencil_length)
    @assertEqual(9, cell_index)

  end subroutine map_cell_index_test


  @test
  subroutine return_part_mass_test()
    use pFUnit_Mod
    use constants_mod, only: r_def
    use cosmic_flux_mod, only : return_part_mass

    implicit none

    real(kind=r_def) :: x_left_limit, x_right_limit, part_mass, tol
    real(kind=r_def), allocatable :: subgrid_coeffs(:)
    integer :: n_coeffs

    tol = 1.0e-6_r_def
    n_coeffs = 3
    allocate(subgrid_coeffs(1:n_coeffs))
    subgrid_coeffs = (/ 1.0_r_def,1.0_r_def,1.0_r_def /)

    x_left_limit  = 0.0_r_def
    x_right_limit = 0.5_r_def

    part_mass = return_part_mass(n_coeffs,subgrid_coeffs,x_left_limit,x_right_limit)
    @assertEqual((2.0_r_def/3.0_r_def), part_mass,tol)

    deallocate(subgrid_coeffs)

  end subroutine return_part_mass_test


  @test
  subroutine eval_integral_test()
    use pFUnit_Mod
    use constants_mod, only: r_def
    use cosmic_flux_mod, only : eval_integral

    implicit none

    real(kind=r_def) :: func_at_x, xx, tol
    real(kind=r_def), allocatable :: subgrid_coeffs(:)
    integer :: n_coeffs

    n_coeffs = 3
    allocate(subgrid_coeffs(1:n_coeffs))
    subgrid_coeffs = (/ 1.0_r_def,1.0_r_def,1.0_r_def /)

    xx = 0.5_r_def
    tol = 1.0e-6_r_def

    func_at_x = eval_integral(n_coeffs,subgrid_coeffs,xx)
    @assertEqual((2.0_r_def/3.0_r_def), func_at_x,tol)

    deallocate(subgrid_coeffs)

  end subroutine eval_integral_test


  @test
  subroutine calc_stencil_ordering_test()
    use pFUnit_Mod
    use cosmic_flux_mod, only : calc_stencil_ordering

    implicit none

    integer :: stencil_length
    integer, allocatable :: stencil_order_out(:)

    stencil_length = 9
    allocate(stencil_order_out(1:stencil_length))

    call calc_stencil_ordering(stencil_length,stencil_order_out)

    @assertEqual(5, stencil_order_out(1))
    @assertEqual(4, stencil_order_out(2))
    @assertEqual(3, stencil_order_out(3))
    @assertEqual(2, stencil_order_out(4))
    @assertEqual(1, stencil_order_out(5))
    @assertEqual(6, stencil_order_out(6))
    @assertEqual(7, stencil_order_out(7))
    @assertEqual(8, stencil_order_out(8))
    @assertEqual(9, stencil_order_out(9))

    deallocate(stencil_order_out)

  end subroutine calc_stencil_ordering_test


  @test
  subroutine stencil_ordering_and_orientation_test()
    use pFUnit_Mod
    use cosmic_flux_mod, only : stencil_ordering_and_orientation
    use flux_direction_mod, only : x_direction, y_direction

    implicit none

    integer :: stencil_length
    integer :: orientation
    integer, allocatable :: stencil_order_out(:)

    stencil_length = 9
    allocate(stencil_order_out(1:stencil_length))
    orientation = 1

    call stencil_ordering_and_orientation(stencil_length,orientation,x_direction,stencil_order_out)

    @assertEqual(5, stencil_order_out(1))
    @assertEqual(4, stencil_order_out(2))
    @assertEqual(3, stencil_order_out(3))
    @assertEqual(2, stencil_order_out(4))
    @assertEqual(1, stencil_order_out(5))
    @assertEqual(6, stencil_order_out(6))
    @assertEqual(7, stencil_order_out(7))
    @assertEqual(8, stencil_order_out(8))
    @assertEqual(9, stencil_order_out(9))


    orientation = 4

    call stencil_ordering_and_orientation(stencil_length,orientation,x_direction,stencil_order_out)

    @assertEqual(9, stencil_order_out(1))
    @assertEqual(8, stencil_order_out(2))
    @assertEqual(7, stencil_order_out(3))
    @assertEqual(6, stencil_order_out(4))
    @assertEqual(1, stencil_order_out(5))
    @assertEqual(2, stencil_order_out(6))
    @assertEqual(3, stencil_order_out(7))
    @assertEqual(4, stencil_order_out(8))
    @assertEqual(5, stencil_order_out(9))

    orientation = 1

    call stencil_ordering_and_orientation(stencil_length,orientation,y_direction,stencil_order_out)

    @assertEqual(5, stencil_order_out(1))
    @assertEqual(4, stencil_order_out(2))
    @assertEqual(3, stencil_order_out(3))
    @assertEqual(2, stencil_order_out(4))
    @assertEqual(1, stencil_order_out(5))
    @assertEqual(6, stencil_order_out(6))
    @assertEqual(7, stencil_order_out(7))
    @assertEqual(8, stencil_order_out(8))
    @assertEqual(9, stencil_order_out(9))

    orientation = 2

    call stencil_ordering_and_orientation(stencil_length,orientation,y_direction,stencil_order_out)

    @assertEqual(9, stencil_order_out(1))
    @assertEqual(8, stencil_order_out(2))
    @assertEqual(7, stencil_order_out(3))
    @assertEqual(6, stencil_order_out(4))
    @assertEqual(1, stencil_order_out(5))
    @assertEqual(2, stencil_order_out(6))
    @assertEqual(3, stencil_order_out(7))
    @assertEqual(4, stencil_order_out(8))
    @assertEqual(5, stencil_order_out(9))

    deallocate(stencil_order_out)

  end subroutine stencil_ordering_and_orientation_test


  @test
  subroutine dof_to_update_test()
    use pFUnit_Mod
    use cosmic_flux_mod,    only : dof_to_update
    use flux_direction_mod, only : x_direction, y_direction
    use constants_mod,      only : i_def

    implicit none

    integer(i_def) :: orientation
    integer(i_def) :: w2_dofs(1:2)

    ! If orientation=1 then W2 dofs are arranged in the ordering
    !       4
    !     1   3
    !       2
    ! Hence in the x_direction the dofs are (1,3) and in the y_direction, (2,4)
    orientation = 1
    w2_dofs = dof_to_update(orientation,x_direction)
    @assertEqual(1, w2_dofs(1))
    @assertEqual(3, w2_dofs(2))
    w2_dofs = dof_to_update(orientation,y_direction)
    @assertEqual(2, w2_dofs(1))
    @assertEqual(4, w2_dofs(2))

    ! If orientation=2 then W2 dofs are arranged in the ordering
    !       1
    !     2   4
    !       3
    ! Hence in the x_direction the dofs are (2,4) and in the y_direction, (3,1)
    orientation = 2
    w2_dofs = dof_to_update(orientation,x_direction)
    @assertEqual(2, w2_dofs(1))
    @assertEqual(4, w2_dofs(2))
    w2_dofs = dof_to_update(orientation,y_direction)
    @assertEqual(3, w2_dofs(1))
    @assertEqual(1, w2_dofs(2))

    ! If orientation=3 then W2 dofs are arranged in the ordering
    !       2
    !     3   1
    !       4
    ! Hence in the x_direction the dofs are (3,1) and in the y_direction, (4,2)
    ! Note the reversing of the returned dofs compared to orientation=1
    orientation = 3
    w2_dofs = dof_to_update(orientation,x_direction)
    @assertEqual(3, w2_dofs(1))
    @assertEqual(1, w2_dofs(2))
    w2_dofs = dof_to_update(orientation,y_direction)
    @assertEqual(4, w2_dofs(1))
    @assertEqual(2, w2_dofs(2))

    ! If orientation=4 then W2 dofs are arranged in the ordering
    !       3
    !     4   2
    !       1
    ! Hence in the x_direction the dofs are (4,2) and in the y_direction, (1,3)
    ! Note the reversing of the returned dofs compared to orientation=2
    orientation = 4
    w2_dofs = dof_to_update(orientation,x_direction)
    @assertEqual(4, w2_dofs(1))
    @assertEqual(2, w2_dofs(2))
    w2_dofs = dof_to_update(orientation,y_direction)
    @assertEqual(1, w2_dofs(1))
    @assertEqual(3, w2_dofs(2))

  end subroutine dof_to_update_test

  @test
  subroutine calc_local_vertical_index_test()
    use pFUnit_Mod
    use constants_mod,      only : r_def, i_def
    use cosmic_flux_mod,    only : calc_local_vertical_index

    implicit none

    integer(i_def) :: n_cells_to_sum
    integer(i_def) :: k
    integer(i_def) :: nlayers
    integer(i_def) :: edge
    integer(i_def), allocatable :: local_index(:)
    real(kind=r_def) :: departure_dist

    departure_dist = 1.2_r_def
    n_cells_to_sum = ceiling(abs(departure_dist))
    allocate(local_index(n_cells_to_sum))

    ! For this test we have a column of 5 cells, denoted 0|1|2|3|4
    ! We are are interested in cell "3" (k=3) and have a positive departure distance
    ! of 1.2. Edge=1 refers to the right-hand edge of the cell (or upper edge in
    ! the vertical case) which is the edge between cells 3 and 4. Since the
    ! departure distance is 1.2 then we want to  obtain the densities from
    ! cells 3 and 2. These are the values returned by local_index (in that order).
    nlayers = 5
    k = 3
    edge = 1
    call calc_local_vertical_index(local_index,departure_dist,n_cells_to_sum,k,nlayers,edge)
    @assertEqual(3, local_index(1))
    @assertEqual(2, local_index(2))

    deallocate(local_index)


    departure_dist = -2.4_r_def
    n_cells_to_sum = ceiling(abs(departure_dist))
    allocate(local_index(n_cells_to_sum))

    ! We have a column of 5 cells, denoted 0|1|2|3|4
    ! We are are interested in cell "1" (k=1) and have a negative departure distance
    ! of -2.4. Edge=1 refers to the right-hand edge of the cell (or upper edge in
    ! the vertical case). Since the departure distance is -2.4 then we want to
    ! obtain the densities from cells 2, 3 and 4. These are the values returned by
    ! local_index (in that order). Note that we do not need to know the density
    ! of cell 1 since the departure distance is negative and we are calculating the
    ! flux for the edge between cells 1 and 2.
    nlayers = 5
    k = 1

    call calc_local_vertical_index(local_index,departure_dist,n_cells_to_sum,k,nlayers,edge)
    @assertEqual(2, local_index(1))
    @assertEqual(3, local_index(2))
    @assertEqual(4, local_index(3))

    deallocate(local_index)

  end subroutine calc_local_vertical_index_test

end module cosmic_flux_mod_test
