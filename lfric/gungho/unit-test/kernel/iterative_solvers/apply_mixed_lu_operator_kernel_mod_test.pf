!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! For further details please refer to the file COPYRIGHT.txt
! which you should have received as part of this distribution.
!-----------------------------------------------------------------------------

!> Test the mixed operator to the momentum equation
!>
module apply_mixed_lu_operator_kernel_mod_test

  use constants_mod, only : i_def, r_def
  use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: apply_mixed_lu_operator_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type apply_mixed_lu_operator_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(apply_mixed_lu_operator_test_type), intent(inout) :: this

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(apply_mixed_lu_operator_test_type), intent(inout) :: this

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  @Test( )
  subroutine test_all( this )

    use apply_mixed_lu_operator_kernel_mod, only : apply_mixed_lu_operator_code

    implicit none

    class(apply_mixed_lu_operator_test_type), intent(inout) :: this

    real(r_def), parameter :: tol = 1.0e-12_r_def

    ! Mesh
    integer(i_def), parameter :: nlayers = 1
    integer(i_def), parameter :: cell = 1
    integer(i_def), parameter :: ncell = 1

    ! Spaces
    integer(i_def), parameter :: ndf_w2 = 4
    integer(i_def), parameter :: ndf_wt = 2
    integer(i_def), parameter :: ndf_w3 = 1
    integer(i_def), parameter :: undf_w2 = ndf_w2*nlayers
    integer(i_def), parameter :: undf_wt = nlayers + 1
    integer(i_def), parameter :: undf_w3 = ndf_w3*nlayers

    ! Maps
    integer(i_def), dimension(ndf_w2) :: map_w2
    integer(i_def), dimension(ndf_wt) :: map_wt
    integer(i_def), dimension(ndf_w3) :: map_w3

    ! Operators
    real(r_def), dimension(ndf_w2, ndf_w2, ncell) :: Mu
    real(r_def), dimension(ndf_w2, ndf_wt, ncell) :: Proj
    real(r_def), dimension(ndf_w2, ndf_w3, ncell) :: Grad

    ! Fields
    real(r_def), dimension(undf_w2) :: Lu, u, Nu
    real(r_def), dimension(undf_wt) :: t
    real(r_def), dimension(undf_w3) :: p

    integer(i_def) :: df
    real(r_def)    :: answer

    map_w2 = (/ 1_i_def, 2_i_def, 3_i_def, 4_i_def /)
    map_wt = (/ 1_i_def, 2_i_def /)
    map_w3 = (/ 1_i_def /)

    ! Set up operators
    Mu = 0.0_r_def
    do df = 1,ndf_w2
      Mu(df,df,1) = real(df,r_def)
      Grad(df,1,1) = (-1.0_r_def)**df
    end do
    Proj(:,:,1) = 0.5_r_def

    ! Set up the fields
    u = (/ 0.0_r_def, 1.0_r_def, 3.0_r_def, -2.0_r_def /)
    t = (/ 300.0_r_def, 310.0_r_def /)
    p = (/ 1.2_r_def /)
    Nu = 2.0_r_def
    Lu = 0.0_r_def

    ! Compute Nu*(Mu*u - Proj*t - Grad*p)
    call apply_mixed_lu_operator_code(cell,                    &
                                      nlayers,                 &
                                      Lu,                      &
                                      u, t, p,                 &
                                      ncell, Mu,               &
                                      ncell, Proj,             &
                                      ncell, Grad,             &
                                      Nu,                      &
                                      ndf_w2, undf_w2, map_w2, &
                                      ndf_wt, undf_wt, map_wt, &
                                      ndf_w3, undf_w3, map_w3)

    do df = 1,ndf_w2
      answer = Nu(df)*(Mu(df,df,1)*u(df) - sum(Proj(df,:,1)*t(:)) - Grad(df,1,1)*p(1))
      @assertEqual(answer, Lu(df), tol)
    end do

  end subroutine test_all

end module apply_mixed_lu_operator_kernel_mod_test
