!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the application of the Helmholtz operator
module helmholtz_operator_kernel_mod_test

  use constants_mod, only: i_def, r_def
  use pFUnit_Mod

  implicit none

  private
  public :: test_full_operator

  @TestCase
  type, extends(TestCase), public :: helmholtz_operator_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_full_operator
  end type helmholtz_operator_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    implicit none

    class(helmholtz_operator_test_type), intent(inout) :: this

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(helmholtz_operator_test_type), intent(inout) :: this

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  @Test( )
  subroutine test_full_operator( this )

    use helmholtz_operator_kernel_mod, only: helmholtz_operator_code

    implicit none

    class(helmholtz_operator_test_type), intent(inout) :: this

    real(kind=r_def), parameter :: tol = 1.0e-12_r_def

    ! Mesh
    integer(kind=i_def), parameter :: nlayers = 5
    integer(kind=i_def), parameter :: nfaces = 4
    integer(kind=i_def), parameter :: smap_size_w2 = 1 + nfaces
    integer(kind=i_def), parameter :: ncell = smap_size_w2*nlayers
    integer(kind=i_def), dimension(smap_size_w2) :: cell_map

    ! Spaces
    integer(kind=i_def), parameter :: ndf_w3 = 1
    integer(kind=i_def), parameter :: ndf_w2 = 6
    integer(kind=i_def), parameter :: ndf_wt = 2
    integer(kind=i_def), parameter :: undf_w3 = ndf_w3*nlayers
    integer(kind=i_def), parameter :: undf_wt = ndf_w2*nlayers + 1
    integer(kind=i_def), parameter :: undf_w2 = ((ndf_w2-1)*nlayers+1)*smap_size_w2

    ! Maps
    integer(kind=i_def), dimension(ndf_w3)               :: map_w3
    integer(kind=i_def), dimension(ndf_wt)               :: map_wt
    integer(kind=i_def), dimension(ndf_w2)               :: map_w2
    integer(kind=i_def), dimension(ndf_w2, smap_size_w2) :: smap_w2

    ! Fields
    real(kind=r_def), dimension(undf_w2) :: hb_lumped_inv, u_normalisation, w2_mask
    real(kind=r_def), dimension(undf_wt) :: t_norm
    real(kind=r_def), dimension(undf_w3) :: helm_c,                         &
                                            helm_n, helm_e, helm_s, helm_w, &
                                            helm_u, helm_d, helm_uu, helm_dd

    ! Operators
    real(kind=r_def), dimension(ndf_w2, ndf_w3, ncell) :: div_star
    real(kind=r_def), dimension(ndf_w3, ndf_w2, ncell) :: compound_div
    real(kind=r_def), dimension(ndf_w3, ndf_wt, ncell) :: p3theta
    real(kind=r_def), dimension(ndf_wt, ndf_w2, ncell) :: ptheta2v
    real(kind=r_def), dimension(ndf_w3, ndf_w3, ncell) :: m3_exner_star

    ! Number of dofs in a single column: 4*nlayers horizontal dofs
    ! and (nlayers + 1) vertical dofs
    integer(kind=i_def), parameter :: ndofs_col = 5*nlayers+1
    integer(kind=i_def) :: wsen_map(4)
    integer(kind=i_def) :: wsen_map_count

    integer(kind=i_def) :: df, k
    real(kind=r_def)    :: answer

    map_w3 = (/ 1_i_def /)
    map_wt = (/ 1_i_def, 2_i_def /)

    do df = 1, nfaces
      map_w2(df) = 1_i_def + (df-1)*nlayers
    end do
    map_w2(5) = 1_i_def + 4*nlayers
    map_w2(6) = map_w2(5)+1_i_def

    smap_w2(:,1) = map_w2

    ! Maps in neighbour cells
    ! Default all dofs to point to a dof
    ! that is not in the central stencil
    smap_w2(:,2) = ndofs_col + 1
    smap_w2(:,3) = ndofs_col + 1
    smap_w2(:,4) = ndofs_col + 1
    smap_w2(:,5) = ndofs_col + 1
    ! Now make sure one dof matches up with central stencil
    ! East cell
    smap_w2(3,2) = smap_w2(1,1)
    ! South cell
    smap_w2(4,3) = smap_w2(2,1)
    ! West cell
    smap_w2(1,4) = smap_w2(3,1)
    ! North cell
    smap_w2(2,5) = smap_w2(4,1)

    do df = 1, smap_size_w2
      cell_map(df) = df
    end do

    ! Set up the fields
    hb_lumped_inv = 0.1_r_def
    u_normalisation = 10.0_r_def
    t_norm = 10.0_r_def
    w2_mask = 1.0_r_def

    ! Set up the operators
    ! Very simple test, set the operators and fields to constants
    div_star = 1.0_r_def
    ptheta2v = 0.1_r_def
    compound_div = 1.0_r_def
    m3_exner_star = 1.0_r_def
    p3theta = 1.0_r_def

    ! Set up W,S,E,N direction map
    ! Defaulting to full stencil
    wsen_map(:) = [ 1, 2, 3, 4 ]
    wsen_map_count = 4

    ! Compute Helmholtz operator
    call helmholtz_operator_code(smap_size_w2,                     &
                                 cell_map,                         &
                                 wsen_map,                         &
                                 wsen_map_count,                   &
                                 nlayers,                          &
                                 helm_c,                           &
                                 helm_n, helm_e, helm_s, helm_w,   &
                                 helm_u, helm_uu, helm_d, helm_dd, &
                                 hb_lumped_inv,                    &
                                 smap_size_w2, smap_w2,            &
                                 u_normalisation,                  &
                                 ncell,                            &
                                 div_star,                         &
                                 t_norm,                           &
                                 ncell,                            &
                                 ptheta2v,                         &
                                 ncell,                            &
                                 compound_div,                     &
                                 ncell,                            &
                                 m3_exner_star,                    &
                                 ncell,                            &
                                 p3theta,                          &
                                 w2_mask,                          &
                                 ndf_w3, undf_w3, map_w3,          &
                                 ndf_w2, undf_w2, map_w2,          &
                                 ndf_wt, undf_wt, map_wt)
    ! In terms of the kernel operators we have
    ! A = -u_normalisation*w2_mask*hb_lumped_inv*div_star = -1
    ! B = t_norm*ptheta2v                 =  1
    ! EC = - compound_div                 = -1
    ! D = - p3theta                       = -1
    ! F = m3_exner_star                   =  1
    ! and the resulting Helmholtz operators are then
    ! helm_c = F + 6*EC*A + 6*D*B*A = 13
    ! helm_e,helm_s,helm_w,helm_n = EC*A = 1
    ! helm_uu, helm_dd = D*B*A = 1
    ! helm_u, helm_d = EC*A + 4*D*B*A = 5

    ! Layer 3:
    k = 2
    answer = 13.0_r_def
    @assertEqual(answer, helm_c(map_w3(1)+k), tol)
    answer = 1.0_r_def
    @assertEqual(answer, helm_n(map_w3(1)+k), tol)
    @assertEqual(answer, helm_e(map_w3(1)+k), tol)
    @assertEqual(answer, helm_s(map_w3(1)+k), tol)
    @assertEqual(answer, helm_w(map_w3(1)+k), tol)
    @assertEqual(answer, helm_uu(map_w3(1)+k), tol)
    @assertEqual(answer, helm_dd(map_w3(1)+k), tol)
    answer = 5.0_r_def
    @assertEqual(answer, helm_u(map_w3(1)+k), tol)
    @assertEqual(answer, helm_d(map_w3(1)+k), tol)

  end subroutine test_full_operator

end module helmholtz_operator_kernel_mod_test
