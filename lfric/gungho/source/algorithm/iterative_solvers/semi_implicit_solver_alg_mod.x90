!-----------------------------------------------------------------------------
! (C) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Semi-Implicit solver for the gungho dynamical core.
!> @details Control routine for the construction and application of
!!          the semi-implicit solver.
!!          More details of the solver forumulation can be found in the solver section of:
!!          https://code.metoffice.gov.uk/trac/lfric/wiki/GhaspSupport/Documentation
module semi_implicit_solver_alg_mod

  use constants_mod,                      only: i_def, r_def, l_def
  use log_mod,                            only: log_event,         &
                                                log_scratch_space, &
                                                LOG_LEVEL_INFO,    &
                                                LOG_LEVEL_ERROR,   &
                                                LOG_LEVEL_TRACE

  ! Config
  use mixed_solver_config_mod,            only: split_w,                  &
                                                mixed_solver_a_tol,       &
                                                eliminate_variables,      &
                                                eliminate_variables_none, &
                                                eliminate_variables_analytic

  ! Derived Types
  use field_vector_mod,                   only: field_vector_type
  use field_mod,                          only: field_type
  use mesh_mod,                           only: mesh_type
  use derived_config_mod,                 only: bundle_size
  use field_indices_mod,                  only: isol_p, isol_t, isol_d,  &
                                                isol_u, isol_w, isol_uv, &
                                                igh_p, igh_t, igh_d,     &
                                                igh_u, igh_w, igh_uv,    &
                                                set_solver_field_indices



  ! Algorithms
  use mixed_operator_alg_mod,             only: mixed_operator_type
  use mixed_schur_preconditioner_alg_mod, only: mixed_schur_preconditioner_type
  use pressure_operator_alg_mod,          only: pressure_operator_type
  use pressure_precon_alg_mod,            only: pressure_preconditioner_type
  use pressure_diag_precon_alg_mod,       only: pressure_diag_preconditioner_type
  use null_preconditioner_alg_mod,        only: null_preconditioner_type
  use multigrid_preconditioner_alg_mod,   only: multigrid_preconditioner_type

  ! preconditioner and solver
  use preconditioner_mod,                 only: abstract_preconditioner_type
  use iterative_solver_mod,               only: abstract_iterative_solver_type, &
                                                bicgstab_type,                  &
                                                gmres_type,                     &
                                                fgmres_type,                    &
                                                gcr_type,                       &
                                                block_gcr_type,                 &
                                                conjugate_gradient_type,        &
                                                precondition_only_type,         &
                                                jacobi_type

  ! Kernels
  use split_w2_field_kernel_mod,          only: split_w2_field_kernel_type
  use combine_w2_field_kernel_mod,        only: combine_w2_field_kernel_type

  ! IO
  use io_config_mod,                      only: subroutine_timers
  use timer_mod,                          only: timer

  implicit none

  private

  ! Operator, preconditioner and iterative solver for mixed problem
  type( mixed_operator_type )                          :: mixed_operator
  class( abstract_preconditioner_type ),   allocatable :: mixed_preconditioner
  class( abstract_iterative_solver_type ), allocatable :: mixed_solver

  !> Operator, preconditioner and iterative solver for
  !> Helmholtz (pressure) problem
  type( pressure_operator_type )                       :: pressure_operator
  class( abstract_preconditioner_type ),   allocatable :: pressure_preconditioner
  class( abstract_iterative_solver_type ), allocatable :: pressure_solver

  public  :: semi_implicit_solver_alg_init
  public  :: semi_implicit_solver_alg_final
  public  :: semi_implicit_solver_alg_step
  private :: construct_solver_state
contains
!=============================================================================!
  !> @details Initialisation procedure for the semi-implicit solver
  !> @param[in] state Prognostic state for the solver
  subroutine semi_implicit_solver_alg_init(state)
    use mixed_solver_config_mod,       only: si_maximum_iterations,                      &
                                             si_tolerance,                               &
                                             si_method,                                  &
                                             mixed_gcrk => gcrk,                         &
                                             si_method_cg,                               &
                                             si_method_bicgstab,                         &
                                             si_method_gmres,                            &
                                             si_method_fgmres,                           &
                                             si_method_gcr,                              &
                                             si_method_block_gcr,                        &
                                             si_method_prec_only,                        &
                                             si_method_jacobi,                           &
                                             si_preconditioner,                          &
                                             si_preconditioner_pressure,                 &
                                             si_preconditioner_diagonal,                 &
                                             si_preconditioner_none,                     &
                                             si_diagnostic_norm

    use helmholtz_solver_config_mod,   only: si_pressure_maximum_iterations,             &
                                             helmholtz_gcrk => gcrk,                     &
                                             si_pressure_tolerance,                      &
                                             si_pressure_a_tol,                          &
                                             helmholtz_method => method,                 &
                                             method_cg,                                  &
                                             method_bicgstab,                            &
                                             method_gmres,                               &
                                             method_fgmres,                              &
                                             method_gcr,                                 &
                                             method_prec_only,                           &
                                             method_jacobi,                              &
                                             helmholtz_preconditioner => preconditioner, &
                                             preconditioner_none,                        &
                                             preconditioner_diagonal,                    &
                                             preconditioner_tridiagonal,                 &
                                             preconditioner_multigrid,                   &
                                             diagnostic_norm

    implicit none

    ! Prognostic fields
    type( field_type ), dimension(bundle_size), intent( in ) :: state

    type( field_vector_type ) :: vector_state
    ! Vertical pressure preconditioner
    type( pressure_preconditioner_type ) :: Hz_preconditioner

    ! Set the correct indices for the solver fields
    call set_solver_field_indices()

    call construct_solver_state(vector_state, state)

    pressure_operator &
      = pressure_operator_type(state(igh_p)%get_function_space(), level=1_i_def)

    ! *** Allocate polymorphic solver- and preconditioner objects ***

    call log_event( "semi_implicit_solver_alg_init: allocate and construct pressure/Helmholtz preconditioner", &
                       LOG_LEVEL_INFO)
    ! Allocate pressure preconditioner preconditioner of correct type
    select case(helmholtz_preconditioner)
    case(PRECONDITIONER_NONE)
       allocate( pressure_preconditioner, &
                 source = null_preconditioner_type() )
    case(PRECONDITIONER_DIAGONAL)
       allocate ( pressure_preconditioner, &
                 source = pressure_diag_preconditioner_type() )
    case(PRECONDITIONER_TRIDIAGONAL)
       allocate( pressure_preconditioner, &
                 source = pressure_preconditioner_type(level=1_i_def) )
    case(PRECONDITIONER_MULTIGRID)
       Hz_preconditioner = pressure_preconditioner_type(level=1_i_def)
       allocate( pressure_preconditioner, &
                 source = multigrid_preconditioner_type(state(igh_p), &
                                                        pressure_operator, &
                                                        Hz_preconditioner) )
    case default
       call log_event( "Unknown pressure preconditioner specified", &
                       LOG_LEVEL_ERROR)
    end select

    call log_event( "semi_implicit_solver_alg_init: Setting up pressure solver", LOG_LEVEL_INFO )

      ! Allocate pressure solver of correct type
    select case( helmholtz_method )
    case (METHOD_BICGSTAB)
       allocate ( pressure_solver, &
                  source = bicgstab_type( pressure_operator,         &
                                        pressure_preconditioner,     &
                                        si_pressure_tolerance,       &
                                        si_pressure_a_tol,           &
                                        si_pressure_maximum_iterations) )
    case(METHOD_CG)
       allocate ( pressure_solver, &
                  source = conjugate_gradient_type( pressure_operator,         &
                                                  pressure_preconditioner,     &
                                                  si_pressure_tolerance,       &
                                                  si_pressure_a_tol,           &
                                                  si_pressure_maximum_iterations) )
    case(METHOD_GMRES)
       allocate ( pressure_solver, &
                  source = gmres_type( pressure_operator,         &
                                     pressure_preconditioner,     &
                                     helmholtz_gcrk,              &
                                     si_pressure_tolerance,       &
                                     si_pressure_a_tol,           &
                                     si_pressure_maximum_iterations) )
    case(METHOD_FGMRES)
       allocate ( pressure_solver, &
                  source = fgmres_type( pressure_operator,         &
                                      pressure_preconditioner,     &
                                      helmholtz_gcrk,              &
                                      si_pressure_tolerance,       &
                                      si_pressure_a_tol,           &
                                      si_pressure_maximum_iterations) )
    case(METHOD_GCR)
       allocate ( pressure_solver, &
                  source = gcr_type( pressure_operator,         &
                                   pressure_preconditioner,     &
                                   helmholtz_gcrk,              &
                                   si_pressure_tolerance,       &
                                   si_pressure_a_tol,           &
                                   si_pressure_maximum_iterations) )
    case(METHOD_PREC_ONLY)
       allocate ( pressure_solver, &
                  source = precondition_only_type( pressure_operator,         &
                                                 pressure_preconditioner,     &
                                                 si_pressure_tolerance,       &
                                                 si_pressure_a_tol,           &
                                                 diagnostic_norm) )
    case(METHOD_JACOBI)
       allocate ( pressure_solver,                                 &
                  source = jacobi_type( pressure_operator,         &
                           pressure_preconditioner,                &
                           si_pressure_tolerance,                  &
                           si_pressure_a_tol,                      &
                           si_pressure_maximum_iterations,         &
                           rho_relax = 1.0_r_def ) )
    case default
       call log_event("Unknown pressure solver specified",LOG_LEVEL_ERROR)
    end select

    call log_event( "semi_implicit_solver_alg_init: ... Helmholtz done ", &
                       LOG_LEVEL_INFO)

    call log_event( "semi_implicit_solver_alg_init: allocate and construct mixed preconditioner", &
                       LOG_LEVEL_INFO)
    ! Allocate mixed preconditioner of correct type and call constructor
    select case(si_preconditioner)
    case(SI_PRECONDITIONER_PRESSURE)
       allocate ( mixed_preconditioner, &
                  source = mixed_schur_preconditioner_type(vector_state, pressure_solver) )
    case(SI_PRECONDITIONER_NONE)
       allocate ( mixed_preconditioner, &
                  source = null_preconditioner_type() )
    case default
       call log_event("Unknown mixed preconditioner specified",LOG_LEVEL_ERROR)
    end select

    call log_event( "semi_implicit_solver_alg_init: Setting up mixed operator", LOG_LEVEL_INFO )
    ! Set up mixed operator
    mixed_operator = mixed_operator_type()

    call log_event( "semi_implicit_solver_alg_init: allocate and construct mixed solver", &
                       LOG_LEVEL_INFO)
    ! Allocate mixed solver of correct type
    select case(si_method)
    case(SI_METHOD_BICGSTAB)
       allocate ( mixed_solver, &
                  source = bicgstab_type( mixed_operator,  &
                                     mixed_preconditioner, &
                                     si_tolerance,         &
                                     mixed_solver_a_tol,   &
                                     si_maximum_iterations) )
    case(SI_METHOD_CG)
       allocate ( mixed_solver, &
                  source = conjugate_gradient_type( mixed_operator,  &
                                               mixed_preconditioner, &
                                               si_tolerance,         &
                                               mixed_solver_a_tol,   &
                                               si_maximum_iterations) )
    case(SI_METHOD_GMRES)
       allocate ( mixed_solver, &
                  source = gmres_type( mixed_operator,  &
                                  mixed_preconditioner, &
                                  mixed_gcrk,           &
                                  si_tolerance,         &
                                  mixed_solver_a_tol,   &
                                  si_maximum_iterations) )
    case(SI_METHOD_FGMRES)
       allocate ( mixed_solver, &
                  source = fgmres_type( mixed_operator,  &
                                   mixed_preconditioner, &
                                   mixed_gcrk,           &
                                   si_tolerance,         &
                                   mixed_solver_a_tol,   &
                                   si_maximum_iterations) )
    case(SI_METHOD_BLOCK_GCR)
       allocate ( mixed_solver, &
                  source = block_gcr_type( mixed_operator,  &
                                      mixed_preconditioner, &
                                      mixed_gcrk,           &
                                      si_tolerance,         &
                                      mixed_solver_a_tol,   &
                                      si_maximum_iterations) )
    case(SI_METHOD_GCR)
       allocate ( mixed_solver, &
                  source = gcr_type( mixed_operator,  &
                                mixed_preconditioner, &
                                mixed_gcrk,           &
                                si_tolerance,         &
                                mixed_solver_a_tol,   &
                                si_maximum_iterations) )
    case(SI_METHOD_PREC_ONLY)
       allocate ( mixed_solver, &
                  source = precondition_only_type( mixed_operator,  &
                                              mixed_preconditioner, &
                                              si_tolerance,         &
                                              mixed_solver_a_tol,   &
                                              si_diagnostic_norm) )
    case(SI_METHOD_JACOBI)
       allocate ( mixed_solver, &
                  source = jacobi_type( mixed_operator,        &
                                        mixed_preconditioner,  &
                                        si_tolerance,          &
                                        mixed_solver_a_tol,    &
                                        si_maximum_iterations, &
                                        rho_relax = 1.0_r_def ) )
    case default
       call log_event("Unknown mixed solver specified",LOG_LEVEL_ERROR)
    end select

    call log_event( "semi_implicit_solver_alg_init: Initialised semi-implicit solver", LOG_LEVEL_INFO )

  end subroutine semi_implicit_solver_alg_init

  !@brief Tidy up semi-implicit solver algorithm module
  !>
  !@details Deallocate memory
  subroutine semi_implicit_solver_alg_final()
    implicit none

    ! Deallocate mixed preconditioner object
    if (allocated(mixed_preconditioner)) then
       deallocate(mixed_preconditioner)
    end if
    ! Deallocate mixed solver object
    if (allocated(mixed_solver)) then
       deallocate(mixed_solver)
    end if
    ! Deallocate pressure preconditioner object
    if (allocated(pressure_preconditioner)) then
       deallocate(pressure_preconditioner)
    end if
    ! Deallocate pressure solver object
    if (allocated(pressure_solver)) then
       deallocate(pressure_solver)
    end if
  end subroutine semi_implicit_solver_alg_final

!=============================================================================!

  !> @brief An algorithm for timestepping the semi-implicit equations.
  !>
  !> @param[in,out] state               Prognostic model state
  !> @param[in,out] rhs                 Residuals
  !> @param[in]     moist_dyn_gas_law   Gas law component of moist dynamics factors
  !> @param[in]     mr                  Mixing ratio array
  !> @param[in]     rho_guess           Estimate for rho^n+1 used for moisture
  !!                                    diagnostics
  !> @param[in]     write_moisture_diag Flag to control output of moisture
  !!                                    conservation diagnostics
  subroutine semi_implicit_solver_alg_step(state, rhs, &
                                           moist_dyn_gas_law, &
                                           mr, rho_guess, &
                                           write_moisture_diag)

    use fem_constants_mod,             only: get_inverse_w3_mass_matrix, &
                                             get_normalisation, &
                                             get_div, &
                                             get_qr
    use fs_continuity_mod,             only: W2, Wtheta
    use mr_indices_mod,                only: nummr
    use moisture_conservation_alg_mod, only: moisture_conservation_alg
    use si_operators_alg_mod,          only: get_m3_rho_star,       &
                                             get_rho_at_u,          &
                                             get_p2theta,           &
                                             get_p3theta,           &
                                             get_ptheta2,           &
                                             get_eliminated_q2t,    &
                                             get_eliminated_q3t
    use matrix_vector_kernel_mod,      only: matrix_vector_kernel_type
    use dg_matrix_vector_kernel_mod,   only: dg_matrix_vector_kernel_type
    use dg_inc_matrix_vector_kernel_mod, only: dg_inc_matrix_vector_kernel_type
    use operator_mod,                  only: operator_type
    use field_mod,                     only: field_type
    use timestepping_config_mod,       only: dt, tau_r
    use enforce_bc_kernel_mod,         only: enforce_bc_kernel_type
    use mass_matrix_solver_alg_mod,    only: mass_matrix_solver_alg

    implicit none

    ! Prognostic fields
    type( field_type ), dimension(bundle_size), intent( inout ) :: state
    type( field_type ), dimension(bundle_size), intent( inout ) :: rhs
    type( field_type ),                         intent( in )    :: moist_dyn_gas_law
    type( field_type ), dimension(nummr),       intent( in )    :: mr
    type( field_type ),                         intent( in )    :: rho_guess
    logical( kind=l_def ),                      intent( in )    :: write_moisture_diag

    real( kind=r_def )                    :: si_err(bundle_size)
    type( field_type ),           pointer :: t_normalisation => null(), &
                                             u_normalisation => null()
    type( field_vector_type )             :: vector_inc, vector_rhs

    ! For eliminate of rho and theta
    type( field_type )             :: div_u,                    &
                                      f_star, rhs_tmp, inc_uvw, &
                                      inc_theta, inc_rho
    type( field_type ),    pointer :: rho_at_u => null(), &
                                      m2_diag => null(),  &
                                      mt_lumped_inv => null()
    type( operator_type ), pointer :: div => null(), &
                                      m3_rho_star => null(), &
                                      mm_w3_inv => null(),   &
                                      p3theta => null(),     &
                                      p2theta => null(),     &
                                      ptheta2 => null(),     &
                                      q2t_op => null(),      &
                                      q3t_op => null()
    real( kind=r_def )             :: tau_r_dt
    integer( kind=i_def )          :: mesh_id

    if ( subroutine_timers ) call timer('semi_implicit_solver_alg')
    mesh_id = state(igh_p)%get_mesh_id()

    if ( write_moisture_diag ) then
      ! Best guess for the prognostic fields state can be calculated as
      ! state_best_guess = rhs_n - rhs_np1 + state + rhs_adv + rhs_phys
      ! where fortunately all of the above except "state" is already in "rhs_np1"
      call invoke(X_plus_Y(rho_guess, state(igh_d), rhs(igh_d)))
      call moisture_conservation_alg( rho_guess, mr, 'Before solve' )
    end if

    ! Normalise theta & u residual
    t_normalisation => get_normalisation(Wtheta, mesh_id)
    u_normalisation => get_normalisation(W2, mesh_id)
    call invoke( inc_X_times_Y(rhs(igh_u), u_normalisation) )
    if ( eliminate_variables == eliminate_variables_analytic ) then
      call rhs_tmp%initialise( vector_space = rhs(igh_t)%get_function_space() )
      call invoke( setval_x( rhs_tmp, rhs(igh_t) ) )
      call mass_matrix_solver_alg( rhs(igh_t), rhs_tmp )
    else
      call invoke( inc_X_times_Y(rhs(igh_t), t_normalisation) )
    end if
    ! Write out si residuals
    call invoke( name = "Compute SI residuals",               &
                 X_innerproduct_X(si_err(igh_u), rhs(igh_u)), &
                 X_innerproduct_X(si_err(igh_t), rhs(igh_t)), &
                 X_innerproduct_X(si_err(igh_d), rhs(igh_d)), &
                 X_innerproduct_X(si_err(igh_p), rhs(igh_p))  &
               )
    write( log_scratch_space, '(A,E16.8)' ) &
         'Residual in momentum equation:  ',sqrt(si_err(igh_u))
    call log_event( log_scratch_space, LOG_LEVEL_INFO )
    write( log_scratch_space, '(A,E16.8)' ) &
         'Residual in energy equation:    ',sqrt(si_err(igh_t))
    call log_event( log_scratch_space, LOG_LEVEL_INFO )
    write( log_scratch_space, '(A,E16.8)' ) &
         'Residual in continuity equation:',sqrt(si_err(igh_d))
    call log_event( log_scratch_space, LOG_LEVEL_INFO )
    write( log_scratch_space, '(A,E16.8)' ) &
         'Residual in equation of state:  ',sqrt(si_err(igh_p))
    call log_event( log_scratch_space, LOG_LEVEL_INFO )

    ! Modify RHS if we are eliminating variables
    if ( eliminate_variables /= eliminate_variables_none ) then
      m3_rho_star => get_m3_rho_star()
       ! Elimination of rho
      call rhs_tmp%initialise( vector_space = rhs(igh_p)%get_function_space() )
      ! Set rhs_p = rhs_p + M_{3,rho} * rhs_rho
      call invoke( dg_inc_matrix_vector_kernel_type( rhs(igh_p), rhs(igh_d), m3_rho_star ) )

      ! Elimination of theta
      if ( eliminate_variables == eliminate_variables_analytic ) then
        q2t_op => get_eliminated_q2t()
        q3t_op => get_eliminated_q3t()
        call invoke( dg_inc_matrix_vector_kernel_type( rhs(igh_p), rhs(igh_t), q3t_op ), &
                     matrix_vector_kernel_type( rhs(igh_u), rhs(igh_t), q2t_op ), &
                     enforce_bc_kernel_type( rhs(igh_u) ) )
      else
        p3theta   => get_p3theta()
        m2_diag   => get_normalisation(W2, mesh_id)
        call rhs_tmp%initialise( vector_space = rhs(igh_p)%get_function_space() )
        ! Set rhs_p = rhs_p + P_{3,theta} * rhs_theta
        call invoke( dg_inc_matrix_vector_kernel_type( rhs(igh_p), rhs(igh_t), p3theta ) )
        ! Set rhs_u = rhs_u + M_2^{diag} * P_{2,theta} * rhs_theta
        call rhs_tmp%initialise( vector_space = rhs(igh_u)%get_function_space() )
        p2theta => get_p2theta()
        call invoke( setval_c(rhs_tmp, 0.0_r_def),                              &
                     matrix_vector_kernel_type( rhs_tmp, rhs(igh_t), p2theta ), &
                     inc_X_times_Y(rhs_tmp, m2_diag),                           &
                     inc_X_plus_Y(rhs(igh_u), rhs_tmp),                         &
                     enforce_bc_kernel_type( rhs(igh_u) ) )
      end if
    end if

    ! Create field vectors out of field arrays
    call construct_solver_state(vector_inc, state)
    call construct_solver_state(vector_rhs,   rhs)
    ! Solve the semi-implicit operator
    call log_event( "Gungho: mixed solve:", LOG_LEVEL_INFO )
    call vector_inc%set_scalar(0.0_r_def)
    if ( subroutine_timers ) call timer('mixed_solver')
    call mixed_solver%apply(vector_inc, vector_rhs)
    if ( subroutine_timers ) call timer('mixed_solver')

    ! Back substitute lhs if we are eliminating variables
    call inc_uvw%initialise( rhs(igh_u)%get_function_space() )
    if ( split_w ) then
      ! Create inc_uvw from  uv & w
      call invoke( combine_w2_field_kernel_type( inc_uvw,                      &
                                                 vector_inc%vector( isol_uv ), &
                                                 vector_inc%vector( isol_w ) ) )

      call vector_inc%vector(isol_uv)%log_minmax(LOG_LEVEL_INFO, 'uv_inc')
      call vector_inc%vector(isol_w)%log_minmax(LOG_LEVEL_INFO, 'w_inc')
    else
      call invoke(setval_x(inc_uvw, vector_inc%vector(isol_u)) )
      call vector_inc%vector(isol_u)%log_minmax(LOG_LEVEL_INFO, 'uvw_inc')
    end if

    if ( eliminate_variables /= eliminate_variables_none ) then
      ! Compute rho increment since solver does not provide one
      div       => get_div(mesh_id)
      rho_at_u  => get_rho_at_u()
      mm_w3_inv => get_inverse_w3_mass_matrix(mesh_id)
      tau_r_dt = -tau_r*real(dt, kind=r_def)
      call div_u%initialise( vector_space = rhs(igh_p)%get_function_space() )
      call f_star%initialise( vector_space = rhs(igh_u)%get_function_space() )
      call rhs_tmp%initialise( vector_space = rhs(igh_p)%get_function_space() )
      call inc_rho%initialise( vector_space = rhs(igh_p)%get_function_space() )

      call invoke( X_times_Y( f_star, rho_at_u, inc_uvw ),                   &
                   dg_matrix_vector_kernel_type( div_u, f_star, div ),       &
                   dg_matrix_vector_kernel_type( rhs_tmp, div_u, mm_w3_inv), &
                   aX_plus_Y(inc_rho, tau_r_dt, rhs_tmp, rhs(igh_d))         &
                 )

      ! Compute theta increment since solver does not provide one
      ptheta2 => get_ptheta2()
      mt_lumped_inv => get_normalisation(Wtheta, mesh_id)
      call rhs_tmp%initialise( vector_space = rhs(igh_t)%get_function_space() )
      call inc_theta%initialise( vector_space = rhs(igh_t)%get_function_space() )
      call invoke( setval_c(rhs_tmp, 0.0_r_def), &
                   dg_inc_matrix_vector_kernel_type(rhs_tmp, inc_uvw, ptheta2))

      if (  eliminate_variables == eliminate_variables_analytic ) then
        call invoke( setval_x( inc_theta, rhs_tmp ) )
        call mass_matrix_solver_alg( rhs_tmp, inc_theta )
      else
        call invoke( inc_X_times_Y(rhs_tmp, mt_lumped_inv) )
      end if
      call invoke( X_minus_Y( inc_theta, rhs(igh_t), rhs_tmp) )
    end if

    call vector_inc%vector(isol_p)%log_minmax(LOG_LEVEL_INFO, 'exner_inc')

    ! Add increments to state fields
    call invoke( inc_X_plus_Y( state(igh_u), inc_uvw ), &
                 inc_X_plus_Y( state(igh_p), vector_inc%vector(isol_p) ) )
    if ( eliminate_variables == eliminate_variables_none ) then
      call invoke( inc_X_plus_Y( state(igh_t), vector_inc%vector(isol_t) ), &
                   inc_X_plus_Y( state(igh_d), vector_inc%vector(isol_d) ) )
    else
      call invoke( inc_X_plus_Y( state(igh_t), inc_theta ), &
                   inc_X_plus_Y( state(igh_d), inc_rho ) )
    end if

    if ( write_moisture_diag )  &
      call moisture_conservation_alg( state(igh_d), mr, 'After solve' )

    nullify( t_normalisation, &
             u_normalisation, &
             rho_at_u,        &
             m2_diag,         &
             mt_lumped_inv,   &
             div,             &
             m3_rho_star,     &
             mm_w3_inv,       &
             p3theta,         &
             p2theta,         &
             ptheta2,         &
             q2t_op,          &
             q3t_op )

    if ( subroutine_timers ) call timer('semi_implicit_solver_alg')

  end subroutine semi_implicit_solver_alg_step

  !> @brief Construct a field vector state out of a field bundle, expanding to
  !>        inlcude the split wind fields if necessary
  !>@param[in,out] vector_state field vector to create
  !>@param[in]     state field bundle to copy
  subroutine construct_solver_state(vector_state, state)
    use function_space_collection_mod, only: function_space_collection
    use fs_continuity_mod,             only: W2v, W2h

    implicit none

    type( field_vector_type ),                  intent(inout) :: vector_state
    type( field_type ), dimension(bundle_size), intent(in)    :: state

    type( field_type ) :: uv, w
    type( mesh_type ), pointer  :: mesh => null()
    integer( kind=i_def ) :: p, state_size

    state_size = 2 ! Default UV + P fields
    if ( split_w ) &
      state_size = state_size + 1 ! Additional W field
    if ( eliminate_variables == eliminate_variables_none ) &
      state_size = state_size + 2 ! Additional T & D fields

    vector_state = field_vector_type( state_size )

    if ( split_w ) then
      p    =  state(igh_u)%get_element_order()
      mesh => state(igh_u)%get_mesh()

      call uv%initialise( function_space_collection%get_fs( mesh, p, W2h ) )
      call w%initialise( function_space_collection%get_fs( mesh, p, W2v ) )
      call invoke( setval_c( uv, 0.0_r_def ), &
                   setval_c( w,  0.0_r_def ), &
                   split_w2_field_kernel_type( uv, w, state(igh_u) ) )
      call vector_state%import_field( uv, isol_uv )
      call vector_state%import_field( w, isol_w )
    else
      call vector_state%import_field( state(igh_u), isol_u )
    end if
    call vector_state%import_field( state(igh_p), isol_p )

    if ( eliminate_variables == eliminate_variables_none ) then
      call vector_state%import_field( state(igh_t), isol_t )
      call vector_state%import_field( state(igh_d), isol_d )
    end if

    nullify(mesh)

  end subroutine construct_solver_state
end module semi_implicit_solver_alg_mod
