!-------------------------------------------------------------------------------
! (C) Crown copyright 2017 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-------------------------------------------------------------------------------

!>@brief Map fields to spaces required by the FD physics routines
module map_physics_fields_alg_mod

  use constants_mod,            only: r_def, i_def
  use field_mod,                only: field_type
  use field_collection_mod,     only: field_collection_type
  use physics_mappings_alg_mod, only: map_physics_winds, map_physics_scalars, &
                                      split_wind_alg
  use moist_dyn_mod,            only: num_moist_factors, total_mass
  use extract_w_kernel_mod,     only: extract_w_kernel_type
  use smagorinsky_shear_kernel_mod, only: smagorinsky_shear_kernel_type
  use mixing_config_mod,            only: smagorinsky
  use physics_config_mod,        only: blayer_placement,               &
                                       blayer_placement_slow,          &
                                       convection_placement,           &
                                       convection_placement_slow
  use geometric_constants_mod,  only: get_da_at_w2, get_height
  use physical_op_constants_mod,only: get_dx_at_w2
  use fs_continuity_mod,        only: W3, Wtheta
  use mesh_mod,                 only: mesh_type

  use log_mod,                   only: log_event,         &
                                       LOG_LEVEL_INFO
  use print_field_stats_alg_mod, only: print_field_stats_alg

  use io_config_mod,             only: subroutine_timers
  use timer_mod,                 only: timer

  implicit none

  private

  public :: map_physics_fields_alg

contains

  !> @details An algorithm for mapping native FE fields to the lowest order
  !>          equivalents for use in the FD physics codes.
  !> @param[in]    u 3D wind field
  !> @param[in]    exner Pressure
  !> @param[in]    rho Density
  !> @param[in]    theta Potential temperature
  !> @param[in]    moist_dyn  Moist dynamics factors
  !> @param[inout] derived_fields Group of derived fields
  subroutine map_physics_fields_alg(u, exner, rho, theta, moist_dyn, derived_fields)

    implicit none
    ! Prognostic fields
    type( field_type ), intent(in)               :: u, rho, theta, exner
    type( field_type ), intent(in)               :: moist_dyn(num_moist_factors)
    type( field_collection_type ), intent(inout) :: derived_fields

    type( field_type ), pointer :: theta_in_w3 => null()
    type( field_type ), pointer :: theta_star => null()
    type( field_type ), pointer :: rho_in_wth => null()
    type( field_type ), pointer :: exner_in_wth => null()
    type( field_type ), pointer :: wetrho_in_wth => null()
    type( field_type ), pointer :: wetrho_in_w3 => null()
    type( field_type ), pointer :: u_in_w3 => null()
    type( field_type ), pointer :: v_in_w3 => null()
    type( field_type ), pointer :: w_in_w3 => null()
    type( field_type ), pointer :: u_in_w2h => null()
    type( field_type ), pointer :: v_in_w2h => null()
    type( field_type ), pointer :: w_in_wth => null()
    type( field_type ), pointer :: u_in_w3_star => null()
    type( field_type ), pointer :: v_in_w3_star => null()
    type( field_type ), pointer :: u_physics => null()
    type( field_type ), pointer :: u_physics_star => null()
    type( field_type ), pointer :: velocity_w2v => null()
    type( field_type ), pointer :: shear => null()
    type( field_type ), pointer :: dA => null()
    type( field_type ), pointer :: height_w3 => null()
    type( field_type ), pointer :: height_wth => null()
    type( field_type ), pointer :: dx_at_w2 => null()

    type( mesh_type ),  pointer :: mesh => null()

    if ( subroutine_timers ) call timer("map_physics_fields")

    mesh => u%get_mesh()

    theta_in_w3 => derived_fields%get_field('theta_in_w3')
    call map_physics_scalars(theta_in_w3, theta)

    rho_in_wth => derived_fields%get_field('rho_in_wth')
    exner_in_wth => derived_fields%get_field('exner_in_wth')
    call map_physics_scalars(rho_in_wth,   rho)
    call map_physics_scalars(exner_in_wth, exner)

    ! create wetrho which is needed by the physics
    wetrho_in_wth => derived_fields%get_field('wetrho_in_wth')
    call invoke(X_times_Y(wetrho_in_wth, rho_in_wth, moist_dyn(total_mass)))
    wetrho_in_w3 => derived_fields%get_field('wetrho_in_w3')
    call map_physics_scalars(wetrho_in_w3, wetrho_in_wth)

    ! Now the winds (NB if sample_physics_winds=.false. then the winds are
    ! not re-oriented and so they are not necessarily perpendicular or
    ! aligned lat-lon)
    u_in_w3 => derived_fields%get_field('u_in_w3')
    v_in_w3 => derived_fields%get_field('v_in_w3')
    w_in_w3 => derived_fields%get_field('w_in_w3')
    call map_physics_winds(u_in_w3, v_in_w3, w_in_w3, u)

    u_in_w2h => derived_fields%get_field('u_in_w2h')
    v_in_w2h => derived_fields%get_field('v_in_w2h')
    w_in_wth => derived_fields%get_field('w_in_wth')
    call split_wind_alg(u_in_w2h, v_in_w2h, w_in_wth, &
                        u, mesh)

    u_physics => derived_fields%get_field('u_physics')
    velocity_w2v => derived_fields%get_field('velocity_w2v')
    ! map dynamics winds into physics space
    dA => get_da_at_w2(mesh%get_id())
    call invoke(         X_divideby_Y(u_physics, u, dA), &
                extract_w_kernel_type(velocity_w2v, u_physics) )

    call u_physics%log_minmax(LOG_LEVEL_INFO, 'u_physics')
    call print_field_stats_alg(u_in_w3, LOG_LEVEL_INFO, &
                               printmin=-150.0_r_def, printmax=150.0_r_def)
    call print_field_stats_alg(v_in_w3, LOG_LEVEL_INFO, &
                               printmin=-100.0_r_def, printmax=100.0_r_def)
    call print_field_stats_alg(w_in_wth, LOG_LEVEL_INFO, &
                               printmin=-10.0_r_def, printmax=10.0_r_def)

    if ( smagorinsky ) then

      call log_event( 'Calculate 3D shear', LOG_LEVEL_INFO )
      ! Calculate 3D shear
      shear => derived_fields%get_field('shear')
      height_wth => get_height(Wtheta, mesh%get_id())
      height_w3 => get_height(W3, mesh%get_id())
      dx_at_w2 => get_dx_at_w2(mesh%get_id())

      call invoke(smagorinsky_shear_kernel_type( shear,         &
                                                 u_physics,  1, &
                                                 dx_at_w2,      &
                                                 height_wth,    &
                                                 height_w3) )
    end if

    if (blayer_placement == blayer_placement_slow .or.                        &
         convection_placement == convection_placement_slow) then
      ! Set up predictors with start of timestep variables
      theta_star => derived_fields%get_field('theta_star')
      u_physics_star => derived_fields%get_field('u_physics_star')
      u_in_w3_star => derived_fields%get_field('u_in_w3_star')
      v_in_w3_star => derived_fields%get_field('v_in_w3_star')
      call invoke(setval_X(theta_star, theta),                                &
                  setval_X(u_physics_star, u_physics),                        &
                  setval_X(u_in_w3_star, u_in_w3),                          &
                  setval_X(v_in_w3_star, v_in_w3) )
    end if

    if ( subroutine_timers ) call timer("map_physics_fields")

  end subroutine map_physics_fields_alg

end module map_physics_fields_alg_mod
