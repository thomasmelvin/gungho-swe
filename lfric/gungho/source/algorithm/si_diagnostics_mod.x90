!-------------------------------------------------------------------------------
! (c) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-------------------------------------------------------------------------------
!> @brief Processes diagnostics relating to the semi-implicit timestep

module si_diagnostics_mod

  use constants_mod,            only: l_def
  use derived_config_mod,       only: bundle_size
  use field_mod,                only: field_type
  use field_collection_mod,     only: field_collection_type
  use field_indices_mod,        only: igh_u, igh_t, igh_p
  use formulation_config_mod,   only: use_physics, moisture_formulation, &
                                      moisture_formulation_dry
  use physics_mappings_alg_mod, only: map_physics_winds
  use mr_indices_mod,           only: nummr, imr_v, imr_cl, imr_ci
  use io_config_mod,            only: subroutine_timers
  use timer_mod,                only: timer

  implicit none

  private

  !-----------------------------
  ! 3D Diagnostic flags
  !-----------------------------

  logical (l_def) :: dtheta_tot_flag
  logical (l_def) :: du_tot_flag
  logical (l_def) :: dv_tot_flag
  logical (l_def) :: dw_tot_flag
  logical (l_def) :: dmv_tot_flag
  logical (l_def) :: dmcl_tot_flag
  logical (l_def) :: dmci_tot_flag
  logical (l_def) :: dtheta_adv_flag
  logical (l_def) :: du_adv_flag
  logical (l_def) :: dv_adv_flag
  logical (l_def) :: dw_adv_flag
  logical (l_def) :: dmv_adv_flag
  logical (l_def) :: dmcl_adv_flag
  logical (l_def) :: dmci_adv_flag
  logical (l_def) :: dbcf_adv_flag
  logical (l_def) :: dcfl_adv_flag
  logical (l_def) :: dcff_adv_flag
  logical (l_def) :: dtheta_solv_flag
  logical (l_def) :: du_solv_flag
  logical (l_def) :: dv_solv_flag
  logical (l_def) :: dw_solv_flag

  public :: output_diags_for_si

contains

  subroutine output_diags_for_si(state, state_n, state_after_slow, mr, mr_n,   &
                                 mr_after_slow, mr_after_adv, derived_fields,  &
                                 du_fast, dtheta_fast, cloud_fields_after_slow,&
                                 cloud_fields_after_adv)

    implicit none

    type(field_type), dimension(bundle_size), intent(in) :: state, state_n, &
                                                            state_after_slow
    type(field_type), dimension(nummr), intent(in) :: mr, mr_n, mr_after_slow, &
                                                      mr_after_adv

    type(field_type), intent(in) :: du_fast, dtheta_fast

    type(field_collection_type), intent(in) :: derived_fields, &
                                               cloud_fields_after_slow, &
                                               cloud_fields_after_adv

    type(field_type) :: dtheta_tot, du_w2_tot, du_tot, dv_tot, dw_tot,    &
                        dmv_tot, dmcl_tot, dmci_tot, dtheta_adv,          &
                        du_w2_adv, du_adv, dv_adv, dw_adv, dmv_adv,       &
                        dmcl_adv, dmci_adv, dbcf_adv, dcfl_adv, dcff_adv, &
                        dtheta_solv, du_w2_solv, du_solv, dv_solv, dw_solv

    type(field_type), pointer :: u_star => null()
    type(field_type), pointer :: theta_star => null()
    type(field_type), pointer :: bcf_after_slow => null()
    type(field_type), pointer :: bcf_after_adv => null()
    type(field_type), pointer :: cfl_after_slow => null()
    type(field_type), pointer :: cfl_after_adv => null()
    type(field_type), pointer :: cff_after_slow => null()
    type(field_type), pointer :: cff_after_adv => null()

    if ( subroutine_timers ) call timer ("si_diagnostics")

    ! Total increments
    ! Difference between current value (X) and X_n
    dtheta_tot_flag = .true.
    if (dtheta_tot_flag) then
      call state(igh_t)%copy_field_properties(dtheta_tot)
      call invoke(X_minus_Y(dtheta_tot,state(igh_t),state_n(igh_t)))
      call dtheta_tot%write_field('processed__dtheta_tot')
    end if

    du_tot_flag = .true.
    dv_tot_flag = .true.
    dw_tot_flag = .true.
    if (du_tot_flag .or. dv_tot_flag .or. dw_tot_flag) then
      call state(igh_u)%copy_field_properties(du_w2_tot)
      call state(igh_p)%copy_field_properties(du_tot)
      call state(igh_p)%copy_field_properties(dv_tot)
      call state(igh_p)%copy_field_properties(dw_tot)
      call invoke(X_minus_Y(du_w2_tot,state(igh_u),state_n(igh_u)))
      call map_physics_winds(du_tot,dv_tot,dw_tot,du_w2_tot)
    end if
    if (du_tot_flag) call du_tot%write_field('processed__du_tot')
    if (dv_tot_flag) call dv_tot%write_field('processed__dv_tot')
    if (dw_tot_flag) call dw_tot%write_field('processed__dw_tot')

    dmv_tot_flag = .true.
    if (dmv_tot_flag) then
      call mr(imr_v)%copy_field_properties(dmv_tot)
      call invoke(X_minus_Y(dmv_tot,mr(imr_v),mr_n(imr_v)))
      call dmv_tot%write_field('processed__dmv_tot')
    end if

    dmcl_tot_flag = .true.
    if (dmcl_tot_flag) then
      call mr(imr_cl)%copy_field_properties(dmcl_tot)
      call invoke(X_minus_Y(dmcl_tot,mr(imr_cl),mr_n(imr_cl)))
      call dmcl_tot%write_field('processed__dmcl_tot')
    end if

    dmci_tot_flag = .true.
    if (dmci_tot_flag) then
      call mr(imr_ci)%copy_field_properties(dmci_tot)
      call invoke(X_minus_Y(dmci_tot,mr(imr_ci),mr_n(imr_ci)))
      call dmci_tot%write_field('processed__dmci_tot')
    end if

    ! These diagnostics use the predictor values, hence only make sense with
    ! physics on
    if (use_physics) then

      ! Advection increments
      ! Difference between X_after_adv or X_star and X_after_slow
      dtheta_adv_flag = .true.
      if (dtheta_adv_flag) then
        theta_star => derived_fields%get_field('theta_star')
        call theta_star%copy_field_properties(dtheta_adv)
        call invoke(X_minus_Y(dtheta_adv,theta_star,state_after_slow(igh_t)))
        call dtheta_adv%write_field('advection__dtheta_adv')
      end if

      du_adv_flag = .true.
      dv_adv_flag = .true.
      dw_adv_flag = .true.
      if (du_adv_flag .or. dv_adv_flag .or. dw_adv_flag) then
        u_star => derived_fields%get_field('u_star')
        call state(igh_u)%copy_field_properties(du_w2_adv)
        call state(igh_p)%copy_field_properties(du_adv)
        call state(igh_p)%copy_field_properties(dv_adv)
        call state(igh_p)%copy_field_properties(dw_adv)
        call invoke(X_minus_Y(du_w2_adv,u_star,state_after_slow(igh_u)))
        call map_physics_winds(du_adv,dv_adv,dw_adv,du_w2_adv)
      end if
      if (du_adv_flag) call du_adv%write_field('advection__du_adv')
      if (dv_adv_flag) call dv_adv%write_field('advection__dv_adv')
      if (dw_adv_flag) call dw_adv%write_field('advection__dw_adv')

      dmv_adv_flag = .true.
      if (dmv_adv_flag .and. moisture_formulation /= moisture_formulation_dry) then
        call mr(imr_v)%copy_field_properties(dmv_adv)
        call invoke(X_minus_Y(dmv_adv,mr_after_adv(imr_v),mr_after_slow(imr_v)))
        call dmv_adv%write_field('advection__dmv_adv')
      end if

      dmcl_adv_flag = .true.
      if (dmcl_adv_flag .and. moisture_formulation /= moisture_formulation_dry) then
        call mr(imr_cl)%copy_field_properties(dmcl_adv)
        call invoke(X_minus_Y(dmcl_adv,mr_after_adv(imr_cl),mr_after_slow(imr_cl)))
        call dmcl_adv%write_field('advection__dmcl_adv')
      end if

      dmci_adv_flag = .true.
      if (dmci_adv_flag .and. moisture_formulation /= moisture_formulation_dry) then
        call mr(imr_ci)%copy_field_properties(dmci_adv)
        call invoke(X_minus_Y(dmci_adv,mr_after_adv(imr_ci),mr_after_slow(imr_ci)))
        call dmci_adv%write_field('advection__dmci_adv')
      end if

      dbcf_adv_flag = .true.
      if (dbcf_adv_flag .and. cloud_fields_after_slow%get_length() > 0) then
        bcf_after_slow => cloud_fields_after_slow%get_field('bulk_fraction')
        bcf_after_adv => cloud_fields_after_adv%get_field('bulk_fraction')
        call bcf_after_slow%copy_field_properties(dbcf_adv)
        call invoke(X_minus_Y(dbcf_adv,bcf_after_adv,bcf_after_slow))
        call dbcf_adv%write_field('advection__dbcf_adv')
      end if

      dcfl_adv_flag = .true.
      if (dcfl_adv_flag .and. cloud_fields_after_slow%get_length() > 0) then
        cfl_after_slow => cloud_fields_after_slow%get_field('liquid_fraction')
        cfl_after_adv => cloud_fields_after_adv%get_field('liquid_fraction')
        call cfl_after_slow%copy_field_properties(dcfl_adv)
        call invoke(X_minus_Y(dcfl_adv,cfl_after_adv,cfl_after_slow))
        call dcfl_adv%write_field('advection__dcfl_adv')
      end if

      dcff_adv_flag = .true.
      if (dcff_adv_flag .and. cloud_fields_after_slow%get_length() > 0) then
        cff_after_slow => cloud_fields_after_slow%get_field('frozen_fraction')
        cff_after_adv => cloud_fields_after_adv%get_field('frozen_fraction')
        call cff_after_slow%copy_field_properties(dcff_adv)
        call invoke(X_minus_Y(dcff_adv,cff_after_adv,cff_after_slow))
        call dcff_adv%write_field('advection__dcff_adv')
      end if

      ! Solver increments
      ! Difference between current value (X) and X_star+dX_fast_physics
      dtheta_solv_flag = .true.
      if (dtheta_solv_flag) then
        theta_star => derived_fields%get_field('theta_star')
        call dtheta_fast%copy_field_properties(dtheta_solv)
        call invoke(X_minus_Y(dtheta_solv,state(igh_t),theta_star), &
                inc_X_minus_Y(dtheta_solv,dtheta_fast))
        call dtheta_solv%write_field('solver__dtheta_solv')
      end if

      du_solv_flag = .true.
      dv_solv_flag = .true.
      dw_solv_flag = .true.
      if (du_solv_flag .or. dv_solv_flag .or. dw_solv_flag) then
        u_star => derived_fields%get_field('u_star')
        call state(igh_u)%copy_field_properties(du_w2_solv)
        call state(igh_p)%copy_field_properties(du_solv)
        call state(igh_p)%copy_field_properties(dv_solv)
        call state(igh_p)%copy_field_properties(dw_solv)
        call invoke(X_minus_Y(du_w2_solv,state(igh_u),u_star), &
                inc_X_minus_Y(du_w2_solv,du_fast))
        call map_physics_winds(du_solv,dv_solv,dw_solv,du_w2_solv)
      end if
      if (du_solv_flag) call du_solv%write_field('solver__du_solv')
      if (dv_solv_flag) call dv_solv%write_field('solver__dv_solv')
      if (dw_solv_flag) call dw_solv%write_field('solver__dw_solv')

    end if

    if ( subroutine_timers ) call timer ("si_diagnostics")

  end subroutine output_diags_for_si

end module si_diagnostics_mod
