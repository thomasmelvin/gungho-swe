!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Compute the advective update A of a Wtheta variable f by a wind U: A = U.grad(f).
!> @todo There are number of workarounds in this algorithm for aspects which
!!       aren't yet supported by PSyclone/LFRic:
!!       1. Issue #868 Multidata fields are not natively supported in PSyclone.
!!                     Currently we treat these as normal fields but need to
!!                     additionally pass in ndata_h or ndata_v to the kernels
!!                     as extra integer arguments.
!!       2. Issue #1246 Region stencils require both the global maximum size of
!!                      the stencil and local column size of the stencil.
!!                      PSyclone currently only passes in the local size and so
!!                      until this is resolved we also pass in the global maximum
!!                      size as an integer argument.
module wt_advective_update_alg_mod

  use constants_mod,                      only: r_def, i_def, l_def, str_def
  use extrusion_mod,                      only: TWOD
  use geometric_constants_mod,            only: get_coordinates,                &
                                                get_panel_id,                   &
                                                get_height
  use fem_constants_mod,                  only: get_mass_matrix_diagonal,       &
                                                get_inverse_lumped_mass_matrix, &
                                                get_rmultiplicity
  use field_mod,                          only: field_type
  use finite_element_config_mod,          only: element_order,          &
                                                nqp_exact,              &
                                                coord_system,           &
                                                coord_system_xyz
  use fs_continuity_mod,                  only: W1, W3, Wtheta
  use function_space_mod,                 only: function_space_type
  use function_space_collection_mod,      only: function_space_collection
  use quadrature_rule_gauss_lobatto_mod,  only: quadrature_rule_gauss_lobatto_type
  use quadrature_rule_gaussian_mod,       only: quadrature_rule_gaussian_type
  use quadrature_xyoz_mod,                only: quadrature_xyoz_type
  use quadrature_face_mod,                only: quadrature_face_type
  use quadrature_edge_mod,                only: quadrature_edge_type
  use transport_config_mod,               only: operators,            &
                                                fv_horizontal_order,  &
                                                fv_Vertical_order,    &
                                                operators_fv,         &
                                                operators_fem,        &
                                                oned_reconstruction,  &
                                                consistent_metric
  use log_mod,                            only: log_event,         &
                                                LOG_LEVEL_ERROR,   &
                                                LOG_LEVEL_INFO
  use mesh_collection_mod,                only: mesh_collection
  use mesh_mod,                           only: mesh_type
  use poly1d_adv_recon_kernel_mod,        only: poly1d_adv_recon_kernel_type
  use poly1d_vert_adv_coeffs_kernel_mod,  only: poly1d_vert_adv_coeffs_kernel_type
  use poly1d_advective_coeffs_kernel_mod, only: poly1d_advective_coeffs_kernel_type
  use poly2d_advective_coeffs_kernel_mod, only: poly2d_advective_coeffs_kernel_type
  use poly2d_adv_recon_kernel_mod,        only: poly2d_adv_recon_kernel_type
  use poly_advective_kernel_mod,          only: poly_advective_kernel_type
  use runtime_tools_mod,                  only: find_mesh_index, &
                                                check_initialised_field
  use transport_enumerated_types_mod,     only: direction_v,    &
                                                direction_h,    &
                                                direction_3d
  use polyh_wtheta_koren_kernel_mod,      only: polyh_wtheta_koren_kernel_type
  use polyv_wtheta_koren_kernel_mod,      only: polyv_wtheta_koren_kernel_type
  implicit none

  private

  logical(kind=l_def) :: variables_allocated = .false.

  integer(kind=i_def), allocatable, target :: adv_stencil_extent_list(:)
  integer(kind=i_def), allocatable, target :: adv_2d_stencil_size_list(:)
  integer(kind=i_def), allocatable, target :: ndata_h_list(:)
  integer(kind=i_def), allocatable, target :: ndata_v_list(:)
  integer(kind=i_def), allocatable, target :: reversible_ndata_v_list(:)
  type(field_type),    allocatable, target :: adv_coeffs_list(:)
  type(field_type),    allocatable, target :: vert_adv_coeffs_list(:)
  type(field_type),    allocatable, target :: reversible_vert_adv_coeffs_list(:)

  public  :: wt_advective_update_set_num_meshes
  public  :: wt_advective_update_alg_init
  public  :: wt_advective_update_alg_final
  public  :: wt_advective_update_alg
  public  :: wt_advective_update_koren_alg
  public  :: get_adv_stencil_extent
  public  :: get_adv_2d_stencil_size
  public  :: get_adv_ndata_h
  public  :: get_adv_ndata_v
  public  :: get_reversible_adv_ndata_v
  public  :: get_adv_coeffs
  public  :: get_vert_adv_coeffs
  public  :: get_reversible_vert_adv_coeffs
  public  :: horizontal_wt_reconstruct_alg
  public  :: horizontal_wt_reconstruct_koren_alg

contains

  !=============================================================================
  !> @brief Allocates the lists of advection coefficients.
  !!
  !> @param[in] number_of_meshes Number of meshes to have coefficients on.
  subroutine wt_advective_update_set_num_meshes( number_of_meshes )

    implicit none

    integer(kind=i_def), intent(in) :: number_of_meshes

    if (.not. variables_allocated) then
      if (.not. allocated(adv_stencil_extent_list)) allocate(adv_stencil_extent_list(number_of_meshes))
      if (.not. allocated(adv_2d_stencil_size_list)) allocate(adv_2d_stencil_size_list(number_of_meshes))
      if (.not. allocated(ndata_h_list)) allocate(ndata_h_list(number_of_meshes))
      if (.not. allocated(ndata_v_list)) allocate(ndata_v_list(number_of_meshes))
      if (.not. allocated(reversible_ndata_v_list)) allocate(reversible_ndata_v_list(number_of_meshes))
      if (.not. allocated(adv_coeffs_list)) allocate(adv_coeffs_list(number_of_meshes))
      if (.not. allocated(vert_adv_coeffs_list)) allocate(vert_adv_coeffs_list(number_of_meshes))
      if (.not. allocated(reversible_vert_adv_coeffs_list)) allocate(reversible_vert_adv_coeffs_list(number_of_meshes))

      variables_allocated = .true.
    else
      call log_event('Variables have already been allocated for ' // &
                     'wt_advective_update_alg', LOG_LEVEL_ERROR)
    end if

  end subroutine wt_advective_update_set_num_meshes

  !=============================================================================
  !> @brief Initialises the advection coefficients for a single mesh.
  !!
  !> @details Initialises the advection coefficients and other constants that
  !!          can be pre-computed for a single mesh.
  !!          FV aspects currently only support lowest order elements.
  !!
  !> @param[in] mesh The mesh to create all fields on
  !!
  subroutine wt_advective_update_alg_init( mesh )

    use reference_element_mod,   only: reference_element_type
    use mesh_mod,                only: mesh_type
    use geometric_constants_mod, only: get_height
    use transport_config_mod,    only: reversible

    implicit none

    type(mesh_type), pointer, intent(in) :: mesh

    integer(kind=i_def)             :: mesh_index
    integer(kind=i_def)             :: adv_stencil_size
    integer(kind=i_def)             :: adv_stencil_extent
    integer(kind=i_def)             :: adv_2d_stencil_size
    integer(kind=i_def)             :: ndata_h
    integer(kind=i_def)             :: ndata_v
    integer(kind=i_def)             :: nfaces_re_h
    integer(kind=i_def)             :: nfaces_re_v
    integer(kind=i_def)             :: polynomial
    logical(kind=l_def)             :: horizontal_edges
    logical(kind=l_def)             :: vertical_edges
    type(field_type),       pointer :: chi(:) => null()
    type(field_type),       pointer :: md_wt => null()
    type(field_type),       pointer :: panel_id => null()
    type(mesh_type),        pointer :: twod_mesh => null()

    type(quadrature_rule_gaussian_type)      :: gaussian_quadrature
    type(quadrature_rule_gauss_lobatto_type) :: gauss_lobatto_quadrature

    type(quadrature_xyoz_type)             :: qr
    type(quadrature_edge_type)             :: qre
    type(function_space_type),     pointer :: w1_fs => null()
    type(function_space_type),     pointer :: wt_fs => null()
    type(field_type)                       :: wt_field
    class(reference_element_type), pointer :: reference_element => null()

    integer(kind=i_def)                    :: edge_quad_order
    integer(kind=i_def)                    :: nqp_xy, nqp_z, nqp_xyz
    real(kind=r_def)                       :: transform_radius, chi3_max
    type(function_space_type),     pointer :: multidata_fs => null()
    type(field_type),              pointer :: height => null()
    integer(kind=i_def)                    :: vertical_order, nlayers

    reference_element => mesh%get_reference_element()
    mesh_index = find_mesh_index(mesh%get_id())

    ! Set default values of 0 for the integers to be stored for this mesh_id,
    ! in case they aren't set below
    adv_stencil_extent = 0_i_def
    adv_2d_stencil_size = 0_i_def
    ndata_h = 0_i_def
    ndata_v = 0_i_def
    twod_mesh => mesh_collection%get_mesh(mesh, TWOD)
    nlayers = mesh%get_nlayers()

    w1_fs => function_space_collection%get_fs( mesh, element_order, W1 )
    wt_fs => function_space_collection%get_fs( mesh, element_order, Wtheta )

    if ( operators == operators_fv ) then
      ! This setup is only needed for FV methods
      if ( element_order == 0_i_def ) then

        ! Compute stencil extents
        adv_stencil_extent = int(real(fv_horizontal_order+1_i_def)/2.0_r_def,i_def)
        !======================================================================!
        ! Compute stencil for nonuniform polynomial fit
        ! Initialise PSy layer arrays (this will not be needed when
        ! multi-dimensional field arrays are supported)
        ! This needs some temporary fields for computing undf in the PSy layer
        md_wt => get_mass_matrix_diagonal(Wtheta, mesh%get_id())
        call wt_field%initialise( vector_space = wt_fs )

        ! Get topology information from the reference element
        ! Number of horizontal neighbours
        nfaces_re_h = reference_element%get_number_horizontal_faces()
        ! Number of vertical neighbours
        nfaces_re_v = reference_element%get_number_vertical_faces()
        if ( oned_reconstruction ) then
          adv_stencil_size = fv_horizontal_order + 1_i_def
        else
          adv_2d_stencil_size = 1_i_def
          do polynomial = 1, fv_horizontal_order
            if ( mod(polynomial, 2_i_def) == 0_i_def ) then
              adv_2d_stencil_size = adv_2d_stencil_size + nfaces_re_h
            else
              adv_2d_stencil_size = adv_2d_stencil_size + nfaces_re_h*polynomial
            end if
          end do
          adv_stencil_size = adv_2d_stencil_size
        end if

        ! Create multi-data space and field for the horizontal advective coefficients
        ndata_h = nfaces_re_h*adv_stencil_size
        ndata_h_list(mesh_index) = ndata_h
        multidata_fs => function_space_collection%get_fs( twod_mesh, element_order, W3, ndata_h )
        call adv_coeffs_list(mesh_index)%initialise( vector_space = multidata_fs, ndata_first = .false. )

        chi => get_coordinates(mesh%get_id())
        panel_id => get_panel_id(mesh%get_id())

        if ( coord_system == coord_system_xyz ) then
          transform_radius = 0.0_r_def
        else
          ! Compute the smallest surface height of chi(3)
          ! (this is only needed for spherically-based coordinates
          ! Transform radius is minimum height + 1
          call chi(3)%field_minmax(transform_radius, chi3_max)
          transform_radius = 1.0_r_def + abs(transform_radius)
        end if

        nqp_xyz = fv_horizontal_order + 1_i_def
        if ( oned_reconstruction ) then
          edge_quad_order = 1_i_def
        else
          edge_quad_order = fv_horizontal_order + 1_i_def
        end if

        ! Compute advective coefficients
        call log_event( "Gungho: computing horizontal advective coeffs", LOG_LEVEL_INFO )
        ! Quadrature rule which has enough points to exactly integrate
        ! fv_horizontal_order polynomials and is odd order horizontaly and has
        ! 2 vertical points such that it gives points on the vertical faces
        nqp_xy = fv_horizontal_order + 3_i_def
        nqp_z  = 2_i_def
        qr = quadrature_xyoz_type(nqp_xy, nqp_xy, nqp_z, &
                                  gauss_lobatto_quadrature)
        ! Edge based quadrature rule on horizontal edges
        nqp_xyz = edge_quad_order
        horizontal_edges = .true.
        vertical_edges = .false.
        qre = quadrature_edge_type(nqp_xyz, horizontal_edges, vertical_edges,  &
                                   reference_element, gaussian_quadrature)

        if ( oned_reconstruction ) then
          call invoke( poly1d_advective_coeffs_kernel_type(                    &
                                               adv_coeffs_list(mesh_index),    &
                                               md_wt,                          &
                                               adv_stencil_extent,             &
                                               chi,                            &
                                               adv_stencil_extent,             &
                                               panel_id,                       &
                                               adv_stencil_extent,             &
                                               ndata_h, fv_horizontal_order,   &
                                               nfaces_re_h, transform_radius,  &
                                               nlayers, qr, qre ) )
        else
          call invoke( poly2d_advective_coeffs_kernel_type(                    &
                                               adv_coeffs_list(mesh_index),    &
                                               md_wt,                          &
                                               adv_stencil_extent,             &
                                               chi,                            &
                                               adv_stencil_extent,             &
                                               panel_id,                       &
                                               adv_stencil_extent,             &
                                               ndata_h, fv_horizontal_order,   &
                                               nfaces_re_h,                    &
                                               adv_2d_stencil_size,            &
                                               transform_radius, nlayers,      &
                                               qr, qre ) )
        end if
        ! Vertical advective coeffs
        call log_event( "Gungho: computing vertical advective coeffs", LOG_LEVEL_INFO )

        ! Create multi-data space and field for the vertical advective coefficients
        vertical_order = fv_vertical_order + 1_i_def
        ndata_v = nfaces_re_v*(vertical_order + 1_i_def)
        ndata_v_list(mesh_index) = ndata_v
        multidata_fs => function_space_collection%get_fs( mesh, element_order, Wtheta, ndata_v )
        call vert_adv_coeffs_list(mesh_index)%initialise( vector_space = multidata_fs, ndata_first = .true. )
        height => get_height(Wtheta, mesh%get_id())
        call invoke( poly1d_vert_adv_coeffs_kernel_type(                       &
                                            vert_adv_coeffs_list(mesh_index),  &
                                            height, ndata_v,                   &
                                            vertical_order) )

        if ( any(reversible) ) then
          ! Compute reversible vertical coefficients
          vertical_order = fv_vertical_order
          ndata_v = nfaces_re_v*(vertical_order + 1_i_def)
          reversible_ndata_v_list(mesh_index) = ndata_v
          multidata_fs => function_space_collection%get_fs( mesh, element_order, Wtheta, ndata_v )
          call reversible_vert_adv_coeffs_list(mesh_index)%initialise( vector_space = multidata_fs, ndata_first = .true. )
          height => get_height(Wtheta, mesh%get_id())
          call invoke( poly1d_vert_adv_coeffs_kernel_type(                                  &
                                              reversible_vert_adv_coeffs_list(mesh_index),  &
                                              height, ndata_v,                              &
                                              vertical_order) )
        end if
        !======================================================================!
      else
        call log_event( "Gungho: subgrid mappings needed for FV MoL with high &
                         order elements", LOG_LEVEL_ERROR )
      end if
    end if

    adv_stencil_extent_list(mesh_index) = adv_stencil_extent
    adv_2d_stencil_size_list(mesh_index) = adv_2d_stencil_size

    nullify( chi, panel_id, md_wt, wt_fs, w1_fs, reference_element, height, twod_mesh )

  end subroutine wt_advective_update_alg_init

  !=============================================================================
  !> @brief Finalises allocatable arrays.
  subroutine wt_advective_update_alg_final()

    implicit none

    if (allocated(vert_adv_coeffs_list)) deallocate(vert_adv_coeffs_list)
    if (allocated(reversible_vert_adv_coeffs_list)) deallocate(reversible_vert_adv_coeffs_list)
    if (allocated(adv_coeffs_list)) deallocate(adv_coeffs_list)
    if (allocated(ndata_v_list)) deallocate(ndata_v_list)
    if (allocated(ndata_h_list)) deallocate(ndata_h_list)
    if (allocated(reversible_ndata_v_list)) deallocate(reversible_ndata_v_list)
    if (allocated(adv_2d_stencil_size_list)) deallocate(adv_2d_stencil_size_list)
    if (allocated(adv_stencil_extent_list)) deallocate(adv_stencil_extent_list)

  end subroutine wt_advective_update_alg_final

  !=============================================================================
  !> @brief Compute the horizontal reconstruction of a Wtheta field.
  !> @param[in,out] h_reconstruction  Horiz. reconstruction in W1 of a Wtheta field
  !> @param[in]     wind              Advecting wind field
  !> @param[in]     field             Wtheta field to advect
  subroutine horizontal_wt_reconstruct_alg(h_reconstruction, wind, field)
    use sample_field_kernel_mod, only: sample_field_kernel_type

    implicit none

    type(field_type),              intent(in)    :: field, wind
    type(field_type),              intent(inout) :: h_reconstruction

    type(field_type), pointer :: adv_coeffs => null()
    type(field_type), pointer :: w1_rmultiplicity => null()

    type(mesh_type), pointer :: mesh => null()

    integer(kind=i_def)          :: mesh_index
    integer(kind=i_def), pointer :: adv_stencil_extent => null()
    integer(kind=i_def), pointer :: adv_2d_stencil_size => null()
    integer(kind=i_def), pointer :: ndata_h => null()

    mesh => wind%get_mesh()
    mesh_index = find_mesh_index(mesh%get_id())
    adv_stencil_extent => adv_stencil_extent_list(mesh_index)
    adv_2d_stencil_size => adv_2d_stencil_size_list(mesh_index)
    ndata_h => ndata_h_list(mesh_index)
    adv_coeffs => adv_coeffs_list(mesh_index)
    w1_rmultiplicity => get_rmultiplicity(W1, mesh%get_id())

    select case(operators)

    case(operators_fv)
      ! Set default value (for h_reconstruction)
      ! to be average of the field at W1 points and then update where the wind
      ! is non-zero using an upwind reconstruction
      call invoke( setval_c(h_reconstruction, 0.0_r_def),     &
                   sample_field_kernel_type(h_reconstruction, &
                                            w1_rmultiplicity, &
                                            field) )

      if ( oned_reconstruction ) then
        ! Use 1d reconstruction
        call invoke( poly1d_adv_recon_kernel_type(                &
                                              h_reconstruction,   &
                                              wind, field,        &
                                              adv_stencil_extent, &
                                              adv_coeffs,         &
                                              ndata_h,            &
                                              fv_horizontal_order ) )
      else
        ! Use 2d reconstruction
        call invoke( poly2d_adv_recon_kernel_type(                &
                                              h_reconstruction,   &
                                              wind, field,        &
                                              adv_stencil_extent, &
                                              adv_coeffs,         &
                                              ndata_h,            &
                                              adv_2d_stencil_size ) )
      end if

    case default
      call log_event( "Gungho: Unrecognised option for wtheta reconstruction.", LOG_LEVEL_ERROR )

    end select

    nullify( adv_coeffs,                  &
             w1_rmultiplicity, ndata_h,   &
             adv_stencil_extent,          &
             adv_2d_stencil_size, mesh )

  end subroutine horizontal_wt_reconstruct_alg

  !=============================================================================
  !> @brief Reconstruction of a Wtheta field with the Koren scheme.
  !> @param[in,out] h_reconstruction  Horiz. reconstruction in W1 of a Wtheta field
  !> @param[in]     wind              Advecting wind field
  !> @param[in]     field             Wtheta field to advect
  subroutine horizontal_wt_reconstruct_koren_alg(h_reconstruction, wind, field)
    use sample_field_kernel_mod, only: sample_field_kernel_type

    implicit none

    type(field_type),  intent(in)    :: field, wind
    type(field_type),  intent(inout) :: h_reconstruction

    type(field_type), pointer    :: w1_rmultiplicity => null()
    type(mesh_type), pointer     :: mesh => null()
    integer(kind=i_def)          :: mesh_index
    integer(kind=i_def), pointer :: adv_stencil_extent => null()
    integer(kind=i_def), pointer :: ndata_h => null()

    mesh => wind%get_mesh()
    mesh_index = find_mesh_index(mesh%get_id())
    adv_stencil_extent => adv_stencil_extent_list(mesh_index)
    ndata_h => ndata_h_list(mesh_index)
    w1_rmultiplicity => get_rmultiplicity(W1, mesh%get_id())

    ! Set default value (for h_reconstruction)
    ! to be average of the field at W1 points and then update where the wind
    ! is non-zero using an upwind reconstruction
    call invoke( setval_c(h_reconstruction, 0.0_r_def),     &
                 sample_field_kernel_type(h_reconstruction, &
                                          w1_rmultiplicity, &
                                          field) )

    call invoke( polyh_wtheta_koren_kernel_type(                    &
                                                h_reconstruction,   &
                                                wind,               &
                                                field,              &
                                                adv_stencil_extent, &
                                                ndata_h           ) )

    nullify( w1_rmultiplicity, mesh, ndata_h, adv_stencil_extent )

  end subroutine horizontal_wt_reconstruct_koren_alg

  !=============================================================================
  !> @brief Compute advective update of a Wtheta field.
  !> @details Compute advective update wind.grad(adv_field) using desired spatial
  !!          reconstruction. Options for this are either FE or FV reconstructions.
  !!          A monotonicity filter is also optionally applied
  !> @param[in,out] rhs          Advective increment
  !> @param[in]     adv_field    Field to advect
  !> @param[in]     wind         Advecting wind field
  !> @param[in]     dt           Timestep
  !> @param[in]     reversible   Use the reversible reconstruction
  !> @param[in]     logspace     Carry out interpolation in log space
  !> @param[in]     monotonicity Choice of monontonic limiter
  subroutine wt_advective_update_alg(rhs, adv_field, wind, dt, direction, reversible, monotonicity, logspace)

    use consistent_wind_kernel_mod,     only: consistent_wind_kernel_type
    use poly1d_vert_adv_kernel_mod,     only: poly1d_vert_adv_kernel_type
    use rtheta_kernel_mod,              only: rtheta_kernel_type
    use rtheta_bd_kernel_mod,           only: rtheta_bd_kernel_type
    use monotonic_update_kernel_mod,    only: monotonic_update_kernel_type
    use reference_element_mod,          only: reference_element_type
    use mesh_mod,                       only: mesh_type
    use transport_enumerated_types_mod, only: monotone_clipping

    implicit none

    type(field_type),              intent(in)    :: adv_field, wind
    type(field_type),              intent(inout) :: rhs
    real(kind=r_def),              intent(in)    :: dt
    integer(kind=i_def),           intent(in)    :: direction
    integer(kind=i_def),           intent(in)    :: monotonicity
    logical(kind=l_def),           intent(in)    :: reversible
    logical(kind=l_def), optional, intent(in)    :: logspace


    type(field_type)                       :: u_grad_f
    type(field_type)                       :: h_reconstruction
    type(field_type), pointer              :: chi(:) => null()
    type(field_type), pointer              :: mt_lumped_inv => null()
    type(field_type)                       :: consistent_wind
    type(field_type)                       :: u_grad_z
    type(field_type), pointer              :: vert_adv_coeffs => null()
    type(field_type), pointer              :: height => null()
    type(function_space_type), pointer     :: w1_fs => null()
    class(reference_element_type), pointer :: reference_element => null()
    type(mesh_type), pointer               :: mesh => null()
    type(quadrature_xyoz_type)             :: qr
    type(quadrature_face_type)             :: qrf
    type(quadrature_rule_gaussian_type)    :: quadrature_rule
    integer(kind=i_def)                    :: mono_stencil, mesh_index
    logical(kind=l_def)                    :: logspace_loc
    integer(kind=i_def), pointer           :: ndata_v => null()
    logical(kind=l_def)                    :: horizontal_faces
    logical(kind=l_def)                    :: vertical_faces
    integer(kind=i_def)                    :: wt_stencil_size
    integer(kind=i_def)                    :: w2_stencil_size
    integer(kind=i_def)                    :: vertical_order

    logspace_loc = .false.
    if ( present(logspace) ) then
      logspace_loc = logspace
    end if

    mesh => wind%get_mesh()

    reference_element => mesh%get_reference_element()
    mesh_index = find_mesh_index(mesh%get_id())

    call u_grad_f%initialise( adv_field%get_function_space() )

    select case(operators)

    case default
      call log_event( "Gungho: Unrecognised option for wtheta reconstruction.", LOG_LEVEL_ERROR )

    case(operators_fv)
      ! Consistent winds will be used for vertical transport
      ! For now set these to be the normal winds and adjust later if needed
      call consistent_wind%initialise ( wind%get_function_space() )
      call invoke( setval_X(consistent_wind, wind) )

      if ( direction == direction_3d .or. direction == direction_h ) then
        ! Horizontal update
        w1_fs => function_space_collection%get_fs( mesh, element_order, W1 )
        call h_reconstruction%initialise( w1_fs )
        call horizontal_wt_reconstruct_alg(h_reconstruction, wind, adv_field)
        ! Compute horizontal advective update
        call invoke( poly_advective_kernel_type(u_grad_f, wind, h_reconstruction) )

        ! Adjust consistent wind field
        if ( consistent_metric ) then
          height => get_height(Wtheta, mesh%get_id())
          chi => get_coordinates(mesh%get_id())
          call u_grad_z%initialise( u_grad_f%get_function_space() )
          call horizontal_wt_reconstruct_alg(h_reconstruction, wind, height)
          call invoke( poly_advective_kernel_type(u_grad_z, wind,         &
                                                  h_reconstruction),      &
                       consistent_wind_kernel_type(consistent_wind, wind, &
                                                   u_grad_z, chi(3)) )
        end if
      else
        call invoke( setval_c( u_grad_f, 0.0_r_def ) )
      end if

      if ( direction == direction_3d .or. direction == direction_v ) then
        ! vertical update
        if ( reversible ) then
          ndata_v => reversible_ndata_v_list(mesh_index)
          vert_adv_coeffs => reversible_vert_adv_coeffs_list(mesh_index)
          vertical_order = fv_vertical_order
        else
          ndata_v => ndata_v_list(mesh_index)
          vert_adv_coeffs => vert_adv_coeffs_list(mesh_index)
          vertical_order = fv_vertical_order + 1_i_def
        end if
        call invoke( poly1d_vert_adv_kernel_type( u_grad_f,        &
                                                  consistent_wind, &
                                                  adv_field,       &
                                                  vert_adv_coeffs, &
                                                  ndata_v,         &
                                                  vertical_order,  &
                                                  logspace_loc ) )
      end if

    case(operators_fem)
      ! Perform 3D update using FEM operators
      if ( direction /= direction_3d ) &
        call log_event( "Gungho: FEM Wt advection requires unsplit method", LOG_LEVEL_ERROR )

      ! Use project u.grad(adv_field) into the adv_field function space
      qr = quadrature_xyoz_type(nqp_exact, quadrature_rule)

      ! Quadrature rule on lateral faces only
      horizontal_faces = .true.
      vertical_faces = .false.
      qrf = quadrature_face_type(nqp_exact, horizontal_faces, vertical_faces, &
                                 reference_element, quadrature_rule)
      wt_stencil_size = 1_i_def
      w2_stencil_size = 1_i_def
      call invoke( setval_c(u_grad_f, 0.0_r_def),                     &
                   rtheta_kernel_type(u_grad_f, adv_field, wind, qr), &
                   rtheta_bd_kernel_type(u_grad_f, adv_field,         &
                                         wt_stencil_size, wind,       &
                                         w2_stencil_size, qrf) )

    end select

    mt_lumped_inv => get_inverse_lumped_mass_matrix(Wtheta, mesh%get_id())
    ! Apply monotonicity (as if this is a full timestep)
    if ( monotonicity == monotone_clipping ) then
      if ( operators == operators_fem ) then
        mono_stencil = 1_i_def
      else
        mono_stencil = fv_horizontal_order / 2_i_def
      end if
      call invoke( monotonic_update_kernel_type(u_grad_f,                      &
                                                adv_field,                     &
                                                mono_stencil, mt_lumped_inv,   &
                                                dt, fv_horizontal_order) )
    end if

    ! Scale by lumped inverse mass matrix
    call invoke( X_times_Y(rhs, u_grad_f, mt_lumped_inv) )

    nullify( height, chi, mt_lumped_inv, vert_adv_coeffs, &
             reference_element, mesh, ndata_v )

  end subroutine wt_advective_update_alg
   !=============================================================================
  !> @brief Compute advective update of a Wtheta field using the Koren scheme.
  !> @details Compute advective update wind.grad(adv_field) using desired spatial
  !!          reconstruction. Options for this are either FE or FV reconstructions.
  !!          A monotonicity filter is also optionally applied
  !> @param[in,out] rhs          Advective increment
  !> @param[in]     adv_field    Field to advect
  !> @param[in]     wind         Advecting wind field
  !> @param[in]     logspace     Carry out interpolation in log space
  subroutine wt_advective_update_koren_alg(rhs, adv_field, wind, direction, logspace)

    use consistent_wind_kernel_mod,     only: consistent_wind_kernel_type
    use poly1d_vert_adv_kernel_mod,     only: poly1d_vert_adv_kernel_type
    use rtheta_kernel_mod,              only: rtheta_kernel_type
    use rtheta_bd_kernel_mod,           only: rtheta_bd_kernel_type
    use monotonic_update_kernel_mod,    only: monotonic_update_kernel_type
    use reference_element_mod,          only: reference_element_type
    use mesh_mod,                       only: mesh_type

    implicit none

    type(field_type),              intent(in)    :: adv_field, wind
    type(field_type),              intent(inout) :: rhs
    integer(kind=i_def),           intent(in)    :: direction
    logical(kind=l_def), optional, intent(in)    :: logspace

    type(field_type)                       :: u_grad_f
    type(field_type)                       :: h_reconstruction
    type(field_type), pointer              :: chi(:) => null()
    type(field_type), pointer              :: mt_lumped_inv => null()
    type(field_type)                       :: consistent_wind
    type(field_type)                       :: u_grad_z
    type(field_type), pointer              :: height => null()
    type(function_space_type), pointer     :: w1_fs => null()
    class(reference_element_type), pointer :: reference_element => null()
    type(mesh_type), pointer               :: mesh => null()
    type(quadrature_xyoz_type)             :: qr
    type(quadrature_face_type)             :: qrf
    type(quadrature_rule_gaussian_type)    :: quadrature_rule
    integer(kind=i_def)                    :: mesh_index
    logical(kind=l_def)                    :: logspace_loc
    integer(kind=i_def), pointer           :: ndata_v => null()
    logical(kind=l_def)                    :: horizontal_faces
    logical(kind=l_def)                    :: vertical_faces
    integer(kind=i_def)                    :: wt_stencil_size
    integer(kind=i_def)                    :: w2_stencil_size

    logspace_loc = .false.
    if ( present(logspace) ) then
      logspace_loc = logspace
    end if

    mesh => wind%get_mesh()
    reference_element => mesh%get_reference_element()
    mesh_index = find_mesh_index(mesh%get_id())

    call u_grad_f%initialise( adv_field%get_function_space() )

    select case(operators)

    case default
      call log_event( "Gungho: Unrecognised option for wtheta reconstruction.", LOG_LEVEL_ERROR )

    case(operators_fv)
      ! Consistent winds will be used for vertical transport
      ! For now set these to be the normal winds and adjust later if needed
      call consistent_wind%initialise ( wind%get_function_space() )
      call invoke( setval_X(consistent_wind, wind) )

      if ( direction == direction_3d .or. direction == direction_h ) then
        ! Horizontal update with the Koren scheme
        w1_fs => function_space_collection%get_fs( mesh, element_order, W1 )
        call h_reconstruction%initialise( w1_fs )
        call horizontal_wt_reconstruct_koren_alg(h_reconstruction, wind, adv_field)
        ! Compute horizontal advective update
        call invoke( poly_advective_kernel_type(u_grad_f, wind, h_reconstruction) )

        ! Adjust consistent wind field
        if ( consistent_metric ) then
          height => get_height(Wtheta, mesh%get_id())
          chi => get_coordinates(mesh%get_id())
          call u_grad_z%initialise( u_grad_f%get_function_space() )
          call horizontal_wt_reconstruct_koren_alg(h_reconstruction, wind, height)
          call invoke( poly_advective_kernel_type(u_grad_z, wind,         &
                                                  h_reconstruction),      &
                       consistent_wind_kernel_type(consistent_wind, wind, &
                                                   u_grad_z, chi(3)) )
        end if
      else
        call invoke( setval_c( u_grad_f, 0.0_r_def ) )
      end if

      if ( direction == direction_3d .or. direction == direction_v ) then
        ! vertical update with Koren scheme
        ndata_v => ndata_v_list(mesh_index)
        call invoke( polyv_wtheta_koren_kernel_type( u_grad_f,           &
                                                     consistent_wind,    &
                                                     adv_field,          &
                                                     ndata_v,            &
                                                     logspace_loc ) )
      end if


    case(operators_fem)
      ! Perform 3D update using FEM operators
      if ( direction /= direction_3d ) &
        call log_event( "Gungho: FEM Wt advection requires unsplit method", LOG_LEVEL_ERROR )

      ! Use project u.grad(adv_field) into the adv_field function space
      qr = quadrature_xyoz_type(nqp_exact, quadrature_rule)

      ! Quadrature rule on lateral faces only
      horizontal_faces = .true.
      vertical_faces = .false.
      qrf = quadrature_face_type(nqp_exact, horizontal_faces, vertical_faces, &
                                 reference_element, quadrature_rule)
      wt_stencil_size = 1_i_def
      w2_stencil_size = 1_i_def
      call invoke( setval_c(u_grad_f, 0.0_r_def),                     &
                   rtheta_kernel_type(u_grad_f, adv_field, wind, qr), &
                   rtheta_bd_kernel_type(u_grad_f, adv_field,         &
                                         wt_stencil_size, wind,       &
                                         w2_stencil_size, qrf) )

    end select

    ! rhs = u_grad_f * mt_lumped_inv
    mt_lumped_inv => get_inverse_lumped_mass_matrix(Wtheta, mesh%get_id())
    ! Scale by lumped inverse mass matrix
     call invoke( X_times_Y(rhs, u_grad_f, mt_lumped_inv) )

    nullify( height, chi, mt_lumped_inv,      &
             reference_element, mesh, ndata_v )

  end subroutine wt_advective_update_koren_alg

  !> @brief Returns a pointer to the advective stencil extent
  !> @param[in] mesh_id the ID of the mesh to get the object for
  !> @return The advective stencil extent
  function get_adv_stencil_extent(mesh_id) result(adv_stencil_extent)
    implicit none
    integer(kind=i_def), intent(in) :: mesh_id
    integer(kind=i_def)             :: mesh_index
    integer(kind=i_def),    pointer :: adv_stencil_extent

    mesh_index = find_mesh_index(mesh_id)
    adv_stencil_extent => adv_stencil_extent_list(mesh_index)

  end function get_adv_stencil_extent

  !> @brief Returns a pointer to the advective 2D stencil size
  !> @param[in] mesh_id the ID of the mesh to get the object for
  !> @return The advective 2D stencil size
  function get_adv_2d_stencil_size(mesh_id) result(adv_2d_stencil_size)
    implicit none
    integer(kind=i_def), intent(in) :: mesh_id
    integer(kind=i_def)             :: mesh_index
    integer(kind=i_def),    pointer :: adv_2d_stencil_size

    mesh_index = find_mesh_index(mesh_id)
    adv_2d_stencil_size => adv_2d_stencil_size_list(mesh_index)

  end function get_adv_2d_stencil_size

  !> @brief Returns a pointer to the number of horizontal data points
  !> @param[in] mesh_id the ID of the mesh to get the object for
  !> @return The ndata_h integer
  function get_adv_ndata_h(mesh_id) result(ndata_h)
    implicit none
    integer(kind=i_def), intent(in) :: mesh_id
    integer(kind=i_def)             :: mesh_index
    integer(kind=i_def),    pointer :: ndata_h

    mesh_index = find_mesh_index(mesh_id)
    ndata_h => ndata_h_list(mesh_index)

  end function get_adv_ndata_h

  !> @brief Returns a pointer to the number of vertical data points
  !> @param[in] mesh_id the ID of the mesh to get the object for
  !> @return The ndata_v integer
  function get_adv_ndata_v(mesh_id) result(ndata_v)
    implicit none
    integer(kind=i_def), intent(in) :: mesh_id
    integer(kind=i_def)             :: mesh_index
    integer(kind=i_def),    pointer :: ndata_v

    mesh_index = find_mesh_index(mesh_id)
    ndata_v => ndata_v_list(mesh_index)

  end function get_adv_ndata_v

  !> @brief Returns a pointer to the number of vertical data points
  !> @param[in] mesh_id the ID of the mesh to get the object for
  !> @return The ndata_v integer
  function get_reversible_adv_ndata_v(mesh_id) result(ndata_v)
    implicit none
    integer(kind=i_def), intent(in) :: mesh_id
    integer(kind=i_def)             :: mesh_index
    integer(kind=i_def),    pointer :: ndata_v

    mesh_index = find_mesh_index(mesh_id)
    ndata_v => reversible_ndata_v_list(mesh_index)

  end function get_reversible_adv_ndata_v

  !> @brief Returns a pointer to the advective coefficients
  !> @param[in] mesh_id the ID of the mesh to get the object for
  !> @return The advective coefficients field
  function get_adv_coeffs(mesh_id) result(adv_coeffs)
    implicit none
    integer(kind=i_def), intent(in) :: mesh_id
    integer(kind=i_def)             :: mesh_index
    type(field_type),       pointer :: adv_coeffs
    character(str_def)              :: field_name

    mesh_index = find_mesh_index(mesh_id)
    field_name = 'adv_coeffs'
    adv_coeffs => adv_coeffs_list(mesh_index)
    call check_initialised_field(adv_coeffs, field_name, mesh_id)

  end function get_adv_coeffs

  !> @brief Returns a pointer to the vertical advective coefficients
  !> @param[in] mesh_id the ID of the mesh to get the object for
  !> @return The vertical advective coefficient field
  function get_vert_adv_coeffs(mesh_id) result(vert_adv_coeffs)
    implicit none
    integer(kind=i_def), intent(in) :: mesh_id
    integer(kind=i_def)             :: mesh_index
    type(field_type),       pointer :: vert_adv_coeffs
    character(str_def)              :: field_name

    mesh_index = find_mesh_index(mesh_id)
    field_name = 'vert_adv_coeffs'
    vert_adv_coeffs => vert_adv_coeffs_list(mesh_index)
    call check_initialised_field(vert_adv_coeffs, field_name, mesh_id)

  end function get_vert_adv_coeffs

  !> @brief Returns a pointer to the reversible vertical advective coefficients
  !> @param[in] mesh_id the ID of the mesh to get the object for
  !> @return The vertical advective coefficient field
  function get_reversible_vert_adv_coeffs(mesh_id) result(vert_adv_coeffs)
    implicit none
    integer(kind=i_def), intent(in) :: mesh_id
    integer(kind=i_def)             :: mesh_index
    type(field_type),       pointer :: vert_adv_coeffs
    character(str_def)              :: field_name

    mesh_index = find_mesh_index(mesh_id)
    field_name = 'reversible_vert_adv_coeffs'
    vert_adv_coeffs => reversible_vert_adv_coeffs_list(mesh_index)
    call check_initialised_field(vert_adv_coeffs, field_name, mesh_id)

  end function get_reversible_vert_adv_coeffs

end module wt_advective_update_alg_mod
