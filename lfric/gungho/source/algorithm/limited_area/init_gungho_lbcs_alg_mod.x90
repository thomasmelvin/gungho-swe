!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Initialisation of analytical LBC fields.
module init_gungho_lbcs_alg_mod

  use clock_mod,                       only: clock_type
  use constants_mod,                   only: i_def, r_def, str_def
  use field_mod,                       only: field_type
  use field_collection_mod,            only: field_collection_type
  use formulation_config_mod,          only: moisture_formulation,    &
                                             moisture_formulation_dry
  use fs_continuity_mod,               only: W2, W3, Wtheta
  use geometric_constants_mod,         only: get_da_at_w2
  use initialization_config_mod,       only: lbc_option,             &
                                             lbc_option_gungho_file, &
                                             lbc_option_um2lfric_file
  use log_mod,                         only: log_event,         &
                                             log_scratch_space, &
                                             LOG_LEVEL_INFO
  use limited_area_constants_mod,      only: get_boundary_mask, &
                                             get_lbc_mask
  use lfric_xios_read_mod,             only: read_state
  use mesh_mod,                        only: mesh_type
  use variable_fields_mod,             only: init_variable_fields,  &
                                             update_variable_fields
  use linked_list_mod,                 only: linked_list_type
  use mr_indices_mod,                  only: nummr,             &
                                             mr_names

  implicit none

  private
  public :: init_lbcs_analytic_alg, &
            init_lbcs_file_alg,     &
            update_lbcs_file_alg,   &
            combine_lbc_winds,      &
            define_boundary_u

  contains

  !> @brief   Copy the LBCs from the prognostic fields.
  !> @details The prognostic fields have been defined analytically.
  !!          We define the LBCs to be these initial conditions - so
  !!          the LBCs are created by copying the prognostic fields in the
  !!          LBC region, as defined by the LBC masks. This
  !!          gives a standalone limited-area model that is forced only
  !!          by the interior.
  !> @param[in]     prognostic_fields The collection of prognostics
  !> @param[in,out] lbc_fields        The collection of LBC fields
  subroutine init_lbcs_analytic_alg( prognostic_fields, lbc_fields )

    implicit none

    type( field_collection_type ), intent(in)    :: prognostic_fields
    type( field_collection_type ), intent(inout) :: lbc_fields

    type( field_type ), pointer :: theta => null()
    type( field_type ), pointer :: u     => null()
    type( field_type ), pointer :: rho   => null()
    type( field_type ), pointer :: exner => null()
    type( field_type ), pointer :: mr => null()

    type( field_type ), pointer :: lbc_theta  => null()
    type( field_type ), pointer :: lbc_u      => null()
    type( field_type ), pointer :: lbc_rho    => null()
    type( field_type ), pointer :: lbc_exner  => null()
    type( field_type ), pointer :: lbc_mr  => null()
    type( field_type ), pointer :: boundary_u => null()

    type( field_type ), pointer :: w2_lbc_mask      => null()
    type( field_type ), pointer :: w3_lbc_mask      => null()
    type( field_type ), pointer :: wtheta_lbc_mask  => null()
    type( field_type ), pointer :: w2_boundary_mask => null()

    character(str_def)          :: lbc_name
    integer(i_def)              :: imr
    type(mesh_type), pointer    :: mesh => null()

    theta => prognostic_fields%get_field( 'theta' )
    u     => prognostic_fields%get_field( 'u' )
    rho   => prognostic_fields%get_field( 'rho' )
    exner => prognostic_fields%get_field( 'exner' )

    mesh => theta%get_mesh()
    w2_lbc_mask      => get_lbc_mask( W2, mesh%get_id() )
    w3_lbc_mask      => get_lbc_mask( W3, mesh%get_id() )
    wtheta_lbc_mask  => get_lbc_mask( wtheta, mesh%get_id() )
    w2_boundary_mask => get_boundary_mask( W2, mesh%get_id() )

    lbc_theta  => lbc_fields%get_field( 'lbc_theta' )
    lbc_u      => lbc_fields%get_field( 'lbc_u' )
    lbc_rho    => lbc_fields%get_field( 'lbc_rho' )
    lbc_exner  => lbc_fields%get_field( 'lbc_exner' )
    boundary_u => lbc_fields%get_field( 'boundary_u_driving' )

    call invoke( X_times_Y( lbc_u,      u,     w2_lbc_mask ),     &
                 X_times_Y( lbc_rho,    rho,   w3_lbc_mask ),     &
                 X_times_Y( lbc_exner,  exner, w3_lbc_mask ),     &
                 X_times_Y( lbc_theta,  theta, wtheta_lbc_mask ), &
                 X_times_Y( boundary_u, u,     w2_boundary_mask ) )

    if ( moisture_formulation /= moisture_formulation_dry ) then
      do imr = 1, nummr

        lbc_name = trim( 'lbc_' // adjustl(mr_names(imr)) )
        mr => prognostic_fields%get_field( mr_names(imr) )
        lbc_mr => lbc_fields%get_field( lbc_name )

        call invoke( X_times_Y( lbc_mr, mr, wtheta_lbc_mask ) )

      enddo

    endif

    nullify( w2_lbc_mask, w3_lbc_mask, wtheta_lbc_mask, w2_boundary_mask )
    nullify( theta, u, rho, exner, mr )
    nullify( lbc_theta, lbc_u, lbc_rho, lbc_exner, lbc_mr, boundary_u )
    nullify( mesh )

  end subroutine init_lbcs_analytic_alg

  !> @brief   Read the time-varying LBCs from a file.
  !> @details Initialise the LBCs, that are read in and updated using
  !!          a time-axis.
  !> @param[in,out] lbc_times_list  The LBC time axis list
  !> @param[in]     clock           Clock
  !> @param[in,out] lbc_fields      The LBC field collection
  subroutine init_lbcs_file_alg( lbc_times_list, clock, lbc_fields )

    implicit none

    type( field_collection_type ), intent(inout) :: lbc_fields
    type(linked_list_type),        intent(in)    :: lbc_times_list
    class(clock_type),             intent(in)    :: clock

    call read_state( lbc_fields )
    call init_variable_fields( lbc_times_list, &
                               clock, lbc_fields )

    if ( clock%is_initialisation() ) then

      ! Map to derived fields, e.g. winds in W2H and Wtheta to W2
      select case( lbc_option )
      case ( lbc_option_gungho_file )
        call combine_lbc_winds( lbc_fields, extensive=.true. )

      case ( lbc_option_um2lfric_file )
        ! Note that map_lbc_inputs will rebalance the winds, so
        ! that call needs to come before combining the winds.
        call map_lbc_inputs( lbc_fields )
        call combine_lbc_winds( lbc_fields, extensive=.false. )

      case default
        call log_event('This lbc_option not available', LOG_LEVEL_INFO)
      end select

      ! Define boundary_u_driving
      call define_boundary_u( lbc_fields )

    end if

  end subroutine init_lbcs_file_alg

  !> @brief   Update the time-varying LBCs from a file.
  !> @details Update the LBCs, that are read in and updated using
  !!          a time-axis.
  !> @param[in]     lbc_times_list  The LBC time axis list
  !> @param[in]     clock           Clock
  !> @param[in,out] lbc_fields      The LBC field collection
  subroutine update_lbcs_file_alg( lbc_times_list, clock, lbc_fields )

    implicit none

    type( field_collection_type ), intent(inout) :: lbc_fields
    type(linked_list_type),        intent(in)    :: lbc_times_list
    class(clock_type),             intent(in)    :: clock

    call update_variable_fields( lbc_times_list, &
                                 clock,lbc_fields )

    ! Map to derived fields, e.g. winds in W2H and Wtheta to W2
    select case( lbc_option )
      case ( lbc_option_gungho_file )
        call combine_lbc_winds( lbc_fields, extensive=.true. )

      case ( lbc_option_um2lfric_file )
        call map_lbc_inputs( lbc_fields )
        call combine_lbc_winds( lbc_fields, extensive=.false. )

      case default
        call log_event('This lbc_option not available', LOG_LEVEL_INFO)
    end select

    ! Define boundary_u_driving
    call define_boundary_u( lbc_fields )

  end subroutine update_lbcs_file_alg

  !> @brief   Combine horizontal and vertical winds
  !> @details The horizontal winds are read in as W2H, and the vertical
  !!          winds are read in as Wtheta. This combines them into a
  !!          single W2 field.
  !> @param[in,out] fields  The collection of lbc fields
  subroutine combine_lbc_winds( fields, extensive )

    use combine_w2_field_kernel_mod, only: combine_w2_field_kernel_type

    implicit none

    type( field_collection_type ), intent(inout) :: fields
    logical, intent(in)                          :: extensive
    type(field_type), pointer                    :: wind => null()
    type(field_type), pointer                    :: h_wind => null()
    type(field_type), pointer                    :: v_wind => null()

    type( field_type ), pointer :: dA => null()
    integer(i_def)              :: mesh_id

    write(log_scratch_space,'(A)') "Combining winds "
    call log_event(log_scratch_space, LOG_LEVEL_INFO)

    h_wind => fields%get_field("lbc_h_u")
    v_wind => fields%get_field("lbc_v_u")
    wind => fields%get_field("lbc_u")

    if (extensive)then
      call invoke( combine_w2_field_kernel_type(wind, h_wind, v_wind))
    else
      mesh_id = wind%get_mesh_id()
      dA => get_da_at_w2(mesh_id)
      call invoke( combine_w2_field_kernel_type(wind, h_wind, v_wind),    &
                   inc_X_times_Y(wind, dA) )
    end if

  end subroutine combine_lbc_winds

  !> @brief   Define the LBC wind on the solver boundary
  !> @details Define boundary_u by applying the w2_boundary_mask
  !!          to lbc_u
  !> @param[in,out] lbc_fields  The collection of lbc fields
  subroutine define_boundary_u( lbc_fields )

    implicit none

    type( field_collection_type ), intent(inout) :: lbc_fields
    type( field_type ), pointer :: lbc_field  => null()
    type( field_type ), pointer :: boundary_u => null()
    type( field_type ), pointer :: w2_boundary_mask => null()

    type( mesh_type ), pointer :: mesh => null()

    lbc_field  => lbc_fields%get_field( 'lbc_u' )
    boundary_u => lbc_fields%get_field( 'boundary_u_driving' )

    mesh => lbc_field%get_mesh()
    w2_boundary_mask => get_boundary_mask( W2, mesh%get_id() )

    call invoke( X_times_Y( boundary_u, lbc_field, w2_boundary_mask ) )

    ! Print max and min
    lbc_field  => lbc_fields%get_field( 'lbc_u' )
    call lbc_field%log_minmax(LOG_LEVEL_INFO, 'lbc_u')

    lbc_field      => lbc_fields%get_field( 'lbc_theta' )
    call lbc_field%log_minmax(LOG_LEVEL_INFO, 'lbc_theta')

    lbc_field      => lbc_fields%get_field( 'lbc_rho' )
    call lbc_field%log_minmax(LOG_LEVEL_INFO, 'lbc_rho')

    lbc_field      => lbc_fields%get_field( 'lbc_exner' )
    call lbc_field%log_minmax(LOG_LEVEL_INFO, 'lbc_exner')

    nullify( boundary_u, lbc_field, w2_boundary_mask, mesh )

  end subroutine define_boundary_u

  !> @brief   Map from LBC fields read from file to derived LBC fields.
  !> @details LBC files from the UM contain rho*r**2 and specific humidities
  !>          whereas LFRic needs dry rho and mixing ratios.  So manipulate
  !>          these accordingly.
  !> @param[in,out] lbc_fields  The collection of lbc fields
  subroutine map_lbc_inputs( lbc_fields )
    use map_um_lbc_inputs_alg_mod,     only: map_um_lbc_inputs
    use moist_dyn_mod,                 only: num_moist_factors, &
                                             gas_law, total_mass, water
    use geometric_constants_mod,       only: get_height
    use planet_config_mod,             only: radius,  rd, p_zero, kappa, &
                                             cp, gravity
    use lbc_balance_kernel_mod,        only: lbc_balance_kernel_type
    use sample_eos_rho_kernel_mod,     only: sample_eos_rho_kernel_type
    use moist_dyn_gas_kernel_mod,      only: moist_dyn_gas_kernel_type
    implicit none

    type( field_collection_type ), intent(inout) :: lbc_fields

    type(field_type), pointer :: lbc_rho_r2 => null()
    type(field_type), pointer :: lbc_rho => null()
    type(field_type), pointer :: lbc_q => null()
    type(field_type), pointer :: lbc_qcl => null()
    type(field_type), pointer :: lbc_qcf => null()
    type(field_type), pointer :: lbc_qrain => null()
    type(field_type), pointer :: lbc_m_v => null()
    type(field_type), pointer :: lbc_m_cl => null()
    type(field_type), pointer :: lbc_m_ci => null()
    type(field_type), pointer :: lbc_m_r => null()
    type(field_type)          :: lbc_moist_dyn(num_moist_factors)
    type(field_type), pointer :: lbc_theta  => null()
    type(field_type), pointer :: lbc_exner  => null()
    type(field_type), pointer :: lbc_v_u => null()

    type(mesh_type),  pointer :: mesh => null()
    type(field_type), pointer :: w3_lbc_mask => null()
    type(field_type), pointer :: height_w3 => null()

    ! The interior of the LBC fields for rho and exner need to have
    ! sensible values to avoid numerical errors for kernels that
    ! redundantly use them either in the model or from diagnostic output.
    ! Choose a fill value for the domain interior that is an
    ! acceptable physical value.
    real(r_def), parameter    :: EXNER_RHO_FILL_VALUE = 0.2_r_def

    integer(i_def)            :: imd

    write(log_scratch_space,'(A)') 'Recovering density, and mixing ratios for LBCs. '
    call log_event(log_scratch_space, LOG_LEVEL_INFO)

    lbc_rho_r2 => lbc_fields%get_field( 'lbc_rho_r2' )
    lbc_rho    => lbc_fields%get_field( 'lbc_rho' )
    lbc_q      => lbc_fields%get_field( 'lbc_q' )
    lbc_qcl    => lbc_fields%get_field( 'lbc_qcl' )
    lbc_qcf    => lbc_fields%get_field( 'lbc_qcf' )
    lbc_qrain  => lbc_fields%get_field( 'lbc_qrain' )
    lbc_m_v    => lbc_fields%get_field( 'lbc_m_v' )
    lbc_m_ci   => lbc_fields%get_field( 'lbc_m_ci' )
    lbc_m_cl   => lbc_fields%get_field( 'lbc_m_cl' )
    lbc_m_r    => lbc_fields%get_field( 'lbc_m_r' )
    lbc_theta  => lbc_fields%get_field( 'lbc_theta' )
    lbc_exner  => lbc_fields%get_field( 'lbc_exner' )
    lbc_v_u    => lbc_fields%get_field( 'lbc_v_u' )

    mesh        => lbc_exner%get_mesh()
    height_w3   => get_height(W3, mesh%get_id())
    w3_lbc_mask => get_lbc_mask(W3, mesh%get_id())

    call lbc_theta%log_minmax(LOG_LEVEL_INFO, 'lbc_theta')
    call lbc_q%log_minmax(LOG_LEVEL_INFO, 'lbc_q')

    call map_um_lbc_inputs(lbc_q, lbc_qcl, lbc_qcf, lbc_qrain, lbc_rho_r2, &
                           lbc_m_v, lbc_m_cl, lbc_m_ci, lbc_m_r, lbc_rho   &
                           )

    ! Update factors for moist dynamics.
    ! The implementation here is comparable with moisture_formulation_traditional
    ! but since the LBCs don't necessarily use all moisture fields (i.e. that
    ! are in the mr array), we don't use moist_dyn_factors_alg to
    ! set this up.
    do imd=1,3
      call lbc_q%copy_field_properties(lbc_moist_dyn(imd))
    end do
    call invoke( moist_dyn_gas_kernel_type(lbc_moist_dyn(gas_law), lbc_m_v),    &
                 setval_c( lbc_moist_dyn(total_mass), 1.0_r_def),               &
                 inc_X_plus_Y(lbc_moist_dyn(total_mass), lbc_m_v),              &
                 setval_c( lbc_moist_dyn(water), 1.0_r_def),                    &

    ! Initialize hydrostatically balanced exner field.
    ! This will also recalculate the dry density to satisfy the
    ! equation of state
                 setval_c(lbc_exner, EXNER_RHO_FILL_VALUE),                     &
                 lbc_balance_kernel_type(lbc_exner, lbc_rho, lbc_theta,         &
                                         lbc_moist_dyn, height_w3, w3_lbc_mask, &
                                         gravity, p_zero, kappa, rd, cp),       &
                 sample_eos_rho_kernel_type(lbc_rho, lbc_exner, lbc_theta,      &
                                            lbc_moist_dyn(gas_law),             &
                                            kappa, rd, p_zero),                 &
    ! Set vertical component of wind to zero
                 setval_c(lbc_v_u, 0.0_r_def) )

    call lbc_rho%log_minmax(LOG_LEVEL_INFO, 'lbc_rho')
    call lbc_exner%log_minmax(LOG_LEVEL_INFO, 'lbc_exner')
    call lbc_m_v%log_minmax(LOG_LEVEL_INFO, 'lbc_m_v')
    call lbc_m_cl%log_minmax(LOG_LEVEL_INFO, 'lbc_m_cl')
    call lbc_m_ci%log_minmax(LOG_LEVEL_INFO, 'lbc_m_ci')
    call lbc_m_r%log_minmax(LOG_LEVEL_INFO, 'lbc_m_r')

end subroutine map_lbc_inputs

end module init_gungho_lbcs_alg_mod
