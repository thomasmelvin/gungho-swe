!-----------------------------------------------------------------------------
! (c) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief   Remap the inputs from an LBC file to the appropriate prognostic
!>          variables for GungHo
!> @details The LBC inputs are currently provided as specific humidities and
!>          a total density.  This routine converts them to the equivalent
!>          mixing ratios and dry density.
module map_um_lbc_inputs_alg_mod

  use field_mod,                      only: field_type
  use fs_continuity_mod,              only: W3
  use constants_mod,                  only: i_def, r_def
  use sample_wtheta_to_w3_kernel_mod, only: sample_wtheta_to_w3_kernel_type
  use geometric_constants_mod,        only: get_height
  use planet_config_mod,              only: radius

  implicit none

  public  :: map_um_lbc_inputs

contains

  !> @brief   Remap the inputs from an LBC file to the appropriate prognostic
  !>          variables for GungHo
  !> @details The LBC inputs are currently provided as specific humidities and
  !>          a total density.  This routine converts them to the equivalent
  !>          mixing ratios and dry density.
  !> @param[in]     q      vapour specific humidity
  !> @param[in]     qcl    liquid specific humidity
  !> @param[in]     qcf    frozen specific humidity
  !> @param[in]     qrain  rain specific humidity
  !> @param[in]     rho_r2 wet density multiplied by radius squared
  !> @param[in,out] m_v    vapour mixing ratio
  !> @param[in,out] m_cl   liquid mixing ratio
  !> @param[in,out] m_ci   frozen mixing ratio
  !> @param[in,out] m_r    rain mixing ratio
  !> @param[in,out] rho    dry density
  subroutine map_um_lbc_inputs( q, qcl, qcf, qrain, rho_r2, &
                                m_v, m_cl, m_ci, m_r, rho   &
                                )

    implicit none

    type(field_type), intent(in)    :: q, qcl, qcf, qrain, rho_r2
    type(field_type), intent(inout) :: m_v, m_cl, m_ci, m_r, rho
    type(field_type), pointer       :: height_w3 => null()
    type(field_type)                :: radius_w3
    type(field_type)                :: qsum
    type(field_type)                :: qsum_w3
    integer(i_def)                  :: mesh_id

    mesh_id     =  rho%get_mesh_id()
    height_w3   => get_height( W3, mesh_id )

    ! Convert to a total air density
    ! rho = rho/r/r
    ! at this stage rho is not yet dry
    call height_w3%copy_field_properties( radius_w3 )

    call invoke( a_plus_X( radius_w3, radius, height_w3 ), &
                 X_divideby_Y( rho, rho_r2, radius_w3 ),   &
                 inc_X_divideby_Y( rho, radius_w3 ) )

    ! Next we need the specific humidity variables
    ! Can get rho_d = rho_T(1 - S)
    ! Where S = sum of q's
    ! Then m_i = qi/(1-S)
    ! Note below the field qsum = (1 - S).
    ! We also average qsum to the rho location for the recovery
    ! of the dry density.

    call q%copy_field_properties( qsum )
    call rho%copy_field_properties( qsum_w3 )

    call invoke( setval_c( qsum, 1.0_r_def ),      &
                 inc_X_minus_Y( qsum, q ),         &
                 inc_X_minus_Y( qsum, qcl ),       &
                 inc_X_minus_Y( qsum, qcf ),       &
                 inc_X_minus_Y( qsum, qrain ),     &
                 X_divideby_Y( m_v, q, qsum ),     &
                 X_divideby_Y( m_cl, qcl, qsum ),  &
                 X_divideby_Y( m_ci, qcf, qsum ),  &
                 X_divideby_Y( m_r, qrain, qsum ), &
                 sample_wtheta_to_w3_kernel_type( qsum_w3, qsum ), &
                 inc_X_times_Y( rho, qsum_w3 )     &
                 )

  end subroutine map_um_lbc_inputs

end module map_um_lbc_inputs_alg_mod
