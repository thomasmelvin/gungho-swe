##############################################################################
# (c) Crown copyright 2020 Met Office. All rights reserved.
# The file LICENCE, distributed with this code, contains details of the terms
# under which the code may be used.
##############################################################################
"""Entities to store data collected by MetadataExtractor"""
import logging
from typing import Dict, Set, List, Optional

LOGGER = logging.getLogger("reconfigurator.entities")


# Tell pylint to allow large constructors on entities, allow too few public
# methods as public attributes can accessed directly, allow many
# instance attributes

# pylint: disable=too-few-public-methods, too-many-instance-attributes


class Field:
    """Stores attributes of a metadata field"""

    def __init__(self, unique_id: str,
                 field_group_id: str,
                 active: bool = False,
                 checksum: bool = False,
                 long_name: Optional[str] = None,
                 standard_name: Optional[str] = None,
                 units: Optional[str] = None,
                 grid_ref: Optional[str] = None,
                 mesh_id: Optional[int] = None,
                 function_space: Optional[str] = None,
                 order: Optional[int] = None,
                 io_driver: Optional[str] = None,
                 data_type: Optional[str] = None,
                 timestep: Optional[str] = None,
                 vertical_dimension_id: Optional[str] = None,
                 domain_ref: Optional[str] = None):
        """

        :param unique_id: Identifier for metadata field
        :param field_group_id: Identifier for the field group this field is in
        :param active: Whether or not the field is activated in the Rose suite
        :param checksum: Flag to control if a checksum of the final field state
                         is generated
        :param long_name: Descriptive name, particularly when there
                          is no standard name
        :param standard_name: Descriptive name as defined by the
                               CF/CMIP/etc convention
        :param units: Unit of measurement
        :param grid_ref: Which XIOS grid the field is being output on
                         (work in progress)
        :param mesh_id: Which LFRic grid the field is being held against
        :param function_space: The function space within which the field exists
        :param order: Finite element order
        :param io_driver: Which driver LFRic uses to convert the field to
                          the correct structure to transmit to XIOS
        :param data_type: INT/REAL
        :param timestep: If field is restricted, timestep value will be present
                         to specify on which timesteps the field is calculated
        :param vertical_dimension_id: The unique_id of the vertical dimension
        :param domain_ref: The id of the domain in the iodef file
        """
        # pylint: disable=too-many-arguments
        self.unique_id = unique_id
        self.field_group_id = field_group_id
        self.active = active
        self.checksum = checksum
        self.long_name = long_name
        self.standard_name = standard_name
        self.units = units
        self.grid_ref = grid_ref
        self.mesh_id = mesh_id
        self.function_space = function_space
        self.order = order
        self.io_driver = io_driver
        self.data_type = data_type
        self.timestep = timestep  # for timestep restricted fields
        self.vertical_dimension_id = vertical_dimension_id
        self.non_spatial_dimension = []
        self.domain_ref = domain_ref


class FieldGroup:
    """Stores a field group and its fields"""

    def __init__(self, name: str, timestep: str = "1ts",
                 temporal: str = "instant",
                 vertical_dimension_id: Optional[str] = None):
        """
        :param name: Identifier for the field group
        :param timestep: Default timestep on which fields in the group
                         will be generated by LFRic
        :param temporal: Which statistical operation is applied to fields in
                         the group (always instant)
        :param vertical_dimension_id: The id of the vertical dimension of
                                      fields in this group
        """
        self.name = name
        self.timestep = timestep
        self.temporal = temporal
        self.vertical_dimension_id = vertical_dimension_id
        # Initialised collection to be an empty set of [Field.unique_id]s
        self._fields: Set = set()

    def add_field(self, field: Field):
        """Add a field to the field group"""
        self._fields.add(field.unique_id)

    def get_fields(self):
        """:return: Sorted list of fields contained within the group"""
        return sorted(self._fields)


class OutputStreamField:
    """Stores attributes of an output stream field"""

    def __init__(self, unique_id: int, field_ref: str = "",
                 temporal: str = "instant"):
        """
        :param unique_id: Identifier for the output stream field within the
                          output stream
        :param field_ref: Field.unique_id of the field to output
        :param temporal: Which statistical operation is applied to the field
        """
        self.unique_id = unique_id
        self.field_ref = field_ref
        self.temporal = temporal


class OutputStream:
    """Stores attributes of an output stream and its output fields"""

    def __init__(self, unique_id: int, name: Optional[str] = None,
                 timestep: Optional[str] = None):
        """
        :param unique_id: Identifier for the output stream
        :param name: Name of the output file
        :param timestep: Timestep frequency on which the file is output
                         (and any statistics are applied over)
        """
        self.unique_id: int = unique_id
        self.name: str = name
        self.timestep: str = timestep
        # Initialised collection to be empty set
        # of [OutputStreamField.unique_id: OutputStreamField]
        self._stream_fields: Dict[int, OutputStreamField] = {}
        # XIOS file convention
        # always UGRID, even if the file conforms to additional standards
        self.convention: str = 'UGRID'

    def add_field(self, field: OutputStreamField):
        """Adds an output field to the output stream's field collection"""
        self._stream_fields.update({field.unique_id: field})

    def get_fields(self) -> [OutputStreamField]:
        """
        :return: Sorted list of output stream fields
        """
        return sorted(self._stream_fields.values(),
                      key=lambda field: field.unique_id)


class VerticalDimension:
    """Stores attributes of a vertical dimension"""

    def __init__(self,
                 unique_id: str,
                 active: bool = False,
                 domain_top: Optional[float] = None,
                 extrusion_method: Optional[str] = None,
                 name: Optional[str] = None,
                 positive_direction: Optional[str] = None,
                 primary_axis: Optional[str] = None,
                 level_definition: Optional[List[float]] = None,
                 number_of_layers: Optional[int] = None,
                 units: Optional[str] = None):
        """
        :param unique_id: Identifier for the vertical dimension
        :param active: Whether the vertical dimension is used by any field
        :param domain_top: The height of the top of the vertical dimension
        :param extrusion_method: The method to be used in LFRic to define the
                                 level heights
        :param name: Name of the vertical dimension
        :param positive_direction: The direction of the axis, either up or down
        :param primary_axis: String equal to 'true' or 'false' stating if LFRic
                             is extruded using this dimension
        :param level_definition: A list of boundaries of the vertical levels
        :param number_of_layers: The number of levels in the vertical dimension
        :param units: The unit of measure for the dimension
        """
        self.unique_id = unique_id
        self.active = active
        self.domain_top = domain_top
        self.extrusion_method = extrusion_method
        self.name = name.replace(" ", "_") if name else None
        self.positive_direction = positive_direction
        self.primary_axis = primary_axis
        self.level_definition = level_definition
        self.number_of_layers = number_of_layers
        self.units = units
        self.size = None

    def __eq__(self, other):
        """Evaluates if two dimensions are functionally identical"""
        return self.domain_top == other.domain_top and \
            self.extrusion_method == other.extrusion_method and \
            self.positive_direction == other.positive_direction and \
            self.primary_axis == other.primary_axis and \
            self.level_definition == other.level_definition and \
            self.number_of_layers == other.number_of_layers and \
            self.units == other.units

    def format_level_definition(self) -> None:
        """Formats the level definition into a string suitable for XIOS"""

        values = None

        # Currently setting the mutable level values to the level number
        # This will need to be updated when real heights are added to LFRic
        if self.unique_id.startswith("model_vert_axis_"):
            if self.unique_id.endswith("_half_levels"):
                self.size = int(self.number_of_layers)
                values = ' '.join(str(i + 0.5) for i in range(self.size))

            elif self.unique_id.endswith("_full_levels"):
                self.size = int(self.number_of_layers) + 1
                values = ' '.join(str(i) for i in range(self.size))

        # Currently setting fixed levels to the values in the metadata
        # This may need to be updated as with model vertical axes?
        elif self.unique_id.startswith("fixed_vert_axis_"):
            self.size = len(self.level_definition)
            values = ' '.join(str(i) for i in self.level_definition)

        if values is not None:
            self.level_definition = f"(0, {self.size - 1}) [{values}]"
        else:
            raise ValueError(f"Unrecognised vertical dimension unique id "
                             f"format '{self.unique_id}'")

    def validate(self) -> None:
        """Raise an exception if vertical dimension is not fully specified"""

        required_attributes = ['name', 'number_of_layers', 'primary_axis',
                               'positive_direction', 'unique_id', 'units']
        dimension_invalid = False

        # Must have required attributes
        for attribute in required_attributes:
            if getattr(self, attribute) is None:
                dimension_invalid = True
                LOGGER.error("Vertical dimension '%s' missing '%s' attribute",
                             self.unique_id, attribute)

        # Should have either level definition or top and extrusion
        if self.level_definition is not None:
            if self.domain_top is not None or \
                    self.extrusion_method is not None:
                dimension_invalid = True
                LOGGER.error("Manually-defined vertical dimension '%s' should "
                             "not specify a domain top or extrusion method",
                             self.unique_id)
        else:
            if self.domain_top is None or not self.extrusion_method:
                dimension_invalid = True
                LOGGER.error("Generated vertical dimension '%s' requires both "
                             "a domain top and an extrusion method",
                             self.unique_id)

        if dimension_invalid:
            raise ValueError(f"Vertical dimension '{self.unique_id}' invalid")


class Grid:
    """Stores attributes of a grid"""

    def __init__(self,
                 domain: Optional[str] = None,
                 axes: Optional[List[str]] = None):
        """
        :param domain: The domain of the grid
        :param axes: A list of the unique ids of the axes that form the grid
        """
        self.domain = domain
        self.axes = axes
        self.unique_id = f"{'__'.join(axis for axis in axes)}__{domain}_grid"

    def __eq__(self, other):
        return self.domain == other.domain and self.axes == other.axes


class NonSpatialDimension:
    """Stores attributes of a non-spatial dimension."""

    def __init__(self,
                 name: str,
                 definition: List,
                 unit: str):
        """
        :param name: Name of the non-spatial dimension
        :param definition: Definition of the non-spatial dimension
        :param unit: The unit of measure used by the non-spatial dimension
        """

        self.name = name.replace(" ", "_")
        self.definition = self._parse_definition(definition)
        self.unit = unit
        self.is_numerical = None

    def __eq__(self, other):
        """Evaluates if two dimensions are functionally identical.
        :param other: The other object that is being compared"""
        return self.name == other.name

    def add_unit(self, unit: str):
        """Adds the unit of measure to the non-spatial dimension.
        :param unit: The unit of measure being added"""
        if not self.unit:
            self.unit = unit
        elif self.unit != unit:
            LOGGER.error("There is a mismatch in non-spatial dimension units"
                         " of measure. %s %s %s", self.name, self.unit, unit)

    def add_definition(self, definition: List):
        """Adds a non-spatial dimension definition if one does not already
        exist.
        :param definition: The non-spatial dimension definition to be added
"""
        if not self.definition:
            self.definition = self._parse_definition(definition)
        else:
            LOGGER.error("""%s already has a definition
Definition = %s
Tried to add = %s
""", self.name, self.definition, definition)

    def _parse_definition(self, definition: List[str]) -> str:
        """Takes a list of values from a non-spatial dimension definition
        and returns it in the required format for the 'iodef.xml' file.
        :param definition: A list to strings containing a points on a
        non-spatial dimension
        :return: A string containing the values in the required format"""
        value = None
        if definition:
            self.size = len(definition)
            self.is_numerical = True
            stripped_def = []
            for element in definition:
                element = element.replace("'", "")
                element = element.replace('"', '')
                stripped_def.append(element)
                for char in element:
                    if not char.isdigit() and not char == ".":
                        self.is_numerical = False

            self.size = len(stripped_def)
            value = f"(0, {len(stripped_def) - 1}) " \
                    f"[{' '.join(str(i) for i in stripped_def)}]"

        return value
